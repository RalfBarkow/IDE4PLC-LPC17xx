"Copyright © 2012-2014 Eric Nicolás Pernia.This file is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>."PLC_ClassWithIdentifier subclass: #PLC_Element	instanceVariableNames: 'inputs outputs'	classVariableNames: 'Elements ElementsCreated'	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_Element commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Element is xxxxxxxxx.Instance Variables	inputs:		<Object>	outputs:		<Object>inputs	- xxxxxoutputs	- xxxxx!!PLC_Element methodsFor: 'connectableBlocks' stamp: 'EricPernia 10/5/2012 22:30'!actualArgumentFor: aPLC_ConnectableBlock atInput: anInputNumber	"Devuelve el actualArgument, es decir, la variable o literal que contiene el elemento"				^ (aPLC_ConnectableBlock blockConnectedToInput: anInputNumber) element actualArgument! !!PLC_Element methodsFor: 'connectableBlocks' stamp: 'EricPernia 10/5/2012 22:30'!actualArgumentFor: aPLC_ConnectableBlock atOutput: anOutputNumber	"Devuelve el actualArgument, es decir, la variable o literal que contiene el elemento"				^ (aPLC_ConnectableBlock blockConnectedToOutput: anOutputNumber) element actualArgument! !!PLC_Element methodsFor: 'connectableBlocks' stamp: 'EricPernia 11/5/2013 12:56'!addInput	"Agrega una entrada al elemento."	"| decl |		decl := PLC_SimpleSymbolicVarDecl 		newWithDataType: PLC_DataTypes Bool		andInitialValue: nil 		andIdentifier: 'IN' , ( self inputs size ) asString.	self inputs add: ( PLC_SimpleSymbolicVar newWithDeclaration: decl andDataValue: nil )."			self inputs add: ( PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: nil 		andIdentifier: 'IN' , ( self inputs size ) asString		).! !!PLC_Element methodsFor: 'connectableBlocks' stamp: 'EricPernia 11/5/2013 12:56'!addOutput	"Agrega una salida al elemento."	"| decl |		decl := PLC_SimpleSymbolicVarDecl 		newWithDataType: PLC_DataTypes Bool		andInitialValue: nil 		andIdentifier: 'OUT' , ( self outputs size ) asString.	self outputs add: ( PLC_SimpleSymbolicVar newWithDeclaration: decl andDataValue: nil )."		self outputs add: ( PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: nil 		andIdentifier: 'OUT' , ( self outputs size ) asString ).! !!PLC_Element methodsFor: 'connectableBlocks' stamp: 'EricPernia 6/12/2013 01:48'!connectableBlockInputs	"Cantidad de entradas para el bloque conectable."	^ self inputs size.! !!PLC_Element methodsFor: 'connectableBlocks' stamp: 'EricPernia 6/12/2013 01:49'!connectableBlockOutputs	"Cantidad de salidas para el bloque conectable."	^ self outputs size.! !!PLC_Element methodsFor: 'connectableBlocks' stamp: 'EricPernia 5/2/2013 17:00'!connectionToAddElement: aPLC_ElemenMorph inBlock: aPLC_ConnectableBlock	"Devuelve la conexion para añadirle un nuevo elemento."	^ aPLC_ConnectableBlock connectedAtOutput: 1.		"Hacer que compruebe aquí si puede conectar o no el elemento nuevo pidiendole a los bloques de sus extremos si lo permiten"		"SI NO PERMITEN DEVUELVEN NIL"		"PISO ESTE METODO EN RightPowerRail "! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 11/10/2012 03:37'!isActualArgumentReader	"Devuelve true si el elemento es una ActualArgumentReader."	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 11/10/2012 03:37'!isActualArgumentWriter	"Devuelve true si el elemento es una ActualArgumentWriter."	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 11/6/2012 18:59'!isCoil	"Devuelve true si el elemento es una Bobina."	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 10/14/2012 04:52'!isConnection	"Devuelve siempre false. ESTE METODO ES UNA MUGRE PARA QUE FUNCIONE FACIL close branch"	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 11/6/2012 18:19'!isContact	"Devuelve true si el elemento es un Contacto."	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 11/15/2013 15:21'!isFunction	"Devuelve true si el elemento es un llamado grafico a Funcion."	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 11/15/2013 15:21'!isFunctionBlock	"Devuelve true si el elemento es un llamado grafico a Bloque de Funcion."	^ false.	! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 10/9/2012 23:55'!isLeftPowerRail	"Devuelve true si el elemento es un Riel Izquierdo"	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 10/9/2012 23:55'!isRightPowerRail	"Devuelve true si el elemento es un Riel Derecho"	^ false.! !!PLC_Element methodsFor: 'testing' stamp: 'EricPernia 10/10/2012 18:53'!isVerticalLink	"Devuelve true si el elemento es un Vertical Link."	^ false.! !!PLC_Element methodsFor: 'initialize-release' stamp: 'EricPernia 6/12/2013 01:47'!initialize	"Inicializaciones"	self inputs: OrderedCollection new.	self outputs: OrderedCollection new.! !!PLC_Element methodsFor: 'accessing' stamp: 'EricPernia 6/12/2013 01:44'!inputs		^ inputs! !!PLC_Element methodsFor: 'accessing' stamp: 'EricPernia 6/12/2013 01:44'!inputs: anObject		inputs := anObject! !!PLC_Element methodsFor: 'accessing' stamp: 'EricPernia 6/12/2013 01:44'!outputs		^ outputs! !!PLC_Element methodsFor: 'accessing' stamp: 'EricPernia 6/12/2013 01:44'!outputs: anObject		outputs := anObject! !!PLC_Element methodsFor: 'parallel' stamp: 'EricPernia 9/13/2013 17:28'!acceptParallel	"Responde true si el elemento acepta estar conectado en una rama paralela en Ladder.		|	c1		 c2			b1	|-----|  |----------|  |-----+-----(  )------|	|				    |	|	c3			    |	|-----|  |---------==----+		|		Quiero agregar un elemento en la conexión ==		"	^ false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Element class	instanceVariableNames: ''!!PLC_Element class methodsFor: 'class initialization' stamp: 'EricPernia 11/22/2013 16:54'!initialize	super initialize.		ElementsCreated ifNil: [		ElementsCreated := false		].	! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 9/24/2012 16:24'!ActualArgumentReader	^ PLC_ActualArgumentReader new.! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 9/24/2012 16:24'!ActualArgumentWriter 	^ PLC_ActualArgumentWriter new.! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 9/30/2012 20:36'!Coil	"Devuelve la única instancia del elemento NOCoil"		ElementsCreated ifFalse: [self createElements].		^ Elements at: #Coil! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 10/9/2012 21:18'!LeftPowerRail	^ PLC_LeftPowerRail new.! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 9/1/2012 19:57'!NCContact	"Devuelve la única instancia del elemento NCContact"		ElementsCreated ifFalse: [self createElements].		^ Elements at: #NCContact! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 9/30/2012 20:35'!NCoil	"Devuelve la única instancia del elemento NCCoil"		ElementsCreated ifFalse: [self createElements].		^ Elements at: #NCoil! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 9/1/2012 19:54'!NOContact	"Devuelve la única instancia del elemento NOContact"		ElementsCreated ifFalse: [self createElements].		^ Elements at: #NOContact! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 10/9/2012 21:43'!RightPowerRail	^ PLC_RightPowerRail new.! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 10/10/2012 01:47'!VerticalLink	^ PLC_VerticalLink new.! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 9/1/2012 19:52'!clearElements	"Borra las instancias únicas creadas."	Elements := Dictionary new.	ElementsCreated := false.	! !!PLC_Element class methodsFor: 'instance creation' stamp: 'EricPernia 11/9/2012 20:20'!createElements	"Crea los elementos que son de instancia única."	Elements := Dictionary new.		"Contactos"		Elements at: #NOContact put: PLC_Contact new.	(Elements at: #NOContact) modifier: PLC_IL_Modifiers NullModifier. 	(Elements at: #NOContact) morph: PLC_NOContactMorph. 		Elements at: #NCContact put: PLC_Contact new.	(Elements at: #NCContact) modifier: PLC_IL_Modifiers NModifier. 	(Elements at: #NCContact) morph: PLC_NCContactMorph. 		Elements at: #Coil put: PLC_Coil new.	(Elements at: #Coil) modifier: PLC_IL_Modifiers NullModifier. 	(Elements at: #Coil) morph: PLC_CoilMorph. 		"Bobinas"		Elements at: #NCoil put: PLC_Coil new.	(Elements at: #NCoil) modifier: PLC_IL_Modifiers NModifier.	(Elements at: #NCoil) morph: PLC_NCoilMorph.		Elements at: #NCoil put: PLC_Coil new.	(Elements at: #NCoil) modifier: PLC_IL_Modifiers NModifier.	(Elements at: #NCoil) morph: PLC_NCoilMorph.	ElementsCreated := true.! !!PLC_Element class methodsFor: 'elements' stamp: 'EricPernia 5/31/2013 21:35'!AllLadderElementNamesStrings.	^ self Elements keys.! !PLC_Element subclass: #PLC_LeftPowerRail	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_LeftPowerRail commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_LeftPowerRail is xxxxxxxxx.Instance Variables!!PLC_LeftPowerRail methodsFor: 'connectableBlocks' stamp: 'EricPernia 9/30/2012 19:46'!connectionToAddElement: aPLC_ElemenMorph inBlock: aPLC_ConnectableBlock	"Devuelve la conexion para añadirle un nuevo elemento."	^ aPLC_ConnectableBlock connectedAtInput: 1.		"Hacer que compruebe aquí si puede conectar o no el elemento nuevo pidiendole a los bloques de sus extremos si lo permiten"		"SI NO PERMITEN DEVUELVEN NIL"! !!PLC_LeftPowerRail methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 13:38'!generateCodeIn: aProgramAccumulator for: aPLC_ConnectableBlock	"Agrega los objetos que genera a aProgramAccumulator.	Como es una instancia única debo pasarle como parámetro el bloque para el cual quiero que compile	para que pueda leer sus entradas y salidas."		PLC_CPU firstCheckFlag_BORRAME: true.		(1 to: self outputs size) do: [ :each | 			(aPLC_ConnectableBlock blockConnectedToOutput: each) generateCodeIn: aProgramAccumulator.				PLC_CPU firstCheckFlag_BORRAME: true.				].! !!PLC_LeftPowerRail methodsFor: 'testing' stamp: 'EricPernia 10/9/2012 23:56'!isLeftPowerRail	"Devuelve true si el elemento es un Riel Izquierdo"	^ true.! !!PLC_LeftPowerRail methodsFor: 'graphic element' stamp: 'EricPernia 4/29/2013 16:06'!graphicElementFor: aConnectableBlock	"Devuelve el Elemento grafico (Morph)."		^ PLC_LeftPowerRailMorph newFromElement: self.! !!PLC_LeftPowerRail methodsFor: 'accessing' stamp: 'EricPernia 6/7/2012 16:05'!outputs	^ outputs! !!PLC_LeftPowerRail methodsFor: 'accessing' stamp: 'EricPernia 6/7/2012 16:05'!outputs: anObject	outputs := anObject! !!PLC_LeftPowerRail methodsFor: 'library' stamp: 'EricPernia 5/31/2013 21:44'!keyword	"Devuelve el symbol del elemento"	^ #LeftPowerRail ! !PLC_Element subclass: #PLC_RightPowerRail	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_RightPowerRail commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_RightPowerRail is xxxxxxxxx.Instance Variables!!PLC_RightPowerRail methodsFor: 'connectableBlocks' stamp: 'EricPernia 11/5/2013 12:56'!addInput	"Agrega una entrada al elemento."	self inputs add: ( PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: nil 		andIdentifier: 'IN' ).! !!PLC_RightPowerRail methodsFor: 'connectableBlocks' stamp: 'EricPernia 5/2/2013 17:00'!connectionToAddElement: aPLC_ElemenMorph inBlock: aPLC_ConnectableBlock	"Devuelve la conexion para añadirle un nuevo elemento."	^ aPLC_ConnectableBlock connectedAtInput: 1.		"Hacer que compruebe aquí si puede conectar o no el elemento nuevo pidiendole a los bloques de sus extremos si lo permiten"		"SI NO PERMITEN DEVUELVEN NIL"! !!PLC_RightPowerRail methodsFor: 'compilation' stamp: 'EricPernia 11/6/2013 16:49'!generateCodeIn: aProgramAccumulator for: aPLC_ConnectableBlock	"Agrega los objetos que genera a aProgramAccumulator.	Como es una instancia única debo pasarle como parámetro el bloque para el cual quiero que compile	para que pueda leer sus entradas y salidas."		"PLC_CPU firstCheckFlag_BORRAME: true."	! !!PLC_RightPowerRail methodsFor: 'testing' stamp: 'EricPernia 10/9/2012 23:56'!isRightPowerRail	"Devuelve true si el elemento es un Riel Derecho"	^ true.! !!PLC_RightPowerRail methodsFor: 'graphic element' stamp: 'EricPernia 4/29/2013 16:06'!graphicElementFor: aConnectableBlock	"Devuelve el Elemento grafico (Morph)."		^ PLC_RightPowerRailMorph new.! !!PLC_RightPowerRail methodsFor: 'library' stamp: 'EricPernia 5/31/2013 21:43'!keyword	"Devuelve el symbol del elemento"	^ #RightPowerRail ! !!PLC_RightPowerRail methodsFor: 'initialize-release' stamp: 'EricPernia 6/12/2013 02:38'!initialize	"Inicializaciones"	super initialize.		self addInput.! !PLC_Element subclass: #PLC_VerticalLink	instanceVariableNames: 'numberOfCompiledImputs objectTypeDecl objectVarDecl'	classVariableNames: 'numberOfInstances'	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_VerticalLink commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_VerticalLink is xxxxxxxxx.Instance Variables	numberOfCompiledImputs:		<Object>	objectTypeDecl:		<Object>	objectVarDecl:		<Object>numberOfCompiledImputs	- xxxxxobjectTypeDecl	- xxxxxobjectVarDecl	- xxxxx!!PLC_VerticalLink methodsFor: 'testing' stamp: 'EricPernia 10/10/2012 18:54'!isVerticalLink	"Devuelve true si el elemento es un Vertical Link."	^ true.! !!PLC_VerticalLink methodsFor: 'graphic element' stamp: 'EricPernia 4/29/2013 16:06'!graphicElementFor: aConnectableBlock	"Devuelve el Elemento grafico (Morph)."		^ PLC_VerticalLinkMorph newFromElement: self.! !!PLC_VerticalLink methodsFor: 'accessing' stamp: 'EricPernia 11/3/2012 23:56'!numberOfCompiledImputs	^ numberOfCompiledImputs! !!PLC_VerticalLink methodsFor: 'accessing' stamp: 'EricPernia 11/3/2012 23:56'!numberOfCompiledImputs: anObject	numberOfCompiledImputs := anObject! !!PLC_VerticalLink methodsFor: 'accessing' stamp: 'EricPernia 11/4/2012 02:58'!objectTypeDecl	^ objectTypeDecl! !!PLC_VerticalLink methodsFor: 'accessing' stamp: 'EricPernia 11/4/2012 02:58'!objectTypeDecl: anObject	objectTypeDecl := anObject! !!PLC_VerticalLink methodsFor: 'accessing' stamp: 'EricPernia 11/4/2012 02:58'!objectVarDecl	^ objectVarDecl! !!PLC_VerticalLink methodsFor: 'accessing' stamp: 'EricPernia 11/4/2012 02:58'!objectVarDecl: anObject	objectVarDecl := anObject! !!PLC_VerticalLink methodsFor: 'connectableBlocks' stamp: 'EricPernia 11/6/2013 15:48'!addInput	"Agrega una entrada al elemento."	self inputs add: ( PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: nil 		andIdentifier: 'IN' , ( self inputs size ) asString		andCategory: PLC_VariableCategoryDecl tempVarDecls		).	"PLC_VariableCategoryDecl tempVarDecls      Es un parche para que compile bien"! !!PLC_VerticalLink methodsFor: 'connectableBlocks' stamp: 'EricPernia 11/6/2013 15:50'!addOutput	"Agrega una salida al elemento Vertical Link."	self outputs add: ( PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: nil 		andIdentifier: 'OUT'		andCategory: PLC_VariableCategoryDecl tempVarDecls		).			"PLC_VariableCategoryDecl tempVarDecls      Es un parche para que compile bien"! !!PLC_VerticalLink methodsFor: 'initialize-release' stamp: 'EricPernia 6/12/2013 03:33'!initialize	"Inicializaciones"		super initialize.		"Genera el nombre único de cada VL"	self identifier: 'VL' , self class numberOfInstances asString.	self class numberOfInstances: self class numberOfInstances + 1.		"Inicio a flase el flag que indica si tiene todas sus entradas"	self numberOfCompiledImputs: 0.		! !!PLC_VerticalLink methodsFor: 'compilation' stamp: 'EricPernia 6/17/2013 02:25'!createObjectTypeDec	"Devuelve el Objeto de programa Declaracion de tipos de datos que genera."		| typeDecl |		typeDecl := PLC_TypeDecl 		newWithDataType: self objectStructDec 		andIdentifier: ( self identifier , '_TYPE_STRUCT' ).		typeDecl description: 'Estructura de Enlace Vertical.'.	"Guarda y devuelve el Objeto de porgrama generado"	self objectTypeDecl: typeDecl.			^ typeDecl.! !!PLC_VerticalLink methodsFor: 'compilation' stamp: 'EricPernia 11/6/2013 17:02'!createObjectVarDec	"Devuelve el Objeto de programa Declaracion de Variable que genera."		| varDecl |		"Genero una nueva declaracion de variable de tipo de dato estructurado"	varDecl := PLC_SymbolicVariableDecl		newWithDataType: self objectTypeDec 		andInitialValue: nil 		andIdentifier: self identifier , '_VAR_STRUCT'.			" P A R C H E     le clavo una categoria para que haga bien lo de pxPOU->	no hace falta este parche se lo pone el acumulador despues"		"varDecl variableCategory: PLC_VariableCategoryDecl tempVarDecls.	"		"Guarda y devuelve el Objeto de porgrama generado"	self objectVarDecl: varDecl.		^ varDecl.! !!PLC_VerticalLink methodsFor: 'compilation' stamp: 'EricPernia 11/6/2013 16:40'!generateCodeIn: aProgramAccumulator for: aPLC_ConnectableBlock	"Agrega los objetos que genera a aProgramAccumulator.	Como es una instancia única debo pasarle como parámetro el bloque para el cual quiero que compile	para que pueda leer sus entradas y salidas."		| instruction |		"Suma 1 a la cantidad de entradas que va guardando"	self numberOfCompiledImputs: self numberOfCompiledImputs + 1.			( self numberOfCompiledImputs = self inputs size )		ifTrue: [					"Creo las instrucciones:				OR NOMBREVL.VL_IN1				OR NOMBREVL.VL_IN2				...				OR NOMBREVL.VL_INn-1							NOTA: va ahasta n-1 pues el ultimo valor de entrada lo tiene almacenado en el CR"								( 1 to:  (self inputs size - 1 ) ) do: [ :index |								"Creo una nueva instrucción OR"				instruction := PLC_OR_Instruction new.					instruction modifiers add: PLC_IL_Modifiers NullModifier.										"Aquí le creo de operando a la instrucion OR un objeto que cuando este 				le pide que se compile da por ejemplo, NOMBREVARSTRUC.VARITEM"								instruction operands add: (					PLC_StructureItem 						newWithItem: self objectVarOperand  						andItem: ( self inputs at: index ) operand					).									"Agrego los objetos generados, estos deben entender ilCompile y cCompile"				"self halt.	instruction cCompile."								aProgramAccumulator add: instruction.							"aProgramAccumulator compiledBody cCompile."								].							"Si el VL tiene más de una salida debe almacenar el valor de esta para repetirlo en las demas"					( self outputs size > 1)				ifTrue: [								"Creo la instruccion ST NOMBREVL.VL_OUT "													"Creo una nueva instrucción ST"					instruction := PLC_ST_Instruction new.					instruction modifiers add: PLC_IL_Modifiers NullModifier.									"Aquí le creo de operando a la instrucion ST un objeto que cuando este 					le pide que se compile da por ejemplo, NOMBREVARSTRUC.VARITEM"					instruction operands add: (						PLC_StructureItem 							newWithItem: self objectVarOperand  							andItem: self outputs first operand						).										"Agrego los objetos generados, estos deben entender ilCompile y cCompile"				"self halt.	instruction cCompile."					aProgramAccumulator add: instruction.							"aProgramAccumulator compiledBody cCompile."																			"Finalmente compilo todos los bloques conectables conectados a las salidas de este VL					intercalando instrucciones LD NOMBREVL.VLOUT para darle al circuito siguiente el					valor correcto de salida. Recordar que el VL repite su valor de salida en todas sus 					salidas"								"Creo la instruccion LD NOMBREVL.VL_OUT "													"Creo una nueva instrucción LD"					instruction := PLC_LD_Instruction new.					instruction modifiers add: PLC_IL_Modifiers NullModifier.									"Aquí le creo de operando a la instrucion ST un objeto que cuando este 					le pide que se compile da por ejemplo, NOMBREVARSTRUC.VARITEM"					instruction operands add: (						PLC_StructureItem 							newWithItem: self objectVarOperand  							andItem: self outputs first operand						).								"Compilo el bloque conectado a la primer salida"					(aPLC_ConnectableBlock blockConnectedToOutput: 1) generateCodeIn: aProgramAccumulator.								"Compilo los bloques conectados a partir de la segunda salida anteponiendo LD NOMBREVL.VL_OUT"					(2 to: self outputs size) do: [ :each | 											"Agrego la instruccion LD NOMBREVL.VL_OUT "				"self halt.	instruction cCompile."						aProgramAccumulator add: instruction.							"aProgramAccumulator compiledBody cCompile."													"Compilo el bloque conectado a la primer salida"						(aPLC_ConnectableBlock blockConnectedToOutput: each) generateCodeIn: aProgramAccumulator.												].					]				ifFalse: [										"Si solo tiene una sola salida simplemente le digo al bloque conectado a 					esa que genere sus objetos de porgrama"					(aPLC_ConnectableBlock blockConnectedToOutput: 1) generateCodeIn: aProgramAccumulator.										].			] 				ifFalse: [							"Creo una nueva instrucción ST"			instruction := PLC_ST_Instruction new.				instruction modifiers add: PLC_IL_Modifiers NullModifier.										"Aquí le creo de operando a la instrucion ST un objeto que cuando este 			le pide que se compile da por ejemplo, NOMBREVARSTRUC.VARITEM"			instruction  operands add: (				PLC_StructureItem 					newWithItem: self objectVarOperand  					andItem: ( self inputs at: self numberOfCompiledImputs ) operand				).							"Agrego los objetos generados, estos deben entender ilCompile y cCompile"				"self halt.	instruction cCompile."			aProgramAccumulator add: instruction.									"aProgramAccumulator compiledBody cCompile."			].! !!PLC_VerticalLink methodsFor: 'compilation' stamp: 'EricPernia 11/6/2013 15:51'!objectStructDec	"Devuelve el Objeto de programa Declaracion de Variable que genera."		| structDecl outVarDecl |		"Genero una nueva declaracion de tipo de dato estructurado"	structDecl := PLC_StructureDecl newWithIdentifier: ( self identifier , '_STRUCT' ).	"Agrego al tipo las variables de entrada del VL. 	No necesita la ultima pues cuando compila su valor viene en el CR"	self inputs do: [ :each |				" P A R C H E     le clavo una categoria para que haga bien lo de pxPOU->"			"each variableCategory: PLC_VariableCategoryDecl tempVarDecls.	"				structDecl add: each. 		].		"Agrego al tipo la única variable de salida del VL pues en todas las salidas va el mismo valor"		outVarDecl := self outputs first.		" P A R C H E     le clavo una categoria para que haga bien lo de pxPOU->"		"outVarDecl variableCategory: PLC_VariableCategoryDecl tempVarDecls.	"				structDecl add: outVarDecl.				^ structDecl.! !!PLC_VerticalLink methodsFor: 'compilation' stamp: 'EricPernia 11/4/2012 03:03'!objectTypeDec	"Devuelve el Objeto de programa Declaracion de tipos de datos que genera."		self objectTypeDecl		ifNil: [			^ self createObjectTypeDec.			]		ifNotNil:  [			^ self objectTypeDecl.			]! !!PLC_VerticalLink methodsFor: 'compilation' stamp: 'EricPernia 11/4/2012 03:03'!objectVarDec	"Devuelve el Objeto de programa Declaracion de Variable que genera."		self objectVarDecl		ifNil: [			^ self createObjectVarDec.			]		ifNotNil:  [			^ self objectVarDecl.			]! !!PLC_VerticalLink methodsFor: 'compilation' stamp: 'EricPernia 11/6/2013 15:55'!objectVarOperand	"Devuelve el Objeto de programa Operando de Variable."			^ self objectVarDec operand.! !!PLC_VerticalLink methodsFor: 'library' stamp: 'EricPernia 5/31/2013 21:43'!keyword	"Devuelve el symbol del elemento"	^ #VerticalLink ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_VerticalLink class	instanceVariableNames: ''!!PLC_VerticalLink class methodsFor: 'accesors' stamp: 'EricPernia 11/3/2012 20:40'!numberOfInstances	^ numberOfInstances! !!PLC_VerticalLink class methodsFor: 'accesors' stamp: 'EricPernia 11/3/2012 20:40'!numberOfInstances: aNumber	numberOfInstances := aNumber.! !!PLC_VerticalLink class methodsFor: 'class initialization' stamp: 'EricPernia 11/3/2012 20:38'!initialize	"Inicializacion de la clase"	numberOfInstances := 0.! !PLC_Element subclass: #PLC_Contact	instanceVariableNames: 'modifier morph'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_Contact commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Contact is xxxxxxxxx.Instance Variables	modifier:		<Object>	morph:		<Object>modifier	- xxxxxmorph	- xxxxx!!PLC_Contact methodsFor: 'conectableBlocks' stamp: 'EricPernia 5/5/2013 21:27'!actualArgumentFor: aPLC_ConnectableBlock	"Devuelve el actualArgument que en este caso es una variable simbolica simple"				^ ( self connectableBlockActualArgumentFor: aPLC_ConnectableBlock ) element actualArgument! !!PLC_Contact methodsFor: 'conectableBlocks' stamp: 'EricPernia 5/5/2013 21:27'!connectableBlockActualArgumentFor: aPLC_ConnectableBlock	"Devuelve el actualArgument"				^ (aPLC_ConnectableBlock blockConnectedToInput: 2).! !!PLC_Contact methodsFor: 'conectableBlocks' stamp: 'EricPernia 10/31/2012 15:32'!connectionToAddElement: aPLC_ElemenMorph inBlock: aPLC_ConnectableBlock	"Devuelve la conexion para añadirle un nuevo elemento."	^ aPLC_ConnectableBlock connectedAtOutput: 1.		"Hacer que compruebe aquí si puede conectar o no el elemento nuevo pidiendole a los bloques de sus extremos si lo permiten"		"SI NO PERMITEN DEVUELVEN NIL"! !!PLC_Contact methodsFor: 'compilation' stamp: 'EricPernia 11/6/2013 16:23'!generateCodeIn: aProgramAccumulator for: aPLC_ConnectableBlock	"Agrega los objetos que genera a aObjectProgram.	Como es una instancia única debo pasarle como parámetro el bloque para el cual quiero que compile	para que pueda leer sus entradas y salidas."		| instruction |		PLC_CPU firstCheckFlag_BORRAME		ifTrue: [			instruction := PLC_LD_Instruction new.				] 		ifFalse: [			instruction := PLC_AND_Instruction new.				].			PLC_CPU firstCheckFlag_BORRAME: false.	instruction modifiers add: self modifier.		instruction operands add: (self actualArgumentFor: aPLC_ConnectableBlock).					"Agrego los objetos generados, estos deben entende ilCompile y cCompile"	aProgramAccumulator add: instruction.	(aPLC_ConnectableBlock blockConnectedToOutput: 1) generateCodeIn: aProgramAccumulator.! !!PLC_Contact methodsFor: 'testing' stamp: 'EricPernia 11/6/2012 18:19'!isContact	"Devuelve true si el elemento es un Contacto."	^ true.! !!PLC_Contact methodsFor: 'graphic element' stamp: 'EricPernia 5/1/2013 18:38'!graphicElementFor: aConnectableBlock	"Devuelve el Elemento grafico (Morph)."		"Esto esta feo, es casi igual a preguntar por al clase"	( self modifier isNullModifier )		ifTrue: [			^ PLC_NOContactMorph newFromConnectableBlock: aConnectableBlock.			] 		ifFalse: [			^ PLC_NCContactMorph newFromConnectableBlock: aConnectableBlock.			].		! !!PLC_Contact methodsFor: 'accessing' stamp: 'EricPernia 9/1/2012 20:41'!modifier	^ modifier! !!PLC_Contact methodsFor: 'accessing' stamp: 'EricPernia 9/1/2012 20:41'!modifier: anObject	modifier := anObject! !!PLC_Contact methodsFor: 'accessing' stamp: 'EricPernia 10/18/2012 10:54'!morph	^ morph! !!PLC_Contact methodsFor: 'accessing' stamp: 'EricPernia 10/18/2012 10:54'!morph: anObject	morph := anObject! !!PLC_Contact methodsFor: 'initialize-release' stamp: 'EricPernia 6/12/2013 01:51'!initialize	"Inicializaciones"	super initialize.		self addInput.	self addInput.	self addOutput.! !!PLC_Contact methodsFor: 'parallel' stamp: 'EricPernia 9/13/2013 17:30'!acceptParallel	"Responde true si el elemento acepta estar conectado en una rama paralela en Ladder.		|	c1		 c2			b1	|-----|  |----------|  |-----+-----(  )------|	|				    |	|	c3			    |	|-----|  |---------==----+		|		Quiero agregar un elemento en la conexión ==		"	^ true.! !PLC_Element subclass: #PLC_GraphicPOUCall	instanceVariableNames: 'declaration instance numberOfCompiledImputs network'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_GraphicPOUCall commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_GraphicPOUCall is xxxxxxxxx.Instance Variables	declaration:		<Object>	instance:		<Object>	network:		<Object>	numberOfCompiledImputs:		<Object>declaration	- xxxxxinstance	- xxxxxnetwork	- xxxxxnumberOfCompiledImputs	- xxxxx!!PLC_GraphicPOUCall methodsFor: 'initialize-release' stamp: 'EricPernia 6/21/2013 18:35'!initialize	"Inicializaciones"	"Inicio en 0 la variable que indica la cantidad de entradas cableadas compiladas"	self numberOfCompiledImputs: 0.! !!PLC_GraphicPOUCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 05:01'!buildElementInputs	"Devuelve la Coleccion de Entradas del elemento la cual genera a partir su Declaracion.	Corresponden a los pines de Entrada del bloque conectable ordenados según las 	categorías de variables."	inputs := self buildInputs. 	inputs addAll: self buildInOuts. 	inputs add: self instance.			^ inputs.! !!PLC_GraphicPOUCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 05:02'!buildElementOutputs	"Devuelve la Coleccion de Salidas del elemento la cual genera a partir su Declaracion.	Corresponden a los pines de Entrada del bloque conectable ordenados según las 	categorías de variables."	outputs := self buildOutputs. 	outputs addAll: self buildInOuts. 	outputs add: self instance.				^ outputs.! !!PLC_GraphicPOUCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 05:37'!buildInOuts	"Devuelve las Entrada-Salidas de su declaración."	| decls |	decls := OrderedCollection new.	decls addAll: self declaration inOutVarDecls.		^ decls.! !!PLC_GraphicPOUCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 05:36'!buildInputs	"Devuelve las Entradas de su declaración."	| decls |	decls := OrderedCollection new.	decls addAll: self declaration inputVarDecls.		^ decls.! !!PLC_GraphicPOUCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 05:35'!buildOutputs	"Devuelve las Salidas de su declaración."	| decls |	decls := OrderedCollection new.	decls addAll: self declaration outputVarDecls.		^ decls.! !!PLC_GraphicPOUCall methodsFor: 'declaration' stamp: 'EricPernia 6/21/2013 16:21'!declaration	"Devuelve la declaración asociada a su instancia"	^ declaration.! !!PLC_GraphicPOUCall methodsFor: 'graphic element' stamp: 'EricPernia 6/22/2013 02:10'!graphicElementFor: aConnectableBlock	"Devuelve el Elemento grafico (Morph)."	^ PLC_BlockMorph newFromConnectableBlock: aConnectableBlock.! !!PLC_GraphicPOUCall methodsFor: 'compilation' stamp: 'EricPernia 11/10/2012 17:00'!numberOfWiredInputsFor: aPLC_ConnectableBlock	"Devuelve el numero de entradas cableadas sin contar la primera"	| cont |				cont := 0.	( 2 to: self inputs size ) do: [ :each |		(aPLC_ConnectableBlock blockConnectedToInput: each) element isActualArgumentReader			ifFalse: [				cont := cont + 1.				]. 				].			! !!PLC_GraphicPOUCall methodsFor: 'accessing' stamp: 'EricPernia 6/21/2013 16:21'!declaration: anObject		declaration := anObject! !!PLC_GraphicPOUCall methodsFor: 'accessing' stamp: 'EricPernia 9/3/2013 00:38'!instance		^ instance.! !!PLC_GraphicPOUCall methodsFor: 'accessing' stamp: 'EricPernia 9/3/2013 00:38'!instance: anObject		instance := anObject! !!PLC_GraphicPOUCall methodsFor: 'accessing' stamp: 'EricPernia 11/19/2013 00:27'!network		^ network.! !!PLC_GraphicPOUCall methodsFor: 'accessing' stamp: 'EricPernia 11/19/2013 00:28'!network: anObject		network := anObject! !!PLC_GraphicPOUCall methodsFor: 'accessing' stamp: 'EricPernia 6/12/2013 00:41'!numberOfCompiledImputs		^ numberOfCompiledImputs! !!PLC_GraphicPOUCall methodsFor: 'accessing' stamp: 'EricPernia 6/12/2013 00:41'!numberOfCompiledImputs: anObject		numberOfCompiledImputs := anObject! !!PLC_GraphicPOUCall methodsFor: 'parallel' stamp: 'EricPernia 9/13/2013 17:34'!acceptParallel	"Responde true si la POU a la que llama este llamado a POU acepta estar conectada en una rama paralela en Ladder.			Quiero agregar un elemento llamado a POU en la conexión ==		|	c1		 c2			b1	|-----|  |----------|  |-----+-----(  )------|	|				    |	|	c3			    |	|-----|  |---------==----+		|	"	"Se lo delega a la declaraion de POU que conoce"	^ self declaration acceptParallel.! !PLC_GraphicPOUCall subclass: #PLC_GraphicFunctionBlockCall	instanceVariableNames: ''	classVariableNames: 'numberOfInstances'	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_GraphicFunctionBlockCall commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_GraphicFunctionBlockCall is xxxxxxxxx.Instance Variables!!PLC_GraphicFunctionBlockCall methodsFor: 'compilation' stamp: 'EricPernia 11/19/2013 05:17'!generateCodeIn: aProgramAccumulator for: aPLC_ConnectableBlock	"Agrega los objetos que genera a aObjectProgram.	Como es una instancia única debo pasarle como parámetro el bloque para el cual quiero que compile	para que pueda leer sus entradas y salidas."		| instruction pouCall fluxVarDecl structItem |		PLC_CPU firstCheckFlag_BORRAME		ifTrue: [						"Genero: LD true - Para comenzar con el CR en 1 en el caso que la bobina 			o bloque de funcion este conectado directamente a la barra izquieda"						instruction := PLC_LD_Instruction new.				instruction modifiers add: PLC_IL_Modifiers NullModifier. 			instruction operands add: (PLC_Literal newWithDataType: PLC_DataType Bool andDataValue: true).								"Agrego los objetos generados, estos deben entende ilCompile y cCompile"			aProgramAccumulator add: instruction.					].	PLC_CPU firstCheckFlag_BORRAME: false.		"Creo la declaración de variable FLUX que la usan los llamados graficos a F y FB"	fluxVarDecl := PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: nil 		andIdentifier: 'FLUX'. 	"Le asigno la categoría temp asi no pone el pxPOU-> en C"	fluxVarDecl variableCategory: PLC_VariableCategoryDecl tempVarDecls.			"Creo un llamado textual a POU y le asigno la instancia"		pouCall := PLC_TextualFunctionBlockCall 		newFromDeclaration: self declaration 		andInstanceOperand: self instance operand.		"Instance debe ser un instance Operand"						"Asigno la primer salida del llamado a pou a la variable FLUX"	(pouCall outputAssignments at: 1) 		actualArgument: fluxVarDecl operand.					"Asigno las entradas del llamado a pou a partir de la 2da"	( 2 to: pouCall inputAssignments size ) do: [ :index |		(pouCall inputAssignments at: index) 			actualArgument: (				self actualArgumentFor: aPLC_ConnectableBlock 					atInput: index			).		].		"Asigno las salidas del llamado a pou a partir de la 2da"	( 2 to: pouCall outputAssignments size ) do: [ :index |		(pouCall outputAssignments at: index) 			actualArgument: (				self actualArgumentFor: aPLC_ConnectableBlock 					atOutput: index			).		].			"pouCall returnAssignment explore.""	Ver cual es la precedencia en:	pxPOU -> ADD_INT_VAR . IN		a - (pxPOU -> ADD_INT_VAR ) . IN	b - pxPOU -> (ADD_INT_VAR . IN )		es a Esta bien"	"Genero: ST EN"	structItem := PLC_StructureItem		newWithItem: self instance operand		andItem: (			PLC_SymbolicVariableDecl 				newWithDataType:  (pouCall inputAssignments at: 1) formalParameter dataType				andInitialValue: nil 				andIdentifier: (pouCall inputAssignments at: 1) formalParameter identifier 				andCategory: PLC_VariableCategoryDecl tempVarDecls			) operand.		instruction := PLC_ST_Instruction new.	instruction modifiers add: PLC_IL_Modifiers NullModifier.	instruction operands add: structItem.									"Agrego ST EN al Acumulador"	aProgramAccumulator add: instruction.		"Agrego el llamado textual al Acumulador"	aProgramAccumulator add: pouCall.										"Genero: LD FLUX - Restituyo el CR a partir de FLUX"	instruction := PLC_LD_Instruction new.		instruction modifiers add: PLC_IL_Modifiers NullModifier. 	instruction operands add: fluxVarDecl operand.								"Agrego LD FLUX al Acumulador"	aProgramAccumulator add: instruction.			"Le indico al siguiente elemento que genere código"	(aPLC_ConnectableBlock blockConnectedToOutput: 1) generateCodeIn: aProgramAccumulator.! !!PLC_GraphicFunctionBlockCall methodsFor: 'testing' stamp: 'EricPernia 11/15/2013 15:19'!isFunctionBlock	"Devuelve true si el elemento es un llamado grafico a Bloque de Funcion."	^ true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_GraphicFunctionBlockCall class	instanceVariableNames: ''!!PLC_GraphicFunctionBlockCall class methodsFor: 'instance creation' stamp: 'EricPernia 11/22/2013 16:52'!initialize	"Inicializacion de la clase		numberOfInstances guarda el numero de instancias del llamado a FB 	para ponerle un numero distinto a cada instancia de llamado repetido."	numberOfInstances := 0.! !!PLC_GraphicFunctionBlockCall class methodsFor: 'instance creation' stamp: 'EricPernia 11/19/2013 03:13'!newWithDeclaration: pou andNetwork: aNet	"Crea una nueva instancia y le asigana la instancia pasada como parámetro."	| pouCall |		pouCall := self new.		"Asigno la declaración."	pouCall declaration: pou.	pouCall network: aNet.					"Asigno la declaración de instancia. La crea la Declaración. 	En Funciones es única en Programas y FB se crea una nueva."		pouCall instance: (		pou 			instanceDeclForForFBWithIdentifier:				pou typedIdentifier , 				'_VAR_' , 				numberOfInstances asString		). "Le pongo una PLC_SymbolicVariableDecl en lugar de una 		PLC_InstanceVariableDecl para que no agregue el static"		 	"AUMENTA EL NUMERO DE LLAMADOS A FB PARA NO PISAR EL NOMBRE DE INSTANCIA"		numberOfInstances := numberOfInstances + 1.				"AGREGO LA DECLARACION DE VARIABLE DE INSTANCIA A LAS DECLARACIONES VAR"	aNet pouBody pou varDecls add: 		pouCall instance.			"Construye sus entradas y salidas a partir de su declaración."	pouCall buildElementInputs.	pouCall buildElementOutputs.		^ pouCall.! !!PLC_GraphicFunctionBlockCall class methodsFor: 'instance creation' stamp: 'EricPernia 11/19/2013 00:33'!numberOfInstances	"numberOfInstances guarda el numero de instancias del llamado a FB 	para ponerle un numero distinto a cada instancia de llamado repetido."	^ numberOfInstances.! !PLC_GraphicPOUCall subclass: #PLC_GraphicFunctionCall	instanceVariableNames: ''	classVariableNames: 'numberOfCalls'	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_GraphicFunctionCall commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_GraphicFunctionCall is xxxxxxxxx.Instance Variables!!PLC_GraphicFunctionCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 05:03'!buildElementInputs	"Devuelve la Coleccion de Entradas del elemento la cual genera a partir su Declaracion.	Corresponden a los pines de Entrada del bloque conectable ordenados según las 	categorías de variables."	inputs := self buildInputs. 	inputs addAll: self buildInOuts. 	^ inputs.! !!PLC_GraphicFunctionCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 05:02'!buildElementOutputs	"Devuelve la Coleccion de Salidas del elemento la cual genera a partir su Declaracion.	Corresponden a los pines de Entrada del bloque conectable ordenados según las 	categorías de variables."	outputs := self buildOutputs. 	outputs addAll: self buildInOuts. 			^ outputs.! !!PLC_GraphicFunctionCall methodsFor: 'declaration' stamp: 'EricPernia 6/22/2013 04:51'!buildOutputs	"Devuelve la Coleccion de Entradas del elemento la cual genera a partir su Declaracion.	Corresponden a los pines de Entrada del bloque conectable ordenados según las 	categorías de variables."	| firstOutputIdentifier outs |	outs := OrderedCollection new.	 ( self declaration outputVarDecls size > 0 )		ifTrue: [ 			firstOutputIdentifier := ( self declaration outputVarDecls at: 1 ) identifier.			( firstOutputIdentifier = 'ENO' )				ifTrue: [ 					outs add: ( self declaration outputVarDecls at: 1 ).					outs add: self declaration return.					( 2 to: self declaration outputVarDecls size ) do: [ :each |						outs add: ( self declaration outputVarDecls at: each ). 						].					^ outs.											] 				ifFalse: [ 					outs add: self declaration return.					outs addAll: self declaration outputVarDecls. 					^ outs.					].			] 				ifFalse: [ 			outs add: self declaration return.			^ outs.							].! !!PLC_GraphicFunctionCall methodsFor: 'declaration' stamp: 'EricPernia 6/12/2013 00:24'!dataType	^ self declaration return dataType.! !!PLC_GraphicFunctionCall methodsFor: 'testing' stamp: 'EricPernia 11/15/2013 15:20'!isFunction	"Devuelve true si el elemento es un llamado grafico a Funcion."	^ true.! !!PLC_GraphicFunctionCall methodsFor: 'compilation' stamp: 'EricPernia 11/17/2013 13:57'!generateCodeIn: aProgramAccumulator for: aPLC_ConnectableBlock	"Agrega los objetos que genera a aObjectProgram.	Como es una instancia única debo pasarle como parámetro el bloque para el cual quiero que compile	para que pueda leer sus entradas y salidas."		| instruction pouCall fluxVarDecl structItem |		PLC_CPU firstCheckFlag_BORRAME		ifTrue: [						"Genero: LD true - Para comenzar con el CR en 1 en el caso que la bobina 			o bloque de funcion este conectado directamente a la barra izquieda"						instruction := PLC_LD_Instruction new.				instruction modifiers add: PLC_IL_Modifiers NullModifier. 			instruction operands add: (PLC_Literal newWithDataType: PLC_DataType Bool andDataValue: true).								"Agrego los objetos generados, estos deben entende ilCompile y cCompile"			aProgramAccumulator add: instruction.					].	PLC_CPU firstCheckFlag_BORRAME: false.		"Creo la declaración de variable FLUX que la usan los llamados graficos a F y FB"	fluxVarDecl := PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: nil 		andIdentifier: 'FLUX'. 	"Le asigno la categoría temp asi no pone el pxPOU-> en C"	fluxVarDecl variableCategory: PLC_VariableCategoryDecl tempVarDecls.		"Creo un llamado textual a POU y le asigno la instancia"		pouCall := PLC_TextualFunctionCall 		newFromDeclaration: self declaration 		andInstanceOperand: self instance operand.		"Instance debe ser un instance Operand"						"Asigno la primer salida del llamado a pou a la variable FLUX"	(pouCall outputAssignments at: 1) 		actualArgument: fluxVarDecl operand.					"Asigno las entradas del llamado a pou a partir de la 2da"	( 2 to: pouCall inputAssignments size ) do: [ :index |		(pouCall inputAssignments at: index) 			actualArgument: (				self actualArgumentFor: aPLC_ConnectableBlock 					atInput: index			).		].		"Asigno las salidas del llamado a pou a partir de la 2da"	( 2 to: pouCall outputAssignments size ) do: [ :index |		(pouCall outputAssignments at: index) 			actualArgument: (				self actualArgumentFor: aPLC_ConnectableBlock 					atOutput: index + 1			).		].		"Asigno la salida de RETURN del llamado a Funcion"	pouCall returnAssignment		actualArgument: (			self actualArgumentFor: aPLC_ConnectableBlock 				atOutput: 2			).			"pouCall returnAssignment explore.""	Ver cual es la precedencia en:	pxPOU -> ADD_INT_VAR . IN		a - (pxPOU -> ADD_INT_VAR ) . IN	b - pxPOU -> (ADD_INT_VAR . IN )		es a Esta bien"	"Genero: ST EN"	structItem := PLC_StructureItem		newWithItem: self instance operand		andItem: (			PLC_SymbolicVariableDecl 				newWithDataType:  (pouCall inputAssignments at: 1) formalParameter dataType				andInitialValue: nil 				andIdentifier: (pouCall inputAssignments at: 1) formalParameter identifier 				andCategory: PLC_VariableCategoryDecl tempVarDecls			) operand.		instruction := PLC_ST_Instruction new.	instruction modifiers add: PLC_IL_Modifiers NullModifier.	instruction operands add: structItem.									"Agrego ST EN al Acumulador"	aProgramAccumulator add: instruction.		"Agrego el llamado textual al Acumulador"	aProgramAccumulator add: pouCall.										"Genero: LD FLUX - Restituyo el CR a partir de FLUX"	instruction := PLC_LD_Instruction new.		instruction modifiers add: PLC_IL_Modifiers NullModifier. 	instruction operands add: fluxVarDecl operand.								"Agrego LD FLUX al Acumulador"	aProgramAccumulator add: instruction.			"Le indico al siguiente elemento que genere código"	(aPLC_ConnectableBlock blockConnectedToOutput: 1) generateCodeIn: aProgramAccumulator.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_GraphicFunctionCall class	instanceVariableNames: ''!!PLC_GraphicFunctionCall class methodsFor: 'instance creation' stamp: 'EricPernia 11/19/2013 06:21'!newWithDeclaration: decl andNetwork: aNet	"Crea una nueva instancia y le asigana la instancia pasada como parámetro."	| pouCall colec |		pouCall := self new.		"Asigno la declaración."	pouCall declaration: decl.	pouCall network: aNet.		"Asigno la declaración de instancia. La crea la Declaración. 	En Funciones es única en Programas y FB se crea una nueva."		pouCall instance: (		decl instanceDeclForForFBWithIdentifier: nil		). "Le pongo una PLC_SymbolicVariableDecl en lugar de una 		PLC_InstanceVariableDecl para que no agregue el static"				"AGREGO LA DECLARACION DE VARIABLE DE INSTANCIA A LAS DECLARACIONES 	VAR SI NO ESTABA AGREGADA, ESTO ES PARA QUE NO HAYA REPETIDAS"	colec := aNet pouBody pou funInstVarDecls declarations collect: [ :each | each identifier ].	colec detect: [ :each | 			each =  pouCall instance identifier 			] 		ifNone: [ 			aNet pouBody pou funInstVarDecls add: 				pouCall instance			].					"Construye sus entradas y salidas a partir de su declaración."	pouCall buildElementInputs.	pouCall buildElementOutputs.		^ pouCall.! !PLC_Element subclass: #PLC_Coil	instanceVariableNames: 'modifier morph'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_Coil commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Coil is xxxxxxxxx.Instance Variables	modifier:		<Object>	morph:		<Object>modifier	- xxxxxmorph	- xxxxx!!PLC_Coil methodsFor: 'compilation' stamp: 'EricPernia 11/17/2013 07:31'!generateCodeIn: aProgramAccumulator for: aPLC_ConnectableBlock	"Agrega los objetos que genera a aObjectProgram.	Como es una instancia única debo pasarle como parámetro el bloque para el cual quiero que compile	para que pueda leer sus entradas y salidas."		| instruction |			PLC_CPU firstCheckFlag_BORRAME		ifTrue: [						"Genero: LD true - Para comenzar con el CR en 1 en el caso que la bobina 			o bloque de funcion este conectado directamente a la barra izquieda"						instruction := PLC_LD_Instruction new.				instruction modifiers add: PLC_IL_Modifiers NullModifier. 			instruction operands add: (PLC_Literal newWithDataType: PLC_DataType Bool andDataValue: true).								"Agrego los objetos generados, estos deben entende ilCompile y cCompile"			aProgramAccumulator add: instruction.					].	PLC_CPU firstCheckFlag_BORRAME: false.				instruction := PLC_ST_Instruction new.			instruction modifiers add: self modifier.		instruction operands add: (self actualArgumentFor: aPLC_ConnectableBlock).				"Agrego los objetos generados, estos deben entende ilCompile y cCompile"	aProgramAccumulator add: instruction.		(aPLC_ConnectableBlock blockConnectedToOutput: 1) generateCodeIn: aProgramAccumulator.! !!PLC_Coil methodsFor: 'connectableBlocks' stamp: 'EricPernia 5/5/2013 21:26'!actualArgumentFor: aPLC_ConnectableBlock	"Devuelve el actualArgument que en este caso es una variable simbolica simple"				^ ( self connectableBlockActualArgumentFor: aPLC_ConnectableBlock ) element actualArgument! !!PLC_Coil methodsFor: 'connectableBlocks' stamp: 'EricPernia 5/5/2013 21:25'!connectableBlockActualArgumentFor: aPLC_ConnectableBlock	"Devuelve el actualArgument"				^ (aPLC_ConnectableBlock blockConnectedToOutput: 2).! !!PLC_Coil methodsFor: 'connectableBlocks' stamp: 'EricPernia 5/3/2013 02:06'!connectionToAddElement: aPLC_ElemenMorph inBlock: aPLC_ConnectableBlock	"Devuelve la conexion para añadirle un nuevo elemento."	^ aPLC_ConnectableBlock connectedAtOutput: 1.		"Hacer que compruebe aquí si puede conectar o no el elemento nuevo pidiendole a los bloques de sus extremos si lo permiten"		"SI NO PERMITEN DEVUELVEN NIL"! !!PLC_Coil methodsFor: 'graphic element' stamp: 'EricPernia 5/1/2013 18:38'!graphicElementFor: aConnectableBlock	"Devuelve el Elemento grafico (Morph)."			"Esto esta feo, es casi igual a preguntar por al clase"	( self modifier isNullModifier )		ifTrue: [			^ PLC_CoilMorph newFromConnectableBlock: aConnectableBlock.			] 		ifFalse: [			^ PLC_NCoilMorph newFromConnectableBlock: aConnectableBlock.			].! !!PLC_Coil methodsFor: 'accessing' stamp: 'EricPernia 9/1/2012 20:05'!modifier	^ modifier! !!PLC_Coil methodsFor: 'accessing' stamp: 'EricPernia 9/1/2012 20:05'!modifier: anObject	modifier := anObject! !!PLC_Coil methodsFor: 'accessing' stamp: 'EricPernia 10/18/2012 10:59'!morph	^ morph! !!PLC_Coil methodsFor: 'accessing' stamp: 'EricPernia 10/18/2012 10:59'!morph: anObject	morph := anObject! !!PLC_Coil methodsFor: 'testing' stamp: 'EricPernia 11/6/2012 18:59'!isCoil	"Devuelve true si el elemento es una Bobina."	^ true.! !!PLC_Coil methodsFor: 'initialize-release' stamp: 'EricPernia 6/12/2013 01:51'!initialize	"Inicializaciones"	super initialize.		self addInput.	self addOutput.	self addOutput.! !PLC_Element subclass: #PLC_ActualArgument	instanceVariableNames: 'actualArgument'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_ActualArgument commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_ActualArgument is xxxxxxxxx.Instance Variables	actualArgument:		<Object>actualArgument	- xxxxx!!PLC_ActualArgument methodsFor: 'connectableBlocks' stamp: 'EricPernia 9/7/2013 02:02'!addInput	"Agrega una entrada al elemento."	self inputs add: PLC_VoidOpenad new.! !!PLC_ActualArgument methodsFor: 'connectableBlocks' stamp: 'EricPernia 9/7/2013 02:02'!addOutput	"Agrega una salida al elemento."	self outputs add: PLC_VoidOpenad new.! !!PLC_ActualArgument methodsFor: 'connectableBlocks' stamp: 'EricPernia 9/7/2013 02:06'!connectionToAddElement: aPLC_ElemenMorph inBlock: aPLC_ConnectableBlock	"Devuelve la conexion para añadirle un nuevo elemento."	| connectableBlock |		"Busco el contacto, bobina o bloque conectado al actual argument"	connectableBlock := aPLC_ConnectableBlock blockConnectedToOutput: 1.		"Le pido la conexion para añadirle un nuevo elemento"	^ connectableBlock element connectionToAddElement: aPLC_ElemenMorph inBlock: connectableBlock.! !!PLC_ActualArgument methodsFor: 'testing' stamp: 'EricPernia 9/7/2013 02:02'!isActualArgumentReader	"Devuelve true si el elemento es una ActualArgumentReader."	^ false.! !!PLC_ActualArgument methodsFor: 'testing' stamp: 'EricPernia 9/7/2013 02:02'!isActualArgumentWriter	"Devuelve true si el elemento es una ActualArgumentWriter."	^ false.! !!PLC_ActualArgument methodsFor: 'library' stamp: 'EricPernia 9/7/2013 02:03'!keyword	"Devuelve el symbol del elemento"	^ #ActualArgument! !!PLC_ActualArgument methodsFor: 'accessing' stamp: 'EricPernia 9/7/2013 02:02'!actualArgument	^ actualArgument! !!PLC_ActualArgument methodsFor: 'accessing' stamp: 'EricPernia 9/7/2013 02:02'!actualArgument: anObject	actualArgument := anObject! !!PLC_ActualArgument methodsFor: 'graphic element' stamp: 'EricPernia 9/7/2013 02:02'!graphicElementFor: aConnectableBlock	"Devuelve el Elemento grafico (Morph)."		^ PLC_ActualArgumentMorph newWithText: self actualArgument identifier.! !!PLC_ActualArgument methodsFor: 'initialize-release' stamp: 'EricPernia 9/7/2013 02:09'!initialize	"Inicializaciones"	super initialize.		self actualArgument: PLC_VoidOpenad new.! !PLC_ActualArgument subclass: #PLC_ActualArgumentWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_ActualArgumentWriter commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_ActualArgumentWriter is xxxxxxxxx.Instance Variables!!PLC_ActualArgumentWriter methodsFor: 'connectableBlocks' stamp: 'EricPernia 5/3/2013 02:04'!connectionToAddElement: aPLC_ElemenMorph inBlock: aPLC_ConnectableBlock	"Devuelve la conexion para añadirle un nuevo elemento."	| connectableBlock |	"Busco el contacto, bobina o bloque conectado al actual argument"	connectableBlock := aPLC_ConnectableBlock blockConnectedToInput: 1.		"Le pido la conexion para añadirle un nuevo elemento"	^ connectableBlock element connectionToAddElement: aPLC_ElemenMorph inBlock: connectableBlock.! !!PLC_ActualArgumentWriter methodsFor: 'testing' stamp: 'EricPernia 11/10/2012 03:38'!isActualArgumentWriter	"Devuelve true si el elemento es una ActualArgumentWriter."	^ true.! !!PLC_ActualArgumentWriter methodsFor: 'library' stamp: 'EricPernia 5/31/2013 21:41'!keyword	"Devuelve el symbol del elemento"	^ #ActualArgumentWriter! !!PLC_ActualArgumentWriter methodsFor: 'initialize-release' stamp: 'EricPernia 9/7/2013 02:07'!initialize	"Inicializaciones"	super initialize.		self addInput.! !!PLC_ActualArgumentWriter methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 02:39'!accept: anOperand in: aPLC_ConnectableBlock	"Devuelve true acepta el operando que le llega como parámetro.	Necesito pasarle el bloque conectable para que pueda moverse 	a través de las conexiones.	  ______ 	  |		| 	  |		|	--|	      |--  anOperand	  |_____|		"		anOperand isPLCLiteral		ifTrue: [ ^ false ].		anOperand isVariable		ifTrue: [ ^ self acceptVariable: anOperand in: aPLC_ConnectableBlock ].		anOperand isStructItem 		ifTrue: [ ^ self acceptStructItem: anOperand in: aPLC_ConnectableBlock ].		anOperand isVoid		ifTrue: [ ^ true ].! !!PLC_ActualArgumentWriter methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 02:38'!acceptStructItem: aStructItemOperand in: aPLC_ConnectableBlock	"Devuelve true acepta el operando que le llega como parámetro"	"	  ______ 	  |		| 	  |		|	--|	      |--  VAR_STRUCT.VAR_ITEM	  |_____|		"		"Hacer chequeos que faltan"	^ false.! !!PLC_ActualArgumentWriter methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 02:38'!acceptVariable: aVariableOperand in: aPLC_ConnectableBlock	"Devuelve true acepta el operando que le llega como parámetro"	"	  ______ 	  |		| 	  |		|	--|	      |--  VAR	  |_____|		"		"Hacer chequeos que faltan"		"Chequeo 2"	^ self canWriteVariable: aVariableOperand.! !!PLC_ActualArgumentWriter methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 03:08'!canWriteVariable: aVariableOperand	"Devuelve true si la variable (operando) que le llega como parámetro tiene permiso de escritura"	"Todas pueden escribirse menos las inputs es decir:		  ______ 	  |		| 	  |		|	--|	      |--  aVariableOperand	  |_____|		Se fija si puede ponerle un valor a aVariableOperand	"		^ ( aVariableOperand declaration variableCategory varType ~= '_INPUT' )! !PLC_ActualArgument subclass: #PLC_ActualArgumentReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Elements-GraphicLanguages'!!PLC_ActualArgumentReader commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_ActualArgumentReader is xxxxxxxxx.Instance Variables!!PLC_ActualArgumentReader methodsFor: 'testing' stamp: 'EricPernia 11/10/2012 03:38'!isActualArgumentReader	"Devuelve true si el elemento es una ActualArgumentReader."	^ true.! !!PLC_ActualArgumentReader methodsFor: 'library' stamp: 'EricPernia 5/31/2013 21:43'!keyword	"Devuelve el symbol del elemento"	^ #ActualArgumentReader! !!PLC_ActualArgumentReader methodsFor: 'initialize-release' stamp: 'EricPernia 9/7/2013 02:05'!initialize	"Inicializaciones"	super initialize.		self addOutput.! !!PLC_ActualArgumentReader methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 02:39'!accept: anOperand in: aPLC_ConnectableBlock	"Devuelve true acepta el operando que le llega como parámetro.	Necesito pasarle el bloque conectable para que pueda moverse 	a través de las conexiones.				   ______ 	 			   |		  | 				   |		  |	anOperand  --|	        |--  			 	   |______|		"		anOperand isPLCLiteral		ifTrue: [ ^ self acceptLiteral: anOperand in: aPLC_ConnectableBlock ].		anOperand isVariable		ifTrue: [ ^ self acceptVariable: anOperand in: aPLC_ConnectableBlock ].		anOperand isStructItem 		ifTrue: [ ^ self acceptStructItem: anOperand in: aPLC_ConnectableBlock ].		anOperand isVoid		ifTrue: [ ^ true ].! !!PLC_ActualArgumentReader methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 03:32'!acceptLiteral: aLiteralOperand in: aPLC_ConnectableBlock	"Devuelve true acepta el operando que le llega como parámetro"	"				   ______ 	 			   |		  | 				   |		  |		       10  --|	        |--  			 	   |______|		"		| inputPinNumber otherConnectableBlock varDecl |		"Obtengo el número de pin de entrada al que está conectado el pin de salida único este Actual Argument"	inputPinNumber := aPLC_ConnectableBlock inputPinNumberConnectedToOutput: 1.		"Obtengo el bloque conectable al que está conectado este Actual Argument"	otherConnectableBlock := aPLC_ConnectableBlock blockConnectedToOutput: 1.		"Obtengo la declaración de variable de la entrada numero inputPinNumber de otherConnectableBlock"	varDecl := otherConnectableBlock inputs at: inputPinNumber.		"CHEQUEO - Le pregunto a la variable si acepta el valor y el tipo del literal.	Le pregunta tambien a su categoria: >>acceptLiteral"	^ ( varDecl acceptLiteral: aLiteralOperand )! !!PLC_ActualArgumentReader methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 02:36'!acceptStructItem: aStructItemOperand in: aPLC_ConnectableBlock	"Devuelve true acepta el operando que le llega como parámetro"	"							   ______ 	 						   |		  | 							   |		  |	VAR_STRUCT.VAR_ITEM  --|	        |--  						 	   |______|		"		"Hacer chequeos que faltan"	^ false.! !!PLC_ActualArgumentReader methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 03:40'!acceptVariable: aVariableOperand in: aPLC_ConnectableBlock	"Devuelve true acepta el operando que le llega como parámetro				   ______ 	 			   |		  | 				   |		  |		     VAR  --|	        |--  			 	   |______|		"		"Hacer chequeos que faltan"	| inputPinNumber otherConnectableBlock varDecl |		"1 - PRIEMER CHEQUEO - Chequea si la varaible que quiero asignar puede leerse o no.	Si no puede, sale, si puede sigue chequeando."	( self canReadVariable: aVariableOperand )		ifFalse: [ ^ false ].		"Obtengo el número de pin de entrada al que está conectado el pin de salida único este Actual Argument"	inputPinNumber := aPLC_ConnectableBlock inputPinNumberConnectedToOutput: 1.		"Obtengo el bloque conectable al que está conectado este Actual Argument"	otherConnectableBlock := aPLC_ConnectableBlock blockConnectedToOutput: 1.		"Obtengo la declaración de variable de la entrada numero inputPinNumber de otherConnectableBlock"	varDecl := otherConnectableBlock inputs at: inputPinNumber.			"2 - SEGUNDO CHEQUEO - Le pregunto a la variable si acepta el tipo de aVariableOperand.	Si da falso ya sale y sino hace el segundo chequeo"	^ varDecl acceptVariable: aVariableOperand.! !!PLC_ActualArgumentReader methodsFor: 'accept' stamp: 'EricPernia 9/14/2013 03:08'!canReadVariable: aVariableOperand	"Devuelve true si la variable (operando) que le llega como parámetro tiene permiso de lectura"		^ ( aVariableOperand declaration variableCategory varType ~= '_OUTPUT' )! !PLC_Element initialize!PLC_VerticalLink initialize!PLC_GraphicFunctionBlockCall initialize!