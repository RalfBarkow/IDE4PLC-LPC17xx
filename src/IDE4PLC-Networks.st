"Copyright © 2012-2014 Eric Nicolás Pernia.This file is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>."Object subclass: #PLC_LadderController	instanceVariableNames: 'ladderView ladderNetwork'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Networks'!!PLC_LadderController commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_LadderController is xxxxxxxxx.Instance Variables	ladderNetwork:		<Object>	ladderView:		<Object>ladderNetwork	- xxxxxladderView	- xxxxx!!PLC_LadderController methodsFor: 'ladderView' stamp: 'EricPernia 6/8/2013 19:23'!openLadderView	"comment stating purpose of message"	"Creo una vista ladder y se la agrego al controlador"	self ladderView: PLC_LadderView new.		"Le agrego el controlador a la vista creada"	self ladderView ladderController: self.		"Le digo a la vista que se refresque en pantalla"	self refreshView.		"Retorna el ladderView"	^ self ladderView.! !!PLC_LadderController methodsFor: 'ladderView' stamp: 'EricPernia 3/29/2013 04:54'!refreshView	"comment stating purpose of message"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:20'!addCoilOn: aConnectableBlockOrConnection	"Agrega una Bobina sobre el elemento que tenga el foco del teclado."		| connection element |		"Creo el elemento"	element := PLC_Element Coil.		"Busco la conexion donde voy a añadir el elemento"	connection := aConnectableBlockOrConnection connectionToAddElement: element.	"Crea y añade una Bobina en el modelo." 		self ladderNetwork addCoil: element onConnection: connection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/19/2013 00:30'!addFunctionBlockCallWithDeclaration: functionBlockDeclaration on: aConnectableBlockOrConnection	"Agrega una Llamada a Función sobre el elemento que tenga el foco del teclado."		| connection element |		"Creo el elemento"	element := PLC_GraphicFunctionBlockCall		newWithDeclaration: functionBlockDeclaration 		andNetwork: self ladderNetwork.		"Busco la conexion donde voy a añadir el elemento"	connection := aConnectableBlockOrConnection connectionToAddElement: element.	"Crea y añade una Llamada a Función en el modelo." 		self ladderNetwork addFunctionBlockCall: element onConnection: connection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/19/2013 00:30'!addFunctionCallWithDeclaration: functionDeclaration on: aConnectableBlockOrConnection	"Agrega una Llamada a Función sobre el elemento que tenga el foco del teclado."		| connection element |		"Creo el elemento"	element := PLC_GraphicFunctionCall		newWithDeclaration: functionDeclaration 		andNetwork: self ladderNetwork.				"Busco la conexion donde voy a añadir el elemento"	connection := aConnectableBlockOrConnection connectionToAddElement: element.	"Crea y añade una Llamada a Función en el modelo." 		self ladderNetwork addFunctionCall: element onConnection: connection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:20'!addNCContactOn: aConnectableBlockOrConnection	"Agrega un Contacto normal cerrado sobre el elemento que tenga el foco del teclado."		| connection element |		"Creo el elemento"	element := PLC_Element NCContact.		"Busco la conexion donde voy a añadir el elemento"	connection := aConnectableBlockOrConnection connectionToAddElement: element.	"Crea y añade un Contacto en el modelo." 		self ladderNetwork addContact: element onConnection: connection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:20'!addNCoilOn: aConnectableBlockOrConnection	"Agrega una Bobina negada sobre el elemento que tenga el foco del teclado."		| connection element |		"Creo el elemento"	element := PLC_Element NCoil.		"Busco la conexion donde voy a añadir el elemento"	connection := aConnectableBlockOrConnection connectionToAddElement: element.	"Crea y añade una Bobina en el modelo." 		self ladderNetwork addCoil: element onConnection: connection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:20'!addNOContactOn: aConnectableBlockOrConnection	"Agrega un Contacto normal abierto sobre el elemento que tenga el foco del teclado."		| connection element |		"Creo el elemento"	element := PLC_Element NOContact.		"Busco la conexion donde voy a añadir el elemento"	connection := aConnectableBlockOrConnection connectionToAddElement: element.	"Crea y añade un Contacto en el modelo." 		self ladderNetwork addContact: element onConnection: connection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/18/2013 18:27'!changeActualArgumentFor: aPLC_ConnectableBlock by: aString	"Cambia el Actual Argument. "			( self ladderNetwork changeActualArgumentFor: aPLC_ConnectableBlock by: aString )		ifTrue: [			"Refresca la vista"			self ladderView refresh.			].	! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:21'!closeBranchFrom: aPLC_ConnectableBlockOrConnection to: aPLC_Connection	"Cierra una rama entre una conexion o bloque y otra conexion si se puede."	"Abre una rama sobre la conexion aConnection en el modelo." 		self ladderNetwork closeBranchFrom: aPLC_ConnectableBlockOrConnection to: aPLC_Connection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:21'!openBranchOnConnection: aConnection	"Abre una rama sobre una conexion (==)."	"Abre una rama sobre la conexion aConnection en el modelo." 		self ladderNetwork openBranchOnConnection: aConnection.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:21'!removeCoil: aCoil	"Remueve un Bobina."	"Remueve una Bobina en el modelo." 		self ladderNetwork removeCoil: aCoil.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:21'!removeContact: aContact	"Remueve un Contacto."	"Remueve un Contacto en el modelo." 		self ladderNetwork removeContact: aContact.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:21'!removeFunctionCall: aFunctionCallConnectableBlock	"Remueve un llamado a Función."	"Remueve un llamado a Función en el modelo." 		self ladderNetwork removeFunctionCall: aFunctionCallConnectableBlock.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'commands recive from View' stamp: 'EricPernia 11/5/2013 13:22'!removeRightPowerRail: aPLC_ConnectableBlockRPR	"Remueve un Right Power Rail."	"Remueve si es posible el Right Power Rail aPLC_ConnectableBlockRPR en el modelo." 		self ladderNetwork removeRightPowerRail: aPLC_ConnectableBlockRPR.		"Refresca la vista"	self ladderView refresh.! !!PLC_LadderController methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 13:17'!ladderNetwork	^ ladderNetwork! !!PLC_LadderController methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 13:17'!ladderNetwork: anObject	ladderNetwork := anObject! !!PLC_LadderController methodsFor: 'accessing' stamp: 'EricPernia 3/12/2013 00:28'!ladderView	^ ladderView! !!PLC_LadderController methodsFor: 'accessing' stamp: 'EricPernia 3/12/2013 00:28'!ladderView: anObject	ladderView := anObject! !!PLC_LadderController methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 13:54'!generateCodeIn: aProgramAccumulator	"Compila su programa a objetos que lo forman. Estos pueden dar su código C o IL."	self ladderNetwork generateCodeIn: aProgramAccumulator.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_LadderController class	instanceVariableNames: ''!!PLC_LadderController class methodsFor: 'instance creation' stamp: 'EricPernia 11/5/2013 13:18'!newWithModel: aLadderNetwork	"Crea una nueva instancia con el modelo de bloques conectables asociado"	| controller |		"Creo un controlador Ladder"	controller := self new.		"Le agrego el modelo"	controller ladderNetwork: ( aLadderNetwork ifNil: [ PLC_LadderNetwork new. ] ) .		^ controller.	! !Object subclass: #PLC_ConnectableBlocksNetwork	instanceVariableNames: 'pouBody networkController networkLabel blocks'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Networks'!!PLC_ConnectableBlocksNetwork commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_ConnectableBlocksNetwork is xxxxxxxxx.Instance Variables	blocks:		<Object>	networkController:		<Object>	networkLabel:		<Object>	pouBody:		<Object>blocks	- xxxxxnetworkController	- xxxxxnetworkLabel	- xxxxxpouBody	- xxxxx!!PLC_ConnectableBlocksNetwork methodsFor: 'initialize-release' stamp: 'EricPernia 11/5/2013 12:52'!initialize	"Inicializacion de la Network de Bloques Conectables"		"creo la OC de bloques"	self blocks: OrderedCollection new.	! !!PLC_ConnectableBlocksNetwork methodsFor: 'commands for checks' stamp: 'EricPernia 9/14/2013 16:15'!checkActualArgumentReader	"comment stating purpose of message"		"HACERRRRRRRRRRRR"		self pouBody.! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 10/9/2012 20:56'!addBlock:  aConnectableBlock	"Añade un bloque conectable a la Ordered Collection blocks"	self blocks add:  aConnectableBlock.! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/15/2013 16:18'!functionBlockConnectableBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un llamado grafico a Bloque de Funcion."	^ self blocks select: [ : each | each element isFunctionBlock ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/15/2013 16:18'!functionConnectableBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un llamado grafico a Funcion."	^ self blocks select: [ : each | each element isFunction ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 10/9/2012 20:55'!inputBlocks	"Retorna una coleccion de bloques conectables de entrada.	Estos son los que no tienen entradas."	^ self blocks select: [ : each | each isInputBlock ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 10/9/2012 20:55'!outputBlocks	"Retorna una coleccion de bloques conectables de salida.	Estos son los que no tienen salidas."	^ self blocks select: [ : each | each isOutputBlock ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 10/9/2012 20:56'!removeBlock:  aConnectableBlock	"Remueve un bloque conectable de la Ordered Collection blocks"	self blocks remove: aConnectableBlock.! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/15/2013 16:18'!standardFunctionBlockConnectableBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un llamado grafico a Bloque de Funcion estandar."	^ self functionBlockConnectableBlocks select: [ : each | ( each element declaration isUserDefined ) not ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/15/2013 16:18'!standardFunctionConnectableBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un llamado grafico a Funcion estandar."	^ self functionConnectableBlocks select: [ : each | ( each element declaration isUserDefined ) not ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/15/2013 16:18'!userFunctionBlockConnectableBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un 	llamado grafico a Bloque de Funcion definida por el usuario."	^ self functionBlockConnectableBlocks select: [ : each | each element declaration isUserDefined ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/15/2013 16:18'!userFunctionConnectableBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un 	llamado grafico a Funcion definida por el usuario."	^ self functionConnectableBlocks select: [ : each | each element declaration isUserDefined ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 5/29/2012 12:14'!blocks	^ blocks! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 5/29/2012 12:14'!blocks: anObject	blocks := anObject! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 5/29/2012 12:14'!networkController	^ networkController! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 5/29/2012 12:14'!networkController: anObject	networkController := anObject! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 10/9/2012 20:57'!networkLabel	^ networkLabel! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 10/9/2012 20:57'!networkLabel: anObject	networkLabel := anObject! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 9/14/2013 16:15'!pouBody	^ pouBody! !!PLC_ConnectableBlocksNetwork methodsFor: 'accessing' stamp: 'EricPernia 9/14/2013 16:15'!pouBody: anObject	pouBody := anObject! !!PLC_ConnectableBlocksNetwork methodsFor: 'checks' stamp: 'EricPernia 11/10/2012 06:01'!moreWiredInputFor: aConnectableBlock	"Devuelve la mayor entrada cableada (conectada a algo que no sea Actual Argument Reader) buscando desde la primera hasta anInputNumber - 1."	| maxInput |		maxInput := 1.	( 1 to: aConnectableBlock element inputs size ) do: [ :each |		( self blockConnectedToInput: each) isActualArgumentReader not			ifTrue: [				maxInput := each.				]. 		].			^ maxInput.! !!PLC_ConnectableBlocksNetwork methodsFor: 'checks' stamp: 'EricPernia 11/10/2012 06:46'!moreWiredInputFor: aConnectableBlock until: anInputNumber	"Devuelve la mayor entrada cableada (conectada a algo que no sea Actual Argument Reader) buscando desde la primera hasta anInputNumber - 1."	| maxInput |		maxInput := 1.	( 1 to: anInputNumber - 1) do: [ :each |		( aConnectableBlock blockConnectedToInput: each) element isActualArgumentReader not			ifTrue: [				maxInput := each.				]. 		].			^ maxInput.! !!PLC_ConnectableBlocksNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 1/23/2014 00:54'!changeActualArgumentFor: aPLC_ConnectableBlock by: aString	"Cambia el Actual Argument. "	"HACER: 		1 - le pase el string a su pou para que lo convierta en un objeto operando ( PARSEO )		| operand |		Devuelve un objeto que puede ser operando: variable, item de estructura, literal, o void;	o devolver nil si el string es cualquier otra cosa.		operand := self pouBody pou convertStringToOperand: aString		2a - Si es operando, le pido al elemento actual argument del bc que le llega como parametro	que cheque si le cabe que le asignen el operando. 	Este operando seguro entiende dataType y dataValue. 	Si es variable o item de estructura además se puede buscar su declaración 		Si le cabe se pone el flag de 'valorInvalido' a False en el actual argument 		Si no le cabe se pone el flag de 'valorInvalido' a True en el actual argument 			Siempre se lo asigna (cambia el texto auque se ingrese cualquier verdura), 			con el flag se determina si se dibuja en rojo o negro para indicar que se 			va a poder compilar o no.		2b - Si es nil le guarda un operando void al elemento actual argument.						LO DE ABAJO ES UN PARCHE PARA QUE SIGA ANDANDO, DESPUES HAY QUE SACAR TODO....	"			| argument |		"Parseo mal hecho"	argument := self parse: aString.			"Cambia el argumento actual"	aPLC_ConnectableBlock element actualArgument: argument.		^ true.! !!PLC_ConnectableBlocksNetwork methodsFor: 'commands add-remove Elements' stamp: 'CL 11/18/2013 02:21'!removeContact: aPLC_ConnectableBlockContact	"Remueve un Contacto."	| connectableBlockActualArgumentReader connectableBlockOutputPin connectableBlockInputPin |	"Busco los pines de los bloques conectables conectados a la primer entrada y salida de la bobina"		connectableBlockOutputPin := ( aPLC_ConnectableBlockContact connectedAtInput: 1) outputPin.	connectableBlockInputPin := ( aPLC_ConnectableBlockContact connectedAtOutput: 1) inputPin.		"Busco el Actual Argument  Writer de la bobina"		connectableBlockActualArgumentReader := aPLC_ConnectableBlockContact blockConnectedToInput: 2.		"Desconecto el Actual Argument  Writer de la bobina"	( connectableBlockActualArgumentReader connectedAtOutput: 1 ) disconnect.		"Desconecto la bobina"	( aPLC_ConnectableBlockContact connectedAtInput: 1) disconnect.	( aPLC_ConnectableBlockContact connectedAtOutput: 1) disconnect.		"Remuevo los bloques conectables de la Network de bloques conectables"	self removeBlock: aPLC_ConnectableBlockContact.	self removeBlock: connectableBlockActualArgumentReader.		"Conecto los pines obtenidos y realizo los chequeos pertinentes a LPR y VL"	^ self checkShortCircuitIfConnect: connectableBlockOutputPin To: connectableBlockInputPin.! !!PLC_ConnectableBlocksNetwork methodsFor: 'called POUs' stamp: 'EricPernia 11/19/2013 04:41'!calledStandardFunctionBlocks	"Retorna una coleccion de declaraciones de Bloques de Funcion estandar."	| collection collectionChild |	"En collection estan las declaraciones de los bloques de funcion usados en la network"	collection := self standardFunctionBlockConnectableBlocks collect: [ : each | each element declaration ].		collectionChild := collection.		"En collectionChild estan las declaraciones que puedan tener a su vez en su cuerpo estas declaraciones"	collectionChild do:  [ :each |		(each pouBody calledPOUs) 			ifNotNil: [ 				collection add: 					each pouBody calledPOUs 				] 		].	^ collection! !!PLC_ConnectableBlocksNetwork methodsFor: 'called POUs' stamp: 'EricPernia 11/15/2013 16:18'!calledStandardFunctions	"Retorna una coleccion de declaraciones de Funciones estandar."	^ self standardFunctionConnectableBlocks collect: [ : each | each element declaration ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'called POUs' stamp: 'EricPernia 11/15/2013 16:19'!calledUserFunctionBlocks	"Retorna una coleccion de declaraciones de Bloques Funcion definidos por el usuario."	^ self userFunctionBlockConnectableBlocks collect: [ : each | each element declaration ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'called POUs' stamp: 'EricPernia 11/15/2013 16:18'!calledUserFunctions	"Retorna una coleccion de declaraciones de Funciones definidas por el usuario."	^ self userFunctionConnectableBlocks collect: [ : each | each element declaration ].! !!PLC_ConnectableBlocksNetwork methodsFor: 'PARSER' stamp: 'EricPernia 1/23/2014 00:58'!parse: aString	"PARSEO LO QUE LLEGUE ASI BUSCO LA VARIABLE CORRECTA"	"aString Parseado pedorramente - Es true, false o numero 	(entero o time)"		| pouDecls decl varDecl argument |		pouDecls := self pouBody pou declarations.			decl := pouDecls includeVarDeclWithIdentifier: aString.		decl 		ifNil: [			"No encontro declaracion. Chequeo si puedo convertir aString 			a un literal, sino creo una nueva variable de la galera con ese			identifier."						"Parseo de Literales barato"							"Pruebo si el string es TRUE"				( (aString = 'true') or: [(aString = 'True') or: [aString = 'TRUE'] ] ) 				ifTrue: [					"Si era true creo un Literal true"					argument := ( PLC_Literal 						newWithDataType: PLC_DataType Bool						andDataValue: true	).					]				ifFalse: [					"Pruebo si el string es FALSE"					( (aString = 'false') or: [(aString = 'False') or: [aString = 'FALSE'] ] ) 						ifTrue: [ 							"Si era false creo un Literal false"							argument := ( PLC_Literal 								newWithDataType: PLC_DataType Bool								andDataValue: false ).							]						ifFalse: [ 							"Pruebo si es numerico ENTERO"							aString isAllDigits								ifTrue: [ 									"Si era numero creo un Literal INT"									argument := ( PLC_Literal 										newWithDataType: PLC_DataType Int										andDataValue: aString asNumber ).									]								ifFalse: [ 									"Chequea si empieza con T# o TIME# para parsear el numero como TIME"									( ( aString beginsWith: 'T#' ) or: [ aString beginsWith: 'TIME#'  ] )										ifTrue: [ 											"Si era numero creo un Literal TIME"											argument := ( PLC_Literal 												newWithDataType: PLC_DataType Time												andDataValue: aString extractNumber ).											] 										ifFalse: [ 											"NO PUDE PARSEARLO, INVENTO UNA DECLARACION DE VARIABLE"											varDecl := PLC_SymbolicVariableDecl 												newWithDataType: PLC_DataType Bool												andInitialValue: nil 												andIdentifier: aString.											"Creo el Operando Variable a partir de la Declaración de Variable"											argument := PLC_Variable 												newWithDeclaration: varDecl 												andDataValue: nil.											].									]. 							]. 					].			]		ifNotNil: [			"Encontro declaracion, creo un nuevo Operando variable 			con la declaración hallada"			argument := PLC_Variable 				newWithDeclaration: decl 				andDataValue: decl initialValue.			].			^ argument.! !PLC_ConnectableBlocksNetwork subclass: #PLC_LadderNetwork	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Networks'!!PLC_LadderNetwork commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_LadderNetwork is xxxxxxxxx.Instance Variables!!PLC_LadderNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/5/2013 12:50'!leftPowerRailBlock	"Retorna una coleccion de bloques conectables cuyo elemento sea un riel derecho."	^ (self blocks select: [ : each | each element isLeftPowerRail ]) first.! !!PLC_LadderNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/5/2013 12:50'!rightRailsBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un riel derecho."	^ self blocks select: [ : each | each element isRightPowerRail ].	"VER SI VA SELECT O COLLECT"! !!PLC_LadderNetwork methodsFor: 'blocks' stamp: 'EricPernia 11/5/2013 12:50'!veriticalLinkBlocks	"Retorna una coleccion de bloques conectables cuyo elemento sea un vertical link."	^ self blocks select: [ : each | each element isVerticalLink ].	"VER SI VA SELECT O COLLECT"! !!PLC_LadderNetwork methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 12:51'!checkValidRightPowerRailConnections	"Cheuquea que los RPR no esten conectados a contactos o VL si esto es así devuelve true."	"LO PARCHIE"		^ true.	"^ self rightRailsBlocks allSatisfy: [:each | 		((each blockConnectedToInput: 1) isContact or: [ (each blockConnectedToInput: 1) isVerticalLink ]) not.		]	"! !!PLC_LadderNetwork methodsFor: 'checks' stamp: 'EricPernia 11/5/2013 12:51'!checkIfFunctionAreInAParallelBranch: aPLC_ConnectableBlockF	"Chequeo si se encuentra en una rama paralela"	| connectableBlockOutputPinNumber lprOrVl |			lprOrVl := aPLC_ConnectableBlockF.		"Busco a través de la Funcion hacia su entrada hasta encontrar un elemento que sea un Vertical Link o	Left Power Rail  y también guardo por cual número de pin de salida llego."	[ lprOrVl element isVerticalLink or: [  lprOrVl element isLeftPowerRail ] ]		whileFalse: 			[ connectableBlockOutputPinNumber := lprOrVl outputPinNumberConnectedToInput: 1.			lprOrVl := lprOrVl blockConnectedToInput: 1. ].		^ lprOrVl element isVerticalLink and: [ connectableBlockOutputPinNumber > 1 ].! !!PLC_LadderNetwork methodsFor: 'checks' stamp: 'EricPernia 4/5/2014 02:43'!checkShortCircuitIfConnect: connectableBlockOutputPin To: connectableBlockInputPin	"Chequeo que no se forme un cortocircuito si conecto connectableBlockOutputPin 	con connectableBlockInputPin. Si no hay problema los conecto. Si se forma un corto	Borro los pines de los VL o LPR que lo forman y no conecto los pines. Cuando Borro 	pines debo ver que queden VL o LPR validos.		AGREGAR CHEQUEO DE QUE NO HAYA SOLO BOBINAS O BLOQUES EN LAS RAMAS SERIES DE LA RAMA PARALELA 	EN BOBINA Y BLOQUE		Evita el caso al eliminar un contacto por ejejmplo:		       	c1	  			   		c1 			NO PUEDE QUEDAR ASI 	-----+-----|  |----+-----		-----+-----|  |-----+-----	DEBE REEMPLAZAR LOS 2 		|	c2	   |		==>	|		   |		VL POR HORIZONTAL LINKS	     +-----|  |----+		           +-------------+														"	| connectableBlockInput connectableBlockOutput  	 VLorLPRinput VLOutput 	 adequateInputPin locationForNewOutputPin outputToDisappear newOutputPin inputPinToConnect   	 adequateOutputPin locationForNewInputPin inputToDisappear newInputPin outputPinToConnect | 		connectableBlockInput := connectableBlockOutputPin block.	connectableBlockOutput := connectableBlockInputPin block.		VLorLPRinput := connectableBlockInput.	VLOutput := connectableBlockOutput.			adequateInputPin := connectableBlockInputPin.		"Si da true entonces se formaria un cortocircuito y hay que evitarlo"		connectableBlockOutput element isVerticalLink		ifTrue: [			connectableBlockInput element isLeftPowerRail				ifTrue: [															"Chequeo si el VL no tiene pines de entrada. Si esto es asi el LPR debe 'absorver' al VLOutput										Ejemplo:															| p1	     p2  p3			|								|-----|  |-----+----			|-----   p3							|		   |		==>	|							|		  +----			|-----   p4 						|		   p4 			|																	LPR 	VL 			     LPR													"						( VLOutput inputs size = 1 )						ifTrue: [							"Agrego los pines de salida del VLOutput al Left Power Rail."							"VLorLPRinput outputs addAll: VLOutput outputs."								"el input que hay que enchufarle al output es otro, 							  porque el VLOutput va a desaparecer"							adequateInputPin := VLOutput outputs first connection inputPin.							adequateInputPin disconnect.							"reconecto cada uno de los conectados con el VLOutput a nuevos pines en el LPRinput"							locationForNewOutputPin := connectableBlockOutputPin.							(2 to: VLOutput outputs size) do: [ :n |								outputToDisappear := VLOutput outputs at: n.								VLorLPRinput addOutputPinAfter: locationForNewOutputPin.								newOutputPin := VLorLPRinput outputPinAfter: locationForNewOutputPin.								VLorLPRinput element addOutput.   "no se para que es esto!!!!"								inputPinToConnect := outputToDisappear connection inputPin.								inputPinToConnect disconnect.								newOutputPin connectTo: inputPinToConnect.								locationForNewOutputPin := newOutputPin.							 ].							"version de Eric"							"outputPin := connectableBlockOutputPin.							VLOutput outputs do: [ :each | 								each block: VLorLPRinput.								VLorLPRinput addOutputPin: each after: outputPin.								outputPin := each.																							]."							"Remuevo el VLOutput de la network de bloques conectables."							self removeBlock: VLOutput.										"esto lo repito porque hay un return abajo que no entiendo, pero que dejo por las dudas. Ufa."							connectableBlockOutputPin connectTo: adequateInputPin.						] 						ifFalse: [ 							"Remuevo la salida del elemento del VL o LPR - NO ANDABA ANTES PORQUE NO HACIA ESTO"							VLOutput element inputs removeAt: ( VLOutput inputs indexOf: connectableBlockInputPin ).							"Remuevo el pin obtenido del Bloque Conectable LPR o VL"							VLOutput inputs remove: connectableBlockInputPin.							"Remuevo la salida del elemento del VL o LPR - NO ANDABA ANTES PORQUE NO HACIA ESTO"							VLorLPRinput element outputs removeAt: ( VLorLPRinput outputs indexOf: connectableBlockOutputPin ).							"Remuevo el pin obtenido del Bloque Conectable LPR o VL"							VLorLPRinput outputs remove: connectableBlockOutputPin.												].											].							VLorLPRinput element isVerticalLink				ifTrue: [										"Chequeo si el VLorLPRinput tiene un solo pin de salida. Si esto es asi debe 'absorver' al VLOutput											Ejemplo 1:												Ejemplo 2:									    p5    p6	 											    p5     p6					p1 ---+----|  |----+--- p3 			p1 ---+--- p3			p1 ---+----|  |----+--- p4 			p1 ---+--- p4						   |		    |			==>		   |						   |		    | 			==>		   |					p2 ---+		   +--- p4			p2 ---+--- p4			p2 ---+		    |					p2 ---+																						    |						   |						VL1 	VL2 					VL1							  p3---+ 				p3 ---+																				VL1 	VL2 					VL1					p = Pin "																( VLOutput inputs size = 1 )						ifTrue: [							" esto es lo mismo - lo mismo que esta en el caso 							  VLOutput isVerticalLink -- VLorLPRinput isLeftPowerRail - VLorLPRinput output size = 1.							  Refactorizar si este proyecto sigue vivo."							"el input que hay que enchufarle al output es otro, 							  porque el VLOutput va a desaparecer"							adequateInputPin := VLOutput outputs first connection inputPin.							adequateInputPin disconnect.							"reconecto cada uno de los conectados con el VLOutput a nuevos pines en el LPRinput"							locationForNewOutputPin := connectableBlockOutputPin.							(2 to: VLOutput outputs size) do: [ :n |								outputToDisappear := VLOutput outputs at: n.								VLorLPRinput addOutputPinAfter: locationForNewOutputPin.								VLorLPRinput element addOutput.   "no se para que es esto!!!!"								newOutputPin := VLorLPRinput outputPinAfter: locationForNewOutputPin.								inputPinToConnect := outputToDisappear connection inputPin.								inputPinToConnect disconnect.								newOutputPin connectTo: inputPinToConnect.								locationForNewOutputPin := newOutputPin.							 ].							"aca se termina la parte copiada de otro caso "							"version de Eric"							"Agrego los pines de entrada y salida del VLOutput al VLorLPRinput"							"VLorLPRinput inputs addAll: VLOutput inputs.							VLorLPRinput outputs addAll: VLOutput outputs."																		"Remuevo el VLOutput de la network de bloques conectables."							self removeBlock: VLOutput.												"esto lo repito porque hay un return abajo que no entiendo, pero que dejo por las dudas. Ufa."							connectableBlockOutputPin connectTo: adequateInputPin.						]						ifFalse: [ 											( VLorLPRinput outputs size = 1 )							ifTrue: [  								" esto es dual a los casos con codigo repetido, cambiando input por output.								  Refactorizar si este proyecto sigue vivo."								"el output que hay que enchufarle al input es otro, 								  porque el VLorLPRinput va a desaparecer"								adequateOutputPin := VLorLPRinput inputs first connection outputPin.								adequateOutputPin disconnect.								"reconecto cada uno de los conectados con el VLOutput a nuevos pines en el LPRinput"								locationForNewInputPin := connectableBlockInputPin.								(2 to: VLorLPRinput inputs size) do: [ :n |									inputToDisappear := VLorLPRinput inputs at: n.									VLOutput addInputPinAfter: locationForNewInputPin.									VLOutput element addInput.   "no se para que es esto!!!!"									newInputPin := VLOutput inputPinAfter: locationForNewInputPin.									outputPinToConnect := inputToDisappear connection outputPin.									outputPinToConnect disconnect.									newInputPin connectTo: outputPinToConnect.									locationForNewInputPin := newInputPin.								 ].								"aca se termina la parte copiada de otro caso "																			"Remuevo el VLOutput de la network de bloques conectables."								self removeBlock: VLorLPRinput.								"esto lo repito porque hay un return abajo que no entiendo, pero que dejo por las dudas. Ufa."								adequateOutputPin connectTo: connectableBlockInputPin.							]							ifFalse: [ 								"Remuevo la salida del elemento del VL o LPR - NO ANDABA ANTES PORQUE NO HACIA ESTO"								VLOutput element inputs removeAt: ( VLOutput inputs indexOf: connectableBlockInputPin ).								"Remuevo el pin obtenido del Bloque Conectable LPR o VL"								VLOutput inputs remove: connectableBlockInputPin.								"Remuevo la salida del elemento del VL o LPR - NO ANDABA ANTES PORQUE NO HACIA ESTO"								VLorLPRinput element outputs removeAt: ( VLorLPRinput outputs indexOf: connectableBlockOutputPin ).								"Remuevo el pin obtenido del Bloque Conectable LPR o VL"								VLorLPRinput outputs remove: connectableBlockOutputPin.							 ]						].											"Chequeo si el aConnectableBlockVL tiene una sola entrada y una sola salida.					Si esto es asi entonces lo reemplazo por un Horizontal Link."								self checkValidVerticalLink: VLorLPRinput.						]				ifFalse:[					"Si entro aca entonces connectableBlockInput no es ni VL ni LPR, entonces 					simplemente conecta, no tiene que absorber nada"										"Conecto los pines que obtuve al principio para cerrar el circuito y retorno la nueva conexion"					^ connectableBlockOutputPin connectTo: adequateInputPin.										].							"Chequeo si el aConnectableBlockVL tiene una sola entrada y una sola salida.			Si esto es asi entonces lo reemplazo por un Horizontal Link."						^ self checkValidVerticalLink: VLOutput.						].				"Conecto los pines que obtuve al principio para cerrar el circuito y retorno la nueva conexion"	^ connectableBlockOutputPin connectTo: adequateInputPin.! !!PLC_LadderNetwork methodsFor: 'checks' stamp: 'EricPernia 11/5/2013 12:51'!checkValidVerticalLink: aConnectableBlockVL	"Chequeo si el aConnectableBlockVL tiene una sola entrada y una sola salida.	Si esto es asi entonces lo reemplazo por un Horizontal Link.						Ejemplo, Borro c1:						|	 c1					|							 c2	|------|   |----+-->>		|-		  -+-->>			|------|   |------->>		|	 c2     |		==>	|	 c2	    |		==>	|------|   |----+				|------|   |----+	|						|						"						| connectableBlockOutputPin connectableBlockInputPin |						( aConnectableBlockVL inputs size = 1 and: [ aConnectableBlockVL outputs size = 1 ] )		ifTrue: [			"Busco los pines conectados a entrada y salida del VL"			connectableBlockOutputPin := ( aConnectableBlockVL connectedAtInput: 1) outputPin.			connectableBlockInputPin := ( aConnectableBlockVL connectedAtOutput: 1) inputPin. 						"Desconecto los pines obtenidos"			connectableBlockOutputPin disconnect.			connectableBlockInputPin disconnect.						"Remuevo el bloque conectable VL de la Network de bloques conectables"			self removeBlock: aConnectableBlockVL.								"Conecto los pines que obtuve y retorno dicha conexion."			^ connectableBlockOutputPin connectTo: connectableBlockInputPin.					]		ifFalse: [			^ aConnectableBlockVL.			]! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!addCoil: aPLC_ElementCoil onConnection: aPLC_Connection	"Crea y añade una Bobina."	| connectableBlockActualArgumentWriter connectableBlockCoil |	"Creo los Bloques Conectables"		connectableBlockCoil := PLC_ConnectableBlock newWithElement: aPLC_ElementCoil.	connectableBlockActualArgumentWriter := PLC_ConnectableBlock newWithElement: PLC_Element ActualArgumentWriter.	"Conecto los 2 bloques conectables que forman el Elemento. 	Esta conexion no está representada por ningun Morph."	connectableBlockCoil output: 2 connectTo: connectableBlockActualArgumentWriter input: 1.		"Agrego los Bloques Conectables a la Network de Bloques Conectables"	self addBlock: connectableBlockCoil.	self addBlock: connectableBlockActualArgumentWriter.			"Conecto el nuevo elemento a los Bloques Conectables entre los cuales estaba la conexion donde agrego el nuevo elemento."	aPLC_Connection replaceConnectionByConnectingToInputPin: connectableBlockCoil inputs first andOutputPin:  connectableBlockCoil outputs first.			^ connectableBlockCoil.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!addContact: aPLC_ElementContact onConnection: aPLC_Connection	"Crea y añade un Contacto."	| connectableBlockActualArgumentReader connectableBlockContact |	"Creo los Bloques Conectables"		connectableBlockContact := PLC_ConnectableBlock newWithElement: aPLC_ElementContact.	connectableBlockActualArgumentReader := PLC_ConnectableBlock newWithElement: PLC_Element ActualArgumentReader.	"Conecto los 2 bloques conectables que forman el Elemento. 	Esta conexion no está representada por ningun Morph."	connectableBlockActualArgumentReader output: 1 connectTo: connectableBlockContact input: 2.		"Agrego los Bloques Conectables a la Network de Bloques Conectables"	self addBlock: connectableBlockContact.	self addBlock: connectableBlockActualArgumentReader.			"Conecto el nuevo elemento a los Bloques Conectables entre los cuales estaba la conexion donde agrego el nuevo elemento."	aPLC_Connection replaceConnectionByConnectingToInputPin: connectableBlockContact inputs first andOutputPin:  connectableBlockContact outputs first.		^ connectableBlockContact.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/17/2013 06:08'!addFunctionBlockCall: aPLC_Element onConnection: aPLC_Connection	"Crea y añade un Llamado a Instancia de Bloque de Función."	| connectableBlockActualArgumentReader connectableBlockActualArgumentWriter connectableBlockFunction |	"Creo el Bloque Conectables del Bloque de Función"		connectableBlockFunction := PLC_ConnectableBlock newWithElement: aPLC_Element.	"Agrego el Bloque Conectable del LLamado a Función a la Network de Bloques Conectables"	self addBlock: connectableBlockFunction.		"Creo y conecto los bloques conectables de los Acrual Argument Reader	de sus salidas y entrada-salidas y agrego los Actual Argument Reader a	la Network de Bloques Conectables."	(2 to: aPLC_Element inputs size ) do: [ :index |		connectableBlockActualArgumentReader := PLC_ConnectableBlock 			newWithElement: PLC_Element ActualArgumentReader.		connectableBlockActualArgumentReader 			output: 1 			connectTo: connectableBlockFunction 			input: index.			self addBlock: connectableBlockActualArgumentReader.		].		"Creo y conecto los bloques conectables de los Acrual Argument Writer 	de sus salidas y entrada-salidas y agrego los Actual Argument Writer a	la Network de Bloques Conectables."	(2 to: aPLC_Element outputs size ) do: [ :index |		connectableBlockActualArgumentWriter := PLC_ConnectableBlock 			newWithElement: PLC_Element ActualArgumentWriter.		connectableBlockFunction 			output: index 			connectTo: connectableBlockActualArgumentWriter 			input: 1.			self addBlock: connectableBlockActualArgumentWriter.			].		"Conecto el nuevo elemento a los Bloques Conectables entre los 	cuales estaba la conexion donde agrego el nuevo elemento."	aPLC_Connection 		replaceConnectionByConnectingToInputPin: connectableBlockFunction inputs first 		andOutputPin: connectableBlockFunction outputs first.		^ connectableBlockFunction.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!addFunctionCall: aPLC_Element onConnection: aPLC_Connection	"Crea y añade un Llamado a Función."	| connectableBlockActualArgumentReader connectableBlockActualArgumentWriter connectableBlockFunction |	"Creo el Bloques Conectables de la Función"		connectableBlockFunction := PLC_ConnectableBlock newWithElement: aPLC_Element.	"Agrego el Bloque Conectable del LLamado a Función a la Network de Bloques Conectables"	self addBlock: connectableBlockFunction.		"Creo y conecto los bloques conectables de los Acrual Argument Reader	de sus salidas y entrada-salidas y agrego los Actual Argument Reader a	la Network de Bloques Conectables."	(2 to: aPLC_Element inputs size ) do: [ :index |		connectableBlockActualArgumentReader := PLC_ConnectableBlock 			newWithElement: PLC_Element ActualArgumentReader.		connectableBlockActualArgumentReader 			output: 1 			connectTo: connectableBlockFunction 			input: index.			self addBlock: connectableBlockActualArgumentReader.		].		"Creo y conecto los bloques conectables de los Acrual Argument Writer 	de sus salidas y entrada-salidas y agrego los Actual Argument Writer a	la Network de Bloques Conectables."	(2 to: aPLC_Element outputs size ) do: [ :index |		connectableBlockActualArgumentWriter := PLC_ConnectableBlock 			newWithElement: PLC_Element ActualArgumentWriter.		connectableBlockFunction 			output: index 			connectTo: connectableBlockActualArgumentWriter 			input: 1.			self addBlock: connectableBlockActualArgumentWriter.			].		"Conecto el nuevo elemento a los Bloques Conectables entre los 	cuales estaba la conexion donde agrego el nuevo elemento."	aPLC_Connection 		replaceConnectionByConnectingToInputPin: connectableBlockFunction inputs first 		andOutputPin: connectableBlockFunction outputs first.		^ connectableBlockFunction.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!addLeftPowerRail	"Crea y añade el Riel de Potencia Izquiedo. Solo debe existir uno por Network."	| connectableBlockLeftPowerRail |	"Creo el Bloque Conectable"		connectableBlockLeftPowerRail := PLC_ConnectableBlock newWithElement: PLC_Element LeftPowerRail.	"Agrego el Bloque Conectable a la Network de Bloques Conectables"	self addBlock: connectableBlockLeftPowerRail.	 "Le agrego el primer pin de salida"	connectableBlockLeftPowerRail addOutput.		^ connectableBlockLeftPowerRail.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!addRightPowerRailConnectedTo: aPLC_ConnectableBlock output: anOutputNumber	"Crea y añade un Riel Derecho y lo conecta a la salida numero anOutputNumber 	del Bloque Conectable aPLC_ConnectableBlock."	| connectableBlockRightPowerRail |	"Creo el Bloque Conectable"		connectableBlockRightPowerRail := PLC_ConnectableBlock newWithElement: PLC_Element RightPowerRail.	"Agrego el Bloque Conectable a la Network de Bloques Conectables"	self addBlock: connectableBlockRightPowerRail.		"Conecto el Bloque Conectable en la Network de Bloques Conectables."		aPLC_ConnectableBlock output: anOutputNumber connectTo: connectableBlockRightPowerRail input: 1.		^ connectableBlockRightPowerRail.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!removeCloseBranch: aPLC_ConnectableBlockVerticalLink	"Remueve en un Vertical Link solo la parte que cierrar rama paralela."	| connectableBlockOutputPin inputConnectableBlock |		"Solo puedo borrar el Close Branch si tiene mas de un pin de entrada"	( aPLC_ConnectableBlockVerticalLink inputs size > 1 )		ifTrue: [						( 2 to: aPLC_ConnectableBlockVerticalLink inputs size ) 				do: [ :index |										"Busco el bloque conectable conectado a la entrada numero index del VL"					inputConnectableBlock := aPLC_ConnectableBlockVerticalLink blockConnectedToInput: index.												"Busco el pin del bloque conectable conectado a la entrada numero index del VL"						connectableBlockOutputPin := ( aPLC_ConnectableBlockVerticalLink connectedAtInput: index) outputPin.										"Desconecto el Pin obtenido"					connectableBlockOutputPin disconnect.										"Le agrego un RPR conectado al pin"					self addRightPowerRailConnectedTo: inputConnectableBlock output: index.										"Borro el pin de entrada numero index del VL"					aPLC_ConnectableBlockVerticalLink inputs removeAt: index.										].						"Chequeo que al final del borrado de pines de entrada resulte un VL valido."				^ self checkValidVerticalLink: aPLC_ConnectableBlockVerticalLink.						].! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!removeCoil: aPLC_ConnectableBlockCoil	"Remueve una Bobina."	| connectableBlockActualArgumentWriter connectableBlockOutputPin connectableBlockInputPin |	"Busco los pines de los bloques conectables conectados a la primer entrada y salida de la bobina"		connectableBlockOutputPin := ( aPLC_ConnectableBlockCoil connectedAtInput: 1) outputPin.	connectableBlockInputPin := ( aPLC_ConnectableBlockCoil connectedAtOutput: 1) inputPin.		"Busco el Actual Argument  Writer de la bobina"		connectableBlockActualArgumentWriter := aPLC_ConnectableBlockCoil blockConnectedToOutput: 2.		"Desconecto el Actual Argument  Writer de la bobina"	( connectableBlockActualArgumentWriter connectedAtInput: 1 ) disconnect.		"Desconecto la bobina"	( aPLC_ConnectableBlockCoil connectedAtInput: 1) disconnect.	( aPLC_ConnectableBlockCoil connectedAtOutput: 1) disconnect.		"Remuevo los bloques conectables de la Network de bloques conectables"	self removeBlock: aPLC_ConnectableBlockCoil.	self removeBlock: connectableBlockActualArgumentWriter.		"Conecto los pines obtenidos y realizo los chequeos pertinentes a LPR y VL"	^ self checkShortCircuitIfConnect: connectableBlockOutputPin To: connectableBlockInputPin.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 4/5/2014 01:51'!removeContact: aPLC_ConnectableBlockContact	"Remueve un Contacto."	| connectableBlockActualArgumentReader connectableBlockOutputPin connectableBlockInputPin VLInput VLOutput |	"Busco los pines de los bloques conectables conectados a la primer entrada y salida del Contacto"		connectableBlockOutputPin := ( aPLC_ConnectableBlockContact connectedAtInput: 1) outputPin.	connectableBlockInputPin := ( aPLC_ConnectableBlockContact connectedAtOutput: 1) inputPin.		"Busco el Actual Argument  Writer del Contacto"		connectableBlockActualArgumentReader := aPLC_ConnectableBlockContact blockConnectedToInput: 2.		"Desconecto el Actual Argument  Writer del Contacto"	( connectableBlockActualArgumentReader connectedAtOutput: 1 ) disconnect.		"Desconecto el Contacto"	( aPLC_ConnectableBlockContact connectedAtInput: 1) disconnect.	( aPLC_ConnectableBlockContact connectedAtOutput: 1) disconnect.		"Remuevo los bloques conectables de la Network de bloques conectables"	self removeBlock: aPLC_ConnectableBlockContact.	self removeBlock: connectableBlockActualArgumentReader.		"Conecto los pines obtenidos y realizo los chequeos pertinentes a LPR y VL"	^ self checkShortCircuitIfConnect: connectableBlockOutputPin To: connectableBlockInputPin.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/19/2013 15:52'!removeFunctionCall: aPLC_ConnectableBlockFunctionCall	"Elimina un Llamado a Función."		| connectableBlock connectableBlockOutputPin connectableBlockInputPin pou |	"Busco los pines de los bloques conectables conectados a la primer entrada y salida del Llamado a Función"		connectableBlockOutputPin := ( aPLC_ConnectableBlockFunctionCall connectedAtInput: 1) outputPin.	connectableBlockInputPin := ( aPLC_ConnectableBlockFunctionCall connectedAtOutput: 1) inputPin.			"Desconecto y borro las entradas según que tenga conectado"	(2 to: aPLC_ConnectableBlockFunctionCall inputs size ) do: [ :index |			"Busco el Bloque Conectable conectado a la entrada número index"			connectableBlock := aPLC_ConnectableBlockFunctionCall blockConnectedToInput: index.			"Chequeo si es un Actual Argument Reader"		connectableBlock element isActualArgumentReader			ifTrue: [				"Si es Actual Argument lo desconecta y lo remueve"								"Desconecto el Actual Argument Reader"				( connectableBlock connectedAtOutput: 1 ) disconnect.						"Remuevo bloques conectable de la Network de bloques conectables"				self removeBlock: connectableBlock.				] 			ifFalse: [				"Si No es Actual Argument le crea y conecta un RPR"								"Desconecto el Elemento"				( connectableBlock connectedAtOutput: 1 ) disconnect.								"Creo y conecto un RPR"				self addRightPowerRailConnectedTo: connectableBlock output: 1.								].		].	"Siempre es un Actual Argument Writer a la salida. Se descoenectan y borran."		(2 to: aPLC_ConnectableBlockFunctionCall outputs size ) do: [ :index |					"Busco el Actual Argument Writer a la salida número index"			connectableBlock := aPLC_ConnectableBlockFunctionCall blockConnectedToOutput: index.						"Desconecto el Actual Argument Writer"		( connectableBlock connectedAtInput: 1 ) disconnect.				"Remuevo bloques conectable de la Network de bloques conectables"		self removeBlock: connectableBlock.		].							"Desconecto el bloque conectable Llamado a Función"	( aPLC_ConnectableBlockFunctionCall connectedAtInput: 1) disconnect.	( aPLC_ConnectableBlockFunctionCall connectedAtOutput: 1) disconnect.				"PARCHE: ELIMINO LA INSTANCIA AL ELIMINAR EL F O FB"	pou := aPLC_ConnectableBlockFunctionCall element network pouBody pou.	( pou pouType = 'FUNCTION' )		ifTrue: [ 			"ES F"			pou funInstVarDecls remove: aPLC_ConnectableBlockFunctionCall element instance. 			] 		ifFalse: [ 			"ES FB"			pou varDecls remove: aPLC_ConnectableBlockFunctionCall element instance. 			].					"Remuevo el bloque conectable Llamado a Función de la Network de bloques conectables"	self removeBlock: aPLC_ConnectableBlockFunctionCall.		"Conecto los pines obtenidos y realizo los chequeos pertinentes a LPR y VL"	^ self checkShortCircuitIfConnect: connectableBlockOutputPin To: connectableBlockInputPin.! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 11/5/2013 12:51'!removeRightPowerRail: aPLC_ConnectableBlockRPR	"Remueve un Right Power Rail."	| connectableBlockOutputPin VLorLPRInput |		"Busco el bloque conectable conectado a la entrada del RPR"	VLorLPRInput := aPLC_ConnectableBlockRPR blockConnectedToInput: 1.		"Solo puedo borrar el RPR si esta conectado a un VL o LPR sino lo retorno"	( VLorLPRInput element isLeftPowerRail or: [ VLorLPRInput element isVerticalLink ] )		ifTrue: [						"Solo puedo borrar el RPR si el LPR o VL tiene mas de una salida."			( VLorLPRInput outputs size > 1 )				ifTrue: [											"Busco el pin del bloque conectable conectado a la primer entrada del RPR"						connectableBlockOutputPin := ( aPLC_ConnectableBlockRPR connectedAtInput: 1) outputPin.																			"Remuevo la salida del elemento del VL o LPR - NO ANDABA ANTES PORQUE NO HACIA ESTO"					VLorLPRInput element outputs removeAt: ( VLorLPRInput outputs indexOf: connectableBlockOutputPin ).					"Remuevo el pin obtenido del Bloque Conectable LPR o VL"					VLorLPRInput outputs remove: connectableBlockOutputPin.												"Desconecto el RPR"					( aPLC_ConnectableBlockRPR connectedAtInput: 1) disconnect.						"Remuevo el bloque conectable de la Network de bloques conectables"					self removeBlock: aPLC_ConnectableBlockRPR.										"Si el LPR o VL es un VL entonces debo chuequear que quede un VL valido"					VLorLPRInput element isVerticalLink						ifTrue: [							^ self checkValidVerticalLink: VLorLPRInput.							].											^ VLorLPRInput.												] 			] .! !!PLC_LadderNetwork methodsFor: 'commands add-remove Elements' stamp: 'EricPernia 1/25/2014 22:40'!replaceAcrualArgumentReaderFor: aPLC_Element inFunction: aPLC_ConnectableBlockF input: anInputNumber	"Reemplaza un Lector de Argumento Real por un contacto en la entrada  anInputNumber de la funcion aPLC_ConnectableBlockF."	| connectableBlockOutputPinNumber lpr maxInput oc connection connectableBlockActualArgument |		"Chequeo que tenga un actual argument reader en esa entrada"	( ( aPLC_ConnectableBlockF blockConnectedToInput: anInputNumber ) element isActualArgumentReader and: [ aPLC_Element isCoil or: aPLC_Element isContact] )		ifTrue: [				"Chequeo si se encuentra en una rama paralela. Si es verdadero no puedo agregar contacto."			(self checkIfFunctionAreInAParallelBranch: aPLC_ConnectableBlockF)				ifFalse: [					"Chequeo que la entrada anInputNumber sea INPUT y BOOL y sea una entrada mayor a 1"					( ( aPLC_ConnectableBlockF element inputs size >= anInputNumber and: [ anInputNumber > 1 ] )						and: [ (aPLC_ConnectableBlockF element inputs at: anInputNumber) dataType acceptType:  PLC_DataType Bool ] ) 												ifTrue: [							"Si se cumple todo entonces reemplazo el Actual Argument Reader por un contacto"														"1 - Busco el mayor numero de  entrada cableada por arriba de anInputNumber"							maxInput := self moreWiredInputFor: aPLC_ConnectableBlockF until: anInputNumber.														"2 - Busco el primer VL o LPR a la derecha yendo por maxInput"							lpr := aPLC_ConnectableBlockF blockConnectedToInput: maxInput.							connectableBlockOutputPinNumber := aPLC_ConnectableBlockF outputPinNumberConnectedToInput: maxInput.														"Busco a través de la Funcion hacia su entrada hasta encontrar un elemento que sea un Vertical Link o							Left Power Rail  y también guardo por cual número de pin de salida llego."							[ lpr element isLeftPowerRail ]								whileFalse: 									[ maxInput :=self moreWiredInputFor: lpr.									connectableBlockOutputPinNumber := lpr outputPinNumberConnectedToInput: maxInput.									lpr := lpr blockConnectedToInput: maxInput. ].								"Si llego aca es porque seguro llegue al LPR. Me fijo si tengo que agregar el pin o hacer lugar y agregar"							lpr outputs size > connectableBlockOutputPinNumber								ifTrue: [									oc :=  lpr outputs copyFrom: connectableBlockOutputPinNumber + 1 to: lpr outputs size.									lpr outputs: (lpr outputs copyFrom: 1 to: connectableBlockOutputPinNumber).									lpr addOutput.									lpr outputs: lpr outputs , oc.									]								ifFalse:[									lpr addOutput.									].								"Busco el Actual Argument "									connectableBlockActualArgument := aPLC_ConnectableBlockF blockConnectedToInput: anInputNumber.								"Desconecto el Actual Argument"								( connectableBlockActualArgument connectedAtOutput: 1 ) disconnect.								"Lo borro de la Network de bloques conectables"								self removeBlock: connectableBlockActualArgument.																								"Conecto entre el nuevo pin y el bloque"								lpr disconnectOutput:  connectableBlockOutputPinNumber + 1.								lpr output: connectableBlockOutputPinNumber + 1 connectTo: aPLC_ConnectableBlockF input: anInputNumber.								connection := lpr connectedAtOutput: connectableBlockOutputPinNumber + 1.																						"Agrego el contacto o bobina"								aPLC_Element isContact									ifTrue: [ self addContact: aPLC_Element onConnection: connection ]. 								aPLC_Element isCoil									ifTrue: [ self addCoil: aPLC_Element onConnection: connection ]. 																					].					].			].			^ 'No se puede agregar contacto.'.! !!PLC_LadderNetwork methodsFor: 'commands copen-close Branch' stamp: 'EricPernia 11/5/2013 12:52'!closeBranchFrom: aPLC_ConnectableBlockOrConnection to: aPLC_Connection	"Cierra una rama si se puede."		( aPLC_ConnectableBlockOrConnection isConnectableBlock )		ifTrue: [			( aPLC_ConnectableBlockOrConnection element isRightPowerRail and: [ aPLC_Connection isConnection ] )				ifTrue: [					^ self closeBranchFromRPR: aPLC_ConnectableBlockOrConnection toHL: aPLC_Connection.				].		].				( aPLC_ConnectableBlockOrConnection isConnection and: [ aPLC_Connection isConnection ] )		ifTrue: [			^ self closeBranchFromHL: aPLC_ConnectableBlockOrConnection toHL: aPLC_Connection.			]			ifFalse: [			^ 'No se puede Cerrar Rama.'.			]! !!PLC_LadderNetwork methodsFor: 'commands copen-close Branch' stamp: 'EricPernia 11/5/2013 12:52'!closeBranchFromHL: aPLC_Connection1 toHL: aPLC_Connection2	"Cierra una Rama desde una Conexion hasta otra conexion, es decir, un Horizontal Link.		---+----|  |-----==-----|  |--------           	 		---+----|  |------+-----|  |----------   	    |		       				 	    ==>		    |		     	  |		   +----|  |-----==-----|  |---->>				  	   +----|  |------+-----|  |---->>		"	| connectableBlock1 connectableBlockOutputPinNumber1 connectableBlock2 connectableBlockOutputPinNumber2 connectableBlockVL  |		" 1 -  Chequeo que los bloques conectables conectados a ambas conexiones no sean LPR o VL.	Si son VL o LPR, entonces no puedo Cerrar la Rama."		"Busco los Bloques Conectables conectados a la entrada y salida de aPLC_Connection1"	connectableBlock1 := aPLC_Connection1 connectedAtInput: 1.	connectableBlock2 := aPLC_Connection1 connectedAtOutput: 1.		"Analizo si son VL o LPR"	( connectableBlock1 element isLeftPowerRail 		or: [ connectableBlock1 element isVerticalLink 			or: [ connectableBlock2 element isLeftPowerRail 				or: [ connectableBlock2 element isVerticalLink ] 				]			 ] )		ifTrue:  [			^ 'No se puede Cerrar Rama.'			].			"Busco los Bloques Conectables conectados a la entrada y salida de aPLC_Connection2"	connectableBlock1 := aPLC_Connection2 connectedAtInput: 1.	connectableBlock2 := aPLC_Connection2 connectedAtOutput: 1.		"Analizo si son VL o LPR"	( connectableBlock1 element isLeftPowerRail 		or: [ connectableBlock1 element isVerticalLink 			or: [ connectableBlock2 element isLeftPowerRail 				or: [ connectableBlock2 element isVerticalLink ] 				]			 ] )		ifTrue:  [			^ 'No se puede Cerrar Rama.'			].			" 2 -   Busco a través de la Conexion ( == ) aPLC_Connection1  hacia su entrada hasta 	encontrar un elemento que sea un Vertical Link o Left Power Rail y también guardo por 	cual número de pin de salida llego."	connectableBlock1 := aPLC_Connection1 connectedAtInput: 1.	[ ( connectableBlock1 element isLeftPowerRail or: [ connectableBlock1 element isVerticalLink ] ) ]		whileFalse: 			[ connectableBlockOutputPinNumber1 := connectableBlock1 outputPinNumberConnectedToInput: 1.			connectableBlock1 := connectableBlock1 blockConnectedToInput: 1. ] .			" 3 -   Busco a través de la Conexion ( == ) aPLC_Connection2 hacia su entrada hasta 	encontrar un elemento que sea un Vertical Link o Left Power Rail y también guardo por 	cual número de pin de salida llego."	connectableBlock2 := aPLC_Connection2 connectedAtInput: 1.	[ ( connectableBlock2 element isLeftPowerRail or: [ connectableBlock2 element isVerticalLink ] ) ]		whileFalse: 			[ connectableBlockOutputPinNumber2 := connectableBlock2 outputPinNumberConnectedToInput: 1.			connectableBlock2 := connectableBlock2 blockConnectedToInput: 1. ] .	" 4 -  Chequeo si los 2 bloques conectables a los cuales llego recorriendo hacia al entrada de	de la Conexion aPLC_Connection1 y de la Conexion aPLC_Connection2 son el mismo Vertical 	Link o Left Power Rail y también que el Numero de Pin al que llego por aPLC_Connection1 	sea mayor en 1 al Numero de Pin al que llego por aPLC_Connection2. Si esto se cumple 	entonces puedo Cerrar la rama creando asi una conexion en Paralelo.					    3 	-----+----|  |------==----|  |------->>		 		 -----+----|  |-------+-------|  |------->>		      |		    2 								 |		      |	     +----|  |------==----|  |------->>		==>		+----|  |-------+-------|  |------->>	      |		    1 								 |	     +----|  |------==----|  |------->>					+----|  |----------------|  |------->>				Puedo Cerrar Rama en los casos:		aPLC_Connection1 = 1 y aPLC_Connection2 = 2		aPLC_Connection1 = 2 y aPLC_Connection2 = 3	"		( connectableBlock1= connectableBlock2 and: [ (connectableBlockOutputPinNumber1 - connectableBlockOutputPinNumber2) = 1 ] )		ifTrue: [						"Si llego a este punto entonces puedo Cerrar la rama creando así una conexion en paralelo.						5 -  Reemplazo ambas conexiones por un nuevo Vertical Link."						"Creo lel Vertical Link y le agrego 2 entradas y 2 salidas."			connectableBlockVL := PLC_ConnectableBlock newWithElement: PLC_Element VerticalLink.			connectableBlockVL 						addOutput;						addOutput;						addInput;						addInput.									"Agrego el Bloque Conectable a la Network de Bloques Conectables"			self addBlock: connectableBlockVL.								"Conecto el Vertical Link donde estaban las conexiones."			aPLC_Connection2 replaceConnectionByConnectingToInputPin: connectableBlockVL inputs first andOutputPin:  connectableBlockVL outputs first.			aPLC_Connection1 replaceConnectionByConnectingToInputPin: connectableBlockVL inputs last andOutputPin:  connectableBlockVL outputs last.						]				ifFalse: [			^ 'No se puede Cerrar Rama.'			].! !!PLC_LadderNetwork methodsFor: 'commands copen-close Branch' stamp: 'EricPernia 11/5/2013 12:52'!closeBranchFromRPR: aPLC_ConnectableBlockRightPowerRail toHL: aPLC_Connection	"Cierra una Rama desde un Riel de Potencia Derecho hacia una conexion, es decir, un Horizontal Link.		|----|  |---------(  )----|            	|----|  |----+----(  )----|        	|					==>	|	       |	|----|  |---->>					|----|  |----+			VER SI HACE FLATA DETECTAR QUE EL RPR NO ESTE CONECTADO A BOBINA		"	| connectableBlock1 connectableBlockOutputPinNumber1 connectableBlock2 connectableBlockOutputPinNumber2 connectableBlockLPRorVL connectableBlockOutputPin |		" 1 -  Chequeo si el primer bloque conectado a la entrada del Right Power Rail ( -->> ) es un Vertical Link	o Left Power Rail, si esto es así entonces no puedo Cerrar la Rama pues genero un cortocircuito.		---+----|  |----==  			     -----+----|  |----+-----      NO SE PUEDE, CORTOCIRCUITO.	    |				   ==>		     |		      |	   +->>						    +-----------+ 		debe haber un elemento entre el VL y el RPR.	( == ) es el Horizontal Link hacia el cual quiero Cerrar la Rama."		"Busco el Bloque Conectable conectado a la entrada 1 del Right Power Rail."	connectableBlock2 := aPLC_ConnectableBlockRightPowerRail blockConnectedToInput: 1.		"Analizo si es un VL o LPR"	( connectableBlock2 element isLeftPowerRail or: [ connectableBlock2 element isVerticalLink ] )		ifTrue: [			^ '1 - No se puede hacer cortocircuitos.'			].			" 2 -  Busco a través del Right Power Rail ( -->> ) hacia su entrada hasta encontrar un	 elemento que sea un Vertical Link o Left Power Rail y también guardo por cual número 	de pin de salida llego."	[ ( connectableBlock2 element isLeftPowerRail or: [ connectableBlock2 element isVerticalLink ] ) ]		whileFalse: 			[ connectableBlockOutputPinNumber2 := connectableBlock2 outputPinNumberConnectedToInput: 1.			connectableBlock2 := connectableBlock2 blockConnectedToInput: 1. ] .				" 3 -   Chequeo si el primer bloque conectado a la entrada del Horizontal Link ( == ) es el mismo bloque	que obtuve en 2. Si esto es así entonces no puedo Cerrar la Rama pues genero un cortocircuito.		     a	 	     b 					   a		 		     b	----|  |----+==----|  |-------  			     ----|  |----+-----------+----|  |-------     NO SE PUEDE, CORTOCIRCUITO.		      |	c			   ==>		    	     |	     c	 |		     +----|  |----->>					    +----|  |----+ 		debe haber un elemento entre los VL.	( == ) es el Horizontal Link hacia el cual quiero Cerrar la Rama desde el Right Power Rail."		"Busco el Bloque Conectable conectado a la entrada 1 de la Conexion."	connectableBlock1 := aPLC_Connection blockConnectedToInput: 1.		"Analizo si los bloques conectables obtenidos son iguales"	( connectableBlock1 = connectableBlock2 )		ifTrue: [			^ '3 - No se puede hacer cortocircuitos.'			].			" 4 -   Busco a través de la Conexion ( == ) hacia su entrada hasta encontrar un	 elemento que sea un Vertical Link o Left Power Rail y también guardo por cual número 	de pin de salida llego."	[ ( connectableBlock1 element isLeftPowerRail or: [ connectableBlock1 element isVerticalLink ] ) ]		whileFalse: 			[ connectableBlockOutputPinNumber1 := connectableBlock1 outputPinNumberConnectedToInput: 1.			connectableBlock1 := connectableBlock1 blockConnectedToInput: 1. ] .	" 5 -  Chequeo si los 2 bloques conectables a los cuales llego recorriendo hacia al entrada de	de la Conexion ( == ) y del Right Power Rail ( -->> ) son el mismo Vertical Link o Left Power Rail 	y también que el Numero de Pin al que llego por el RPR sea mayor al Numero de Pin al que llego 	por la Conexion. Si esto se cumple entonces puedo Cerrar la rama creando asi una conexion 	en Paralelo.										           1	Output Pin N° 1  -----+----|  |-----------------------==-------------|  |-----            	 	 						 |				   2	Output Pin N° 2 	+----|  |----------|  |----==-->>	3						 |		Output Pin N°3 		+----|  |---------------->> 4				Puedo Cerrar Rama en los casos:		3 con 1		4 con 1		4 con 2	"	( connectableBlock1= connectableBlock2 and: [ connectableBlockOutputPinNumber2 > connectableBlockOutputPinNumber1 ] )		ifTrue: [						"Si llego a este punto entonces puedo Cerrar la rama creando así una conexion en paralelo.						6 -  Elimino el Right Power Rail."						"Busco el Pin de salida conectado al  Conectable"			connectableBlockOutputPin := (aPLC_ConnectableBlockRightPowerRail connectedAtInput: 1) outputPin.								"Desconecto el Right Power Rail"			(aPLC_ConnectableBlockRightPowerRail connectedAtInput: 1) disconnect.						"Elimino el Right Power Rail de la Network de Bloques Conectables "			self blocks remove: aPLC_ConnectableBlockRightPowerRail.									"7 -  Chequeo si primer elemento conectado a entrada de la conexion ( == ) es un Vertical 			Link. Si esto se cumple entonces en lugar de crear un nuevo Vertical Link le agrego un 			Pin  de entrada a dicho Vertical Link. CREO QUE ESTE CHEQUEO ME LO FILTRA MAS ARRIBA.					 	 -----+----|  |-----+--==----      	 	 -----+----|  |-----+-----    ASI SI 	 				 |		   |						 |		   |		 			+----|  |-----+			==>		+----|  |-----+					 |								 |		   |					+----|  |-------->> 					+----|  |-----+			 	 -----+----|  |-----+--==----      	 	 -----+----|  |-----+------+-----     ASI NO	 	 				 |		   |						 |		    |	      |	 			+----|  |-----+			==>		+----|  |-----+	      |				 |								 |		   	      |				+----|  |-------->> 					+----|  |-------------+			"						"Busco el Bloque Conectable a la Entrada del la Conexion."			connectableBlockLPRorVL := aPLC_Connection connectedAtInput: 1.						"Analizo si es un VL. Si es verdadero le agrego una Entrada."			( connectableBlockLPRorVL element isVerticalLink )				ifTrue: [					 connectableBlockLPRorVL addInput.					].							"8 -  Chequeo si primer elemento conectado a Salida de la conexion ( == ) es un Vertical 			Link. Si esto se cumple entonces en lugar de crear un nuevo Vertical Link le agrego un 			Pin  de entrada a dicho Vertical Link.					 	 -----+----|  |------==------+----|  |-----+-----   		 	 -----+----|  |-----+----|  |-----+-----     ASI SI							 |		 		   |		      |					 |		   |		      |		 			+----|  |----->> 	  +----|  |-----+		  ==>		+----|  |-----+----|  |-----+								   |		      |							   |		      |									  +----|  |-----+							  +----|  |-----+			 	 -----+----|  |------==------+----|  |-----+-----   		 	 -----+-----|  |------+-----+-----|  |-----+-----     ASI NO							 |		 		   |		      |					 |		     |       |	 	     |		 			+----|  |----->> 	  +----|  |-----+		  ==>		+-----|  |------+     +-----|  |-----+								   |		      |								       |		     |									  +----|  |-----+								      +-----|  |-----+				"						"Busco el Bloque Conectable a la Salida del la Conexion."			connectableBlockLPRorVL := aPLC_Connection connectedAtOutput: 1.						"Analizo si es un VL. Si es verdadero le agrego una Entrada."			( connectableBlockLPRorVL element isVerticalLink )				ifTrue: [					 connectableBlockLPRorVL addInput.					]				ifFalse: [										"9 -  Creo un nuevo Vertical Link y conecto sus primeras entradas y 					salidas donde se encontraba la Conexion."															"Creo lel Vertical Link y le agrego 2 entradas y 1 salida."					connectableBlockLPRorVL := PLC_ConnectableBlock newWithElement: PLC_Element VerticalLink.					connectableBlockLPRorVL addOutput;						addInput;						addInput.											"Agrego el Bloque Conectable a la Network de Bloques Conectables"					self addBlock: connectableBlockLPRorVL.										"Conecto el nuevo elemento a los Bloques Conectables entre los cuales 					estaba la conexion donde agrego el nuevo elemento."					aPLC_Connection replaceConnectionByConnectingToInputPin: connectableBlockLPRorVL inputs first andOutputPin:  connectableBlockLPRorVL outputs first.										].							"10 -  Conecto el pin de salida del Bloque Conectable que estaba conectado el 			Right Power Rail al ultimo pin de Entrada del connectableBlockLPRorVL."						connectableBlockOutputPin connectTo: connectableBlockLPRorVL inputs last.						^ connectableBlockLPRorVL.						]		ifFalse: [			^ 'No se puede Cerrar Rama.'			].! !!PLC_LadderNetwork methodsFor: 'commands copen-close Branch' stamp: 'EricPernia 4/5/2014 03:42'!openBranchOnConnection: aPLC_Connection	"Abre una rama sobre una conexion (==).		|----|  |----==---(  )----|             	|----|  |----+----(  )----|        	|							|	       |	|							|            +->>				CASOS:		1 -  Si abro rama sobre el horizontal link cuya entrada esta conectada a un 	VL o LPR entonces debe agregarle un pin de salida al VL o LPR y ahi 	conectarle el RPR.		|----|  |-----+==--(  )----|			|----|  |-----+----(  )----|	|		  |						|		  |		|		 +------(  )----|   			|		 +->>									|		  |									|		 +----(  )----|  			 			2 -  Si abro rama sobre el horizontal link cuya salida esta conectada a un 	VL entonces debe agregarle un pin de salida al VL y ahi 	conectarle el RPR.								Si quiero abrir rama sobre el HL entre el contacto y el VL entonces tiene 	que agregarle un pin de salida al VL y agregarle ahi el RPR.		|----|  |----==-+----(  )----|			|----|  |-----+----(  )----|	|	 	      |					|		  |		|		     +----(  )----|   			|		 +----(  )----|  									|		  |									|	 	 +->>														3 -  Si abro rama sobre en un horizontal link NO conectado a un VL o LPR 	entonces debo agregarle en su lugar un nuevo Vertical Link y conectarle 	en su segunda salida un Right Power Rail..		|----|  |----==---(  )----|             	|----|  |----+----(  )----|        	|							|	       |	|							|            +->>			"		| connectableBlockLPRorVLInput connectableBlockVLOutput	connectableBlockLPRorVL outputPin connectableBlockRightPowerRail |	"Busco el Bloque Conectable a la Entrada del la conexion, puede ser un LPR, VL u otro."	connectableBlockLPRorVLInput := aPLC_Connection connectedAtInput: 1.		"Busco el Bloque Conectable a la Salida del la conexion, nunca va a poder ser un LPR."	connectableBlockVLOutput := aPLC_Connection connectedAtOutput: 1.				"Chequeo si la conexion ya estaba conectada a un Left Power Rail o 	Vertical Link a su entrada o salida. Si esto es verdadero, le agrego al 	LPR o VL una salida y le conecto un Right Power Rail. Nunca se va a dar 	el caso simultaneo que la conexión esté conectada a izquierda y	derecha a VLs o LPRs en simultaneo ya que sino deberían haber sido 	absorbidos durante un borrado.		Si es falso Debo crear Primero un Vertical Link y luego agregar 	una salida conectada a un RPR."			"Prueba si el bloque conectable de entrada de la conexion es LPR o VL"	( connectableBlockLPRorVLInput element isLeftPowerRail 	or: [ connectableBlockLPRorVLInput element isVerticalLink ] )		ifTrue: [			connectableBlockLPRorVL := connectableBlockLPRorVLInput.			"Seteo el pin luego del cual debe agregarse el nuevo pin"			outputPin := aPLC_Connection outputPin.				].			"Prueba si el bloque conectable de salida de la conexion es VL"		( connectableBlockVLOutput element isVerticalLink )		ifTrue: [			connectableBlockLPRorVL := connectableBlockVLOutput.			"Seteo el pin luego del cual debe agregarse el nuevo pin"			outputPin := connectableBlockLPRorVL outputs last.				].		"Si ni el bloque conectable a la entrada de la conexion, ni el de salida 	son LPR oVL, entonces tiene que crear un VL"		connectableBlockLPRorVL		ifNil: [			"Creo lel Vertical Link y le agrego una entrada y una salida."			connectableBlockLPRorVL := PLC_ConnectableBlock 				newWithElement: PLC_Element VerticalLink.			connectableBlockLPRorVL 				addInput;				addOutput.							"Agrego el Bloque Conectable a la Network de Bloques Conectables"			self addBlock: connectableBlockLPRorVL.						"Conecto el nuevo elemento a los Bloques Conectables entre los 			cuales estaba la conexion donde agrego el nuevo elemento."			aPLC_Connection 				replaceConnectionByConnectingToInputPin: connectableBlockLPRorVL inputs first 				andOutputPin:  connectableBlockLPRorVL outputs first.							"Seteo el pin luego del cual debe agregarse el nuevo pin"			outputPin := connectableBlockLPRorVL outputs first.			].					"Le agrego una salida al Left Power Rail o Vertical Linkl"	connectableBlockLPRorVL addOutputAfter: outputPin.			"Le conecto un nuevo Right Power Rail"	connectableBlockRightPowerRail := self 		addRightPowerRailConnectedTo: connectableBlockLPRorVL 		output: ( connectableBlockLPRorVL outputs indexOf: outputPin ) + 1.		"Agrego el Right Power Rail a la Network de Bloques Conectables"	self addBlock: connectableBlockRightPowerRail.		^ connectableBlockLPRorVL.! !!PLC_LadderNetwork methodsFor: 'compilation' stamp: 'EricPernia 11/15/2013 13:51'!generateCodeIn: aProgramAccumulator	"Compila su programa a objetos que lo forman. Estos pueden dar su código C o IL."	| varDecl |	self checkValidRightPowerRailConnections 		ifTrue: [						"Reseteo los objetos generados por los elementos"			self resetCompiledObjectsInElements.													"Creo la declaración de variable FLUX que la usan los llamados graficos a F y FB"			varDecl := PLC_SymbolicVariableDecl 				newWithDataType: PLC_DataType Bool				andInitialValue: nil 				andIdentifier: 'FLUX'. 						"La agrego a las variables declaradas por el compilador"					aProgramAccumulator addVarDecl: varDecl.						"Le asigno la categoría temp asi no pone el pxPOU-> en C"			varDecl variableCategory: PLC_VariableCategoryDecl tempVarDecls.									"Comienzo la compilacion en el bloque conectable left power rail"			self leftPowerRailBlock generateCodeIn: aProgramAccumulator.									"Guardo los objetos generados por los Vertical Links"			self veriticalLinkBlocks do: [ :block |				aProgramAccumulator addVarDecl: block element objectVarDec.				aProgramAccumulator addDataTypeDecl: block element objectTypeDec.				].					]		ifFalse:[						self error: 'No se puede compilar'.						]				! !!PLC_LadderNetwork methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 12:52'!resetCompiledObjectsInElements.	"Reseteo todo para la proxima compilacion"	"Reseteo los objetos de compilacion generados por los Vertical Links"	self veriticalLinkBlocks do: [ :block |		block element objectVarDecl: nil.		block element objectTypeDecl: nil.		block element numberOfCompiledImputs: 0.		].! !!PLC_LadderNetwork methodsFor: 'initialize-release' stamp: 'EricPernia 11/5/2013 12:53'!initialize	"Inicializacion de la Network de Bloques Conectables"		super initialize.		"Agrego el Left Power Rail y el Right Power Rail en la Network de Bloques Conectables quedando el modelo inicial:		|	|-------------------------------------------------------------|	|		"	self addRightPowerRailConnectedTo: self addLeftPowerRail output: 1.	! !BorderedMorph subclass: #PLC_View	instanceVariableNames: 'controller elements selectedElements unselectedElements keyboardFocusElement uiContext editor'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Networks'!!PLC_View commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_View is xxxxxxxxx.Instance Variables	controller:		<Object>	editor:		<Object>	elements:		<Object>	keyboardFocusElement:		<Object>	selectedElements:		<Object>	uiContext:		<Object>	unselectedElements:		<Object>controller	- xxxxxeditor	- xxxxxelements	- xxxxxkeyboardFocusElement	- xxxxxselectedElements	- xxxxxuiContext	- xxxxxunselectedElements	- xxxxx!!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!controller		^ controller! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!controller: anObject		controller := anObject! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 01:27'!editor		^ editor! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 01:27'!editor: anObject		editor := anObject! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!elements	^ elements! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!elements: anObject	elements := anObject! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!keyboardFocusElement	^ keyboardFocusElement! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!keyboardFocusElement: anObject	keyboardFocusElement := anObject! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!selectedElements	^ selectedElements! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!selectedElements: anObject	selectedElements := anObject! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!uiContext		^ uiContext! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!uiContext: anObject		uiContext := anObject! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!unselectedElements	^ unselectedElements! !!PLC_View methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!unselectedElements: anObject	unselectedElements := anObject! !!PLC_View methodsFor: 'commands send to controller' stamp: 'EricPernia 8/4/2013 02:31'!commandCopy	"Este mensaje se dispara cuando presionan las teclas Ctrl + C."			Transcript show: 'COPY'.	! !!PLC_View methodsFor: 'commands send to controller' stamp: 'EricPernia 8/4/2013 02:32'!commandPaste	"Este mensaje se dispara cuando presionan las teclas Ctrl + C."			Transcript show: 'PASTE'.	! !!PLC_View methodsFor: 'commands send to controller' stamp: 'EricPernia 8/4/2013 02:31'!removeSelectedElements	"Remueve todos los elementos seleccionados."		"Remuevo todos los elementos seleccionados"	"SE JODE PORQUE CAMBIAN LOS ELEMENTOS AL BORRAR EL PRIMERO"	"self selectedElements do: [ :elem |			elem removeElementFrom: self.		]."		"Parche momentaneo, solo borro el primero de los seleccionados"	(self selectedElements size > 0 )		ifTrue: [			self selectedElements first removeElementFrom: self.			].! !!PLC_View methodsFor: 'commands send to self' stamp: 'EricPernia 8/4/2013 02:31'!addSelectedAndKeyboardFocus: aPLC_GraphicElementMorph	"Añade el elemento a la lista de seleccionados y le da el foco del teclado."		(self unselectedElements includes: aPLC_GraphicElementMorph)		ifTrue: [			self unselectedElements remove: aPLC_GraphicElementMorph.				].			(self selectedElements includes: aPLC_GraphicElementMorph)		ifFalse: [			self selectedElements add: aPLC_GraphicElementMorph.				].	self selectedElements do: [ :each |		each selected;			notKeyboardFocus.		].		self keyboardFocusElement: aPLC_GraphicElementMorph.	aPLC_GraphicElementMorph keyboardFocus.! !!PLC_View methodsFor: 'commands send to self' stamp: 'EricPernia 11/18/2013 04:49'!editorKeyBoradFocus	"Avisa a su owner que le dieron el foco del teclado."		self editor ifNotNil: [ 		"Le saco el foco del teclado a la network que lo tenia"		( self editor keyboardFocusMorph == self  )			ifFalse: [ 				self editor keyboardFocusMorph lostKeyboardFocus.				self selectedElements do: [ :each |					each draggingAnother.					].									 ].		"Le doy el foco del reclado a esta"		self editor keyboardFocusMorph: self.		].		! !!PLC_View methodsFor: 'commands send to self' stamp: 'EricPernia 11/18/2013 01:29'!gotKeyboardFocus	"Evento cuando el ladderView le dan el foco del teclado."		self borderColor: PLC_GraphicElementProperties uniqueInstance rowColorSelected.	self changed.	self selectedElements do: [ :each |		each selected.		].		self editorKeyBoradFocus.! !!PLC_View methodsFor: 'commands send to self' stamp: 'EricPernia 11/18/2013 00:18'!lostKeyboardFocus	"Evento cuando el ladderView pierde el foco del teclado."		self borderColor: Color white.		self selectedElements do: [ :each |		each draggingAnother.		].! !!PLC_View methodsFor: 'commands send to self' stamp: 'EricPernia 8/4/2013 02:31'!selectedAndKeyboardFocus: aPLC_GraphicElementMorph	"Añade el elemento a la lista de seleccionados. Borra los anteriores."		self unselectAll.		(self unselectedElements includes: aPLC_GraphicElementMorph)		ifTrue: [			self unselectedElements remove: aPLC_GraphicElementMorph.			].				self selectedElements add: aPLC_GraphicElementMorph.		self keyboardFocusElement: aPLC_GraphicElementMorph.		self unselectedElements do: [ :each |		each notKeyboardFocus.				].		aPLC_GraphicElementMorph		selected;		keyboardFocus.	! !!PLC_View methodsFor: 'commands send to self' stamp: 'EricPernia 8/4/2013 02:31'!unselectAll	"Pasa todos los elementos a la Coleccion de deseleccionados y actualiza los estados de los elementos graficos."		self selectedElements removeAll.	self unselectedElements removeAll.		self submorphs do: [ :each |		self unselectedElements add: each.			].			self unselectedElements do: [ :each |		each unselected.		].! !!PLC_View methodsFor: 'elements in screen directions' stamp: 'EricPernia 8/4/2013 02:34'!aboveMorphFor: aPLC_GraphicElementMorph	"Devuelve el Morph de arriba del morph pasado como parámetro"	| startPoint stopPoint result distance |		result := nil.		startPoint := aPLC_GraphicElementMorph topCenter.	stopPoint := startPoint x @  self top.		distance := startPoint y - stopPoint y.	"	Transcript show: startPoint asString , ' ' ,  stopPoint asString ,  ' ' , distance asString , '		'."		1 to: distance do: [ :index | | col |"		Transcript show: ( startPoint - ( 0 @ index ) ) asString , '		'."		col := (self submorphs select: [ :each | each containsPoint: startPoint - ( 0 @ index ) ])."		Transcript show: col."		col ifNotEmpty:	[ ^ col first].		].		result ifNil: [^ aPLC_GraphicElementMorph ].		! !!PLC_View methodsFor: 'elements in screen directions' stamp: 'EricPernia 8/4/2013 02:34'!beneathMorphFor: aPLC_GraphicElementMorph	"Devuelve el Morph de abajo del morph pasado como parámetro"	| startPoint stopPoint result distance |		result := nil.		startPoint := aPLC_GraphicElementMorph bottomCenter.	stopPoint := startPoint x @  self bottom.		distance := stopPoint y - startPoint y.		"Transcript show: startPoint asString , ' ' ,  stopPoint asString ,  ' ' , distance asString , '		'."		1 to: distance do: [ :index | | col |"		Transcript show: ( startPoint + ( 0 @ index ) ) asString , '		'."		col := (self submorphs select: [ :each | each containsPoint: startPoint + ( 0 @ index ) ]).		"Transcript show: col."		col ifNotEmpty:	[ ^ col first].		].		result ifNil: [^ aPLC_GraphicElementMorph ].		! !!PLC_View methodsFor: 'elements in screen directions' stamp: 'EricPernia 8/4/2013 02:34'!leftMorphFor: aPLC_GraphicElementMorph	"Devuelve el Morph a la izquieda del morph pasado como parámetro"	| startPoint stopPoint result distance |		result := nil.		startPoint := aPLC_GraphicElementMorph leftCenter.	stopPoint := (self left) @ startPoint y.		distance := startPoint x - stopPoint x.	"	Transcript show: startPoint asString , ' ' ,  stopPoint asString , '		'."		1 to: distance do: [ :index | | col |		"Transcript show: (startPoint - ( index @ 0 )) asString , ' '"		col := (self submorphs select: [ :each | each containsPoint: startPoint - ( index @ 0 ) ]).		"Transcript show: col."		col ifNotEmpty:	[ ^ col first].		].		result ifNil: [^ aPLC_GraphicElementMorph ].		! !!PLC_View methodsFor: 'elements in screen directions' stamp: 'EricPernia 8/4/2013 02:34'!rightMorphFor: aPLC_GraphicElementMorph	"Devuelve el Morph a la derecha del morph pasado como parámetro"	| startPoint stopPoint result distance |		result := nil.		startPoint := aPLC_GraphicElementMorph rightCenter.	stopPoint := (self right) @ startPoint y.		distance := stopPoint x - startPoint x.	"	Transcript show: startPoint asString , ' ' ,  stopPoint asString , '		'."		1 to: distance do: [ :index | | col |		"Transcript show: (startPoint - ( index @ 0 )) asString , ' '"		col := (self submorphs select: [ :each | each containsPoint: startPoint + ( index @ 0 ) ]).		"Transcript show: col."		col ifNotEmpty:	[ ^ col first].		].		result ifNil: [^ aPLC_GraphicElementMorph ].		! !!PLC_View methodsFor: 'extent' stamp: 'EricPernia 8/4/2013 02:35'!bottomOfGraphicElementBelowOfAll	"Devuelve el bottom del layoutRectangle del elemento mas abajo en pantalla dentro del ladderView"	^ self elements keys 		inject: 0		into: [:resParcial :elem | 			resParcial max: elem layoutRectangle bottom].! !!PLC_View methodsFor: 'extent' stamp: 'EricPernia 8/4/2013 02:35'!defaultExtent	^ 10@10.! !!PLC_View methodsFor: 'extent' stamp: 'EricPernia 8/4/2013 02:35'!extentChanged	self extent: self totalExtent.! !!PLC_View methodsFor: 'extent' stamp: 'EricPernia 8/4/2013 02:35'!rightOfGraphicElementRightOfAll	"Devuelve el right del layoutRectangle del elemento mas a la derecha en pantalla dentro del ladderView"	^ self elements keys 		inject: 0		into: [:resParcial :elem | 			resParcial max: elem layoutRectangle right].! !!PLC_View methodsFor: 'extent' stamp: 'EricPernia 8/4/2013 02:35'!totalExtent	^ ( self rightOfGraphicElementRightOfAll + self gridOrigin x ) @ ( self bottomOfGraphicElementBelowOfAll + self gridOrigin y ).! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!dragRectangle	"Devuelve un Rectangle de 288@168 alrededor de la posicion actual del puntero del mouse.	El cual es irtersecado con el área de la network para que no se pase para los costados."	| center origin corner|		center := World activeHand cursorPoint.		origin := center - (144@84).	corner := center + (144@84).		^ (Rectangle origin: origin corner: corner) intersect: self bounds.	! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!submorphUnderCursor: anEvent	"Devuelve un submorph o nil."		| collection |		collection := self submorphsUnderCursor: anEvent.		(collection size > 0)		ifTrue: [			^ collection first.			]		ifFalse: [			^ nil.			]! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!submorphsNotUnderCursor: anEvent	"Devuelve una colección de submorphs Manejador del evento Click con boton izquiedo del mouse"	"(click) sent when the mouse button goes up within doubleClickTime."		| collection |		collection := OrderedCollection new.		self submorphsDo: [ :submorph | 		(submorph containsPoint: anEvent cursorPoint)			ifFalse: [ collection add: submorph.]		].		^ collection.! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!submorphsNotUnderDraggRectangle	"Devuelve una colección de submorphs  que estan bajo el área del DraggRectangle"		| collection |		collection := OrderedCollection new.		self submorphsDo: [ :submorph | 		(submorph bounds intersects: self dragRectangle)			ifFalse: [ collection add: submorph.]		].		^ collection.! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!submorphsOn: aRectangle	"Devuelve una colección de submorphs  que estan bajo el área de aRectangle"		| collection |		collection := OrderedCollection new.		self submorphsDo: [ :submorph | 		(submorph bounds intersects: aRectangle)			ifTrue: [ collection add: submorph.]		].		^ collection.! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!submorphsUnderCursor: anEvent	"Devuelve una colección de submorphs Manejador del evento Click con boton izquiedo del mouse"	"(click) sent when the mouse button goes up within doubleClickTime."		| collection |		collection := OrderedCollection new.		self submorphsDo: [ :submorph | 		(submorph containsPoint: anEvent cursorPoint)			ifTrue: [ collection add: submorph.]		].		^ collection.! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!submorphsUnderDraggRectangle	"Devuelve una colección de submorphs  que estan bajo el área del DraggRectangle"		| collection |		collection := OrderedCollection new.		self submorphsDo: [ :submorph | 		(submorph bounds intersects: self dragRectangle)			ifTrue: [ collection add: submorph.]		].		^ collection.! !!PLC_View methodsFor: 'submorphs' stamp: 'EricPernia 8/4/2013 02:36'!submorphsUnselectAll	"Pasa todos sus submorphs al estado deseleccionado"	self submorphs do: [:submorph | 		submorph unselected].	! !!PLC_View methodsFor: 'properties' stamp: 'EricPernia 8/4/2013 02:36'!properties	"Devuelve la unica instancia de la clase PLC_GraphicElementProperties"	^ PLC_GraphicElementProperties uniqueInstance.! !!PLC_View methodsFor: 'mouse events' stamp: 'EricPernia 11/18/2013 00:04'!leftClick: anEvent	"Manejador del evento Click con boton izquiedo del mouse"	"(click) sent when the mouse button goes up within doubleClickTime."			| submorphUnderCursor |				anEvent hand newKeyboardFocus: self. "Le doy al Network Morph el foco del teclado."	self gotKeyboardFocus.	submorphUnderCursor := self submorphUnderCursor: anEvent.		"self lostKeyboardFocus."	submorphUnderCursor		ifNil: [			anEvent shiftPressed 				ifTrue: [					]				ifFalse: [					self unselectAll.	 "Pasa todos a la lista de deseleccionados y actualiza los estados de los elementos graficos."										].							] 		ifNotNil: [			anEvent shiftPressed 				ifTrue: [					self addSelectedAndKeyboardFocus: submorphUnderCursor.					]				ifFalse: [					self unselectAll.	 "Pasa todos a la lista de deseleccionados y actualiza los estados de los elementos graficos."					self selectedAndKeyboardFocus: submorphUnderCursor.										].					]. 			self changed.! !!PLC_View methodsFor: 'mouse events' stamp: 'EricPernia 11/17/2013 23:50'!leftDoubleClick: anEvent	"Manejador del evento doble click con el boton izquierdo del mouse"	"(doubleClick) sent when the mouse goes up, down, and up again all within DoubleClickTime."	| submorphUnderCursor |						anEvent hand newKeyboardFocus: self. "Le doy al Network Morph el foco del teclado."	self gotKeyboardFocus.		submorphUnderCursor := self submorphUnderCursor: anEvent.		self keyboardFocusElement lostKeyboardFocus.	self unselectAll.	 "Pasa todos a la lista de deseleccionados y actualiza los estados de los elementos graficos."			submorphUnderCursor		ifNil: [			] 		ifNotNil: [			self selectedAndKeyboardFocus: submorphUnderCursor.			self selectedElements first changeFunction: anEvent.			]. 			self changed.! !!PLC_View methodsFor: 'mouse events' stamp: 'EricPernia 8/4/2013 02:37'!leftDoubleClickTimeout: anEvent	"Manejador del evento doble click timeout con el boton izquierdo del mouse"	"(doubleClickTimeout) sent when the mouse does not have a doubleClick within DoubleClickTime.""	self networkController leftDoubleClickTimeout: anEvent."! !!PLC_View methodsFor: 'mouse events' stamp: 'EricPernia 8/4/2013 02:37'!rightClick: anEvent	"Manejador del evento Click con boton izquiedo del mouse"	"(click) sent when the mouse button goes up within doubleClickTime."	"	self networkController rightClick: anEvent."! !!PLC_View methodsFor: 'mouse events' stamp: 'EricPernia 8/4/2013 02:37'!rightDoubleClick: anEvent	"Manejador del evento doble click con el boton izquierdo del mouse"	"(doubleClick) sent when the mouse goes up, down, and up again all within DoubleClickTime."	"	self networkController rightDoubleClick: anEvent."! !!PLC_View methodsFor: 'mouse events' stamp: 'EricPernia 8/4/2013 02:37'!rightDoubleClickTimeout: anEvent	"Manejador del evento doble click timeout con el boton izquierdo del mouse"	"(doubleClickTimeout) sent when the mouse does not have a doubleClick within DoubleClickTime.""	self networkController rightDoubleClickTimeout: anEvent."! !!PLC_View methodsFor: 'mouse events' stamp: 'EricPernia 8/4/2013 02:37'!startDrag: anEvent	"(startDrag) sent when the mouse moves more than threshold pixels 	from evt's position within DoubleClickTime."		"	self networkController startDrag: anEvent."! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!aboutToBeGrabbedBy: aHand 	"Este mensaje llega cuando está a punto de ser agarrado por el puntero del mouse (HandMorph)."		super aboutToBeGrabbedBy: aHand.	self stopStepping.	! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!handleKeystroke: anEvent	"Manejador del evento de teclado."		"anEvent hand newKeyboardFocus: self. " "Le doy al morph el foco del teclado."	"anEvent hand newKeyboardFocus: nil." "Le saco al morph el foco del teclado."	"anEvent shiftPressed ifTrue: [Transcript show:  keyValue.] ." "Detecta si la tecla Shift esta presionada durante el evento"	"anEvent commandKeyPressed ifTrue: [ self color: Color blue.] ." "Detecta si la tecla Control esta presionada durante el evento"	| keyValue |	keyValue := anEvent keyValue.		Transcript show: anEvent asString , ' ' , keyValue asString  , ''.	keyValue = 127 "delete"		ifTrue: [ self keyDeletePressed. ].			keyValue = 111 "O"		ifTrue: [ self keyOPressed. ].			keyValue = 112 "P"		ifTrue: [ self keyPPressed. ].	keyValue = 99 "c"		ifTrue: [ 			anEvent commandKeyPressed "Detecta la tecla control del teclado"				ifTrue: [self commandCopy] 				ifFalse: [self keyCPressed] 			]. 			keyValue = 118 "v"		ifTrue: [ 			anEvent commandKeyPressed 				ifTrue: [self commandPaste] 				ifFalse: [self keyVPressed] 			].  			keyValue = 98 "b"		ifTrue: [ self keyBPressed. ].			keyValue = 110 "n"		ifTrue: [ self keyNPressed. ].	keyValue = 30 "up arrow"		ifTrue: [self keyUpPressed. ].			keyValue = 31 "down arrow"		ifTrue: [self keyDownPressed. ].		keyValue = 29 "right arrow"		ifTrue: [self keyRightPressed. ].	keyValue = 28 "left arrow"		ifTrue: [self keyLeftPressed. ].! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!handlesMouseDown: anEvent	"Permite manejar el evento de cuando el usuatio clickea el mouse sobre el morph."	^ true.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!handlesMouseOver: anEvent	"Permite manejar el evento de cuando el usuatio pasa el puntero del  mouse sobre el morph."	^ true.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!handlesMouseOverDragging: anEvent	"Permite manejar el evento de cuando el usuatio clickea el mouse sobre el morph."	^ true.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!justDroppedInto: aMorph event: anEvent	"Recien soltado dentro de aMorph"		self stopStepping.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!mouseDown: anEvent	"Manejador del evento mouse down"	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an 	ensuing click:, doubleClick:, or drag: message gets dispatched"	"Note that mouseMove: and mouseUp: events are not sent to aMorph until it becomes the mouse focus,	which is typically done by aMorph in its click:, doubleClick:, or drag: methods."		anEvent redButtonPressed "click"		ifTrue: [			anEvent hand				waitForClicksOrDrag: self				event: anEvent				selectors: {#leftClick:. #leftDoubleClick:. #leftDoubleClickTimeout:. #startDrag:.}				threshold: 5.								].				anEvent yellowButtonPressed "action-click"		ifTrue: [			anEvent hand				waitForClicksOrDrag: self				event: anEvent				selectors: {#rightClick:. #rightDoubleClick:. #rightDoubleClickTimeout:. nil.}				threshold: 5.			].! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!mouseEnter: anEvent	"Manejador del evento mouse up"		self stopStepping.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!mouseEnterDragging: anEvent	"Manejador del evento mouse up"		self startStepping.		"Para caundo el morph bajo el que este arrastrando el cursor pueda ser el mismo Network"	"anEvent hand submorphsDo: [ :subm | 		subm == self 			ifFalse: [				self startStepping.				].		]."! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!mouseLeave: anEvent	"Manejador del evento mouse up"		self stopStepping.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!mouseLeaveDragging: anEvent	"Manejador del evento mouse up"	self unselectAll.	self stopStepping.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!mouseMove: anEvent	"Manejador del evento mouse move. Este evento ocurre cuando se 	presiona el mouse y se arrastra presionado sobre el morph.""	anEvent redButtonPressed 		ifTrue: [self color: Color white.].			anEvent yellowButtonPressed 		ifTrue: [self color: Color black].	self changed."! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!mouseUp: anEvent	"Manejador del evento mouse up"	self stopStepping. "Ver......"! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!rejectDropMorphEvent: anEvent	"Manejador del evento mouse up"		self unselectAll.	"Ver..."! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!repelsMorph: aMorph event: anEvent	"Devuelve un booleano"	self stopStepping.	(self submorphs) do: [:submorph | submorph unselected.]. 	^(self wantsDroppedMorph: aMorph event: anEvent) not.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!step	"accion cada vez que le llega el mensaje step"	"self submorphsUnderDraggRectangle do: [:submorph | 		submorph underDraggArea].		self submorphsNotUnderDraggRectangle do: [:submorph | 		submorph notUnderDraggArea]."	! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!stepTime	"stepTime en ms"	^ 100.! !!PLC_View methodsFor: 'event handling' stamp: 'EricPernia 8/4/2013 02:41'!wantsDroppedMorph: aMorph event: anEvent	self stopStepping.	^  aMorph isKindOf: PLC_GraphicElementMorph. "Tiene que responder true si el morph es un elemento Ladder o FBD"! !!PLC_View methodsFor: 'keyboard events' stamp: 'EricPernia 8/4/2013 02:44'!keyDeletePressed	"Este mensaje se dispara cuando presionan la tecla Suprimir."	self removeSelectedElements.! !!PLC_View methodsFor: 'keyboard events' stamp: 'EricPernia 8/4/2013 02:44'!keyDownPressed	"Este mensaje se dispara cuando presionan la tecla Down Arrow."			| newKeyboardFocusElement |		newKeyboardFocusElement := self beneathMorphFor: self keyboardFocusElement.		self unselectAll.	self selectedAndKeyboardFocus: newKeyboardFocusElement.		"self networkMorph position: self networkMorph position + (0 @ 1)."	! !!PLC_View methodsFor: 'keyboard events' stamp: 'EricPernia 8/4/2013 02:44'!keyLeftPressed	"Este mensaje se dispara cuando presionan la tecla Left Arrow."		| newKeyboardFocusElement |		newKeyboardFocusElement := self leftMorphFor: self keyboardFocusElement.		self unselectAll.	self selectedAndKeyboardFocus: newKeyboardFocusElement.		"networkMorph position: self networkMorph position - (1 @ 0)."! !!PLC_View methodsFor: 'keyboard events' stamp: 'EricPernia 8/4/2013 02:44'!keyRightPressed	"Este mensaje se dispara cuando presionan la tecla Right Arrow."		| newKeyboardFocusElement |		newKeyboardFocusElement := self rightMorphFor: self keyboardFocusElement.		self unselectAll.	self selectedAndKeyboardFocus: newKeyboardFocusElement.		"self networkMorph position: self networkMorph position + (1 @ 0)."	! !!PLC_View methodsFor: 'keyboard events' stamp: 'EricPernia 8/4/2013 02:44'!keyUpPressed	"Este mensaje se dispara cuando presionan la tecla Up Arrow."		| newKeyboardFocusElement |		newKeyboardFocusElement := self aboveMorphFor: self keyboardFocusElement.		self unselectAll.	self selectedAndKeyboardFocus: newKeyboardFocusElement.		"self networkMorph position: self networkMorph position - (0 @ 1)."	! !!PLC_View methodsFor: 'initialize-release' stamp: 'EricPernia 11/17/2013 17:29'!initialize	"comment stating purpose of message"	super initialize. "Siempre hay que hacerlo en una subclase de MORPH"		"Cambio el tamaño y color"	self extent: self defaultExtent.	self color: Color white.	self borderColor: Color white.	self borderWidth: 2.			"Abro"	self openInWorld.! !!PLC_View methodsFor: 'loop' stamp: 'EricPernia 8/4/2013 04:28'!refresh	"Refresca la vista la vista"	"Hago la vista invisible durante todo el proceso de dibujado"	"self visible: false."		"Guardo los bloques conectables de los elementos morph 	seleccionados y del elemento morph con foco del teclado."	"self saveUIContext." "ANDA MAL"			"Remuevo todos los submorphs"	self removeAllMorphs.		"Inicializo el diccionario elements que contiene asociaciones 	graphicElement --> connectableBlock "	self elements: Dictionary new.		"Inicializo las Colecciones"	self unselectedElements: OrderedCollection new.	self selectedElements: OrderedCollection new.	self keyboardFocusElement: self.! !PLC_View subclass: #PLC_GraphicProgramView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Networks'!!PLC_GraphicProgramView commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_GraphicProgramView is xxxxxxxxx.Instance Variables!!PLC_GraphicProgramView methodsFor: 'model accessing' stamp: 'EricPernia 8/4/2013 02:41'!blockConnectedToInput: anInputNumber for: aGraphicElement	"Devuelve el elemento morph del bloque conectable conectado	a la entrada anInputNumber del elemento morph aGraphicElement."	| connectableBlock |	connectableBlock := ( self modelElementForGraphicElement: aGraphicElement ) blockConnectedToInput: anInputNumber.		^ self graphicElementForModelElement: connectableBlock.! !!PLC_GraphicProgramView methodsFor: 'model accessing' stamp: 'EricPernia 8/4/2013 02:41'!blockConnectedToOutput: anOutputNumber for: aGraphicElement	"Devuelve el elemento morph del bloque conectable conectado	a la salida anOutputNumber del elemento morph aGraphicElement."	| connectableBlock |	connectableBlock := ( self modelElementForGraphicElement: aGraphicElement ) blockConnectedToOutput: anOutputNumber.		^ self graphicElementForModelElement: connectableBlock.! !!PLC_GraphicProgramView methodsFor: 'model accessing' stamp: 'EricPernia 8/4/2013 02:41'!connectedAtInput: aNumber for: aGraphicElement	"Devuelve el elemento morph del bloque conectable o conexión conectado	a la entrada aNumber del elemento morph aGraphicElement."	| connectableBlock |	connectableBlock := ( self modelElementForGraphicElement: aGraphicElement ) connectedAtInput: aNumber.		^ self graphicElementForModelElement: connectableBlock.	! !!PLC_GraphicProgramView methodsFor: 'model accessing' stamp: 'EricPernia 8/4/2013 02:41'!connectedAtOutput: aNumber for: aGraphicElement	"Devuelve el elemento morph del bloque conectable o conexión conectado	a la salida aNumber del elemento morph aGraphicElement."	| connectableBlock |	connectableBlock := ( self modelElementForGraphicElement: aGraphicElement) connectedAtOutput: aNumber.		^ self graphicElementForModelElement: connectableBlock.! !!PLC_GraphicProgramView methodsFor: 'model accessing' stamp: 'EricPernia 8/4/2013 02:41'!modelElementForGraphicElement: aGraphicElement	"Devuelve el bloque conectable o conexion correspondiente al elemento grafico."	^ self elements at: aGraphicElement! !!PLC_GraphicProgramView methodsFor: 'commands send to self' stamp: 'EricPernia 8/4/2013 02:48'!changeActualArgumentFor: actualArgumentMorph by: aString	"Cambia el alactual argument del elemento del modelo de actualArgumentMorph por el string aString"		| connectableBlock |			"Busco el bloque conectable del actualArgumentMorph"	connectableBlock := self modelElementForGraphicElement: actualArgumentMorph.		"Le doy la orden al controller para que cambie el actual argument"	self controller changeActualArgumentFor: connectableBlock by: aString	! !!PLC_GraphicProgramView methodsFor: 'compilation' stamp: 'EricPernia 11/6/2013 13:08'!generateCode	"METODO PROVISORIO. Se lo envía el editor ladder. Sirve para mostrar en un Transcript el programa compilado."		| progAcc |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.		"Le envio la petición al controlador de que se compile en el programa de objetos"	self controller generateCodeIn: progAcc.		"Abro un Transcript y muestro las 2 compilaciones"	Transcript open.		Transcript show: '	Programa en IL:	------------------------' , progAcc compilerDataTypesDecls ilCompile ,'' ,  progAcc compilerVarDecls ilCompile ,'' , progAcc compiledBody ilCompile ,''.			Transcript show: '	Programa en C:	------------------------' , progAcc compilerDataTypesDecls cCompile ,'' ,  progAcc compilerVarDecls cCompile ,'' , progAcc compiledBody cCompile ,''.	! !PLC_GraphicProgramView subclass: #PLC_LadderView	instanceVariableNames: 'groups'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Networks'!!PLC_LadderView commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_LadderView is xxxxxxxxx.Instance Variables	groups:		<Object>groups	- xxxxx!!PLC_LadderView methodsFor: 'draw elements' stamp: 'EricPernia 7/4/2013 02:47'!drawElementFromBlock: connectableBlock	"Dibujo el elemento grafico de connectableBlock."	| graphicElement |		"Chequeo si ya lo dibuje, si es así no lo vuelvo a dibujar."	( self wasDrawn: connectableBlock ) 		ifTrue: [			^ nil.			] 		ifFalse: [			"Creo el elemento grafico."			graphicElement := connectableBlock graphicElement.				"Lo agrego de submorph"			self addMorph: graphicElement.				"Lo agrego al diccionario elementos"			self elements at: graphicElement put: connectableBlock.						"Le pido al elemento que aguregue sus morphs dependientes al ladderView si tiene.			Estos pueden ser Actual Arguments o Pines"			graphicElement addDependentsOnLadderView: self from: connectableBlock.						"Dibujo todas sus salidas"			self drawOutputsForElement: graphicElement.						"Lo agrego a la lista de seleccionados y le doy el foco del teclado"			self selectedAndKeyboardFocus: graphicElement.						^ graphicElement.			].! !!PLC_LadderView methodsFor: 'draw elements' stamp: 'EricPernia 11/5/2013 13:19'!drawElements	"Dibuja todos los elementos explorando el modelo. Los agrego al diccionario elements."		| connectableBlock |		"Busco en el modelo el Riel Izquierdo en el modelo"	connectableBlock := self ladderNetwork leftPowerRailBlock.		"Comienzo a dibujar todo el modelo comenzando por el LeftPowerRail.	Cuando termina de dibujar el elemento dibuja todos los elementos conectados a sus salidas.	En consecuencia, dibuja todos los elementos del modelo."	self drawElementFromBlock: connectableBlock.! !!PLC_LadderView methodsFor: 'draw elements' stamp: 'EricPernia 11/5/2013 13:19'!drawHorizontalLinks	"Dibuja todos los Horizontal Links del modelo. Los agrega al diccionario elements."		| leftPowerRailMorph |		"Busco en el modelo el Riel Izquierdo en el modelo"	leftPowerRailMorph := self graphicElementForModelElement: (self ladderNetwork leftPowerRailBlock).	"Comienzo a dibujar todos los horizontal links del modelo comenzando por las salidas del LeftPowerRail.	Cuando termina de dibujar le pide que dibuje a todos los elementos conectados a sus salidas.	En consecuencia, dibuja todos los horizontal links del modelo."	leftPowerRailMorph drawHorizontalLinksFrom: self.! !!PLC_LadderView methodsFor: 'draw elements' stamp: 'EricPernia 7/17/2013 01:57'!drawHorizontalLinksFrom: connectableBlock	"Dibuja todos los Horizontal Links a las salidas de connectableBlock. 	Los agrega al diccionario elements. Por último le dice a los elementos	graficos conectados a sus salidas que dibujen sus horizontal links."	| graphicElement horizontalLink connection outputConnectableBlock |		graphicElement := self graphicElementForModelElement: connectableBlock.	"Si no tiene salidas no hace nada!!!!"	( 1 to: graphicElement outputPins size ) do: [ :ind |				"Creo el Horizontal Link corespondiente a la salida numero ind."		horizontalLink := PLC_HorizontalLinkMorph new.				"Lo agrego de submorph"		self addMorph: horizontalLink.				"Busco la conexion a la salida numero ind de connectableBlock"		connection := connectableBlock connectedAtOutput: ind.				"Busco el bloque conectable conectado a la salida numero ind"		outputConnectableBlock := connectableBlock blockConnectedToOutput: ind.			"Lo agrego al diccionario elementos"		self elements at: horizontalLink put: connection.					"Lo agrego a la lista de seleccionados y le doy el foco del teclado"		self selectedAndKeyboardFocus: horizontalLink.				"Posiciono el Horizontal Link"		horizontalLink centeredToTheRight: ( graphicElement outputPins at: ind ).				"Actualizo su tamaño"		horizontalLink extentChanged.							"Dibujo los horizontal links de los elementos conectados a sus salidas"		self drawHorizontalLinksFrom: outputConnectableBlock.				].! !!PLC_LadderView methodsFor: 'draw elements' stamp: 'EricPernia 8/6/2013 23:48'!drawOutputsForElement: aGraphicElement	"Dibujo todos los morphs conectados a las salidas de aGraphicElement"	| connectableBlock outputConnectableBlock |		"Obtengo el bloque conectable de aGraphicElement."	connectableBlock := self modelElementForGraphicElement: aGraphicElement.			"Si no tiene salidas no hace nada!!!!"	( 1 to: aGraphicElement outputPinsSize ) do: [ :ind |				"Busco el bloque conectable conectado a la salida numero ind"		outputConnectableBlock := connectableBlock blockConnectedToOutput: ind.				"Dibujo el elemento grafico del bloque hallado"		self drawElementFromBlock: outputConnectableBlock.		].! !!PLC_LadderView methodsFor: 'draw elements' stamp: 'EricPernia 3/29/2013 04:35'!wasDrawn: connectableBlock	"Responde true si el elemento ya fue dibujado antes. Para responder chequea en su diccionario elements."	^ self elements values includes: connectableBlock.	! !!PLC_LadderView methodsFor: 'layout' stamp: 'EricPernia 7/14/2013 06:59'!gotAGroupHorizontallyUnderElement: aGraphicElementMorph	"Devuelve true si encuentra un Grupo cuyo layoutRectangle pise el layoutRectangle de aGraphicElementMorph.	Si no encuentra ninguno devuelve false."		( self maxRightGroupUnderElement: aGraphicElementMorph ) 		ifNil: [			^ false.			] 		ifNotNil: [			^ true.			].! !!PLC_LadderView methodsFor: 'layout' stamp: 'EricPernia 7/14/2013 06:43'!gotAnElementVerticallyUnderGroup: aGroup	"Devuelve true si encuentra un Elemento cuyo layoutRectangle pise el layoutRectangle de aGroup.	Si no encuentra ninguno devuelve false."		( self maxBottomElementUnderGroup: aGroup ) 		ifNil: [			^ false.			] 		ifNotNil: [			^ true.			].! !!PLC_LadderView methodsFor: 'layout' stamp: 'EricPernia 11/5/2013 13:19'!layoutElements	"Dispone en pantalla todos los elementos dentro del ladderView"	| connectableBlockLPR graphicElementLPR |		"Busco en el modelo el Riel Izquierdo en el modelo"	connectableBlockLPR := self ladderNetwork leftPowerRailBlock.	"Obtengo el elemento grafico del bloque conectable"	graphicElementLPR := self graphicElementForModelElement: connectableBlockLPR.		"Comienzo a explorar todo el modelo comenzando por el LeftPowerRail."	graphicElementLPR layoutOn: self.	! !!PLC_LadderView methodsFor: 'layout' stamp: 'EricPernia 7/14/2013 20:12'!maxBottomElementUnderGroup: aGroup 	"Devuelve el elemento de mayor layoutRectangle bottom cuyo 	layoutRectangle pise al layoutRectangle de aGroup."		| elementsUnderGroup maxElement | 		"Selecciono los elementos que estén bajo aGroup"	elementsUnderGroup := OrderedCollection new.	self elements keys asOrderedCollection do: [ :each | 		( each layoutRectangle intersects: aGroup layoutRectangle )			ifTrue: [ elementsUnderGroup add: each. ].		].	"Extraigo de la coleccion los elementos pertenecientes al grupo.	Porque sino el grupo siempre pisa a los elementos que lo forman."	aGroup elements do: [ :each |		( elementsUnderGroup includes: each )			ifTrue: [ 				elementsUnderGroup remove:	each.						].		].		"Extraigo los elementos dependientes de los elementos del grupo."	aGroup elementsDependentsUnderGroupLayoutRectangle do: [ :each |		( elementsUnderGroup includes: each )			ifTrue: [ 				elementsUnderGroup remove:	each.						].		].		"Extraigo los elementos que no estén ya posicionados en X."	elementsUnderGroup do: [ :each |		( each xPositioned )			ifFalse: [ 				elementsUnderGroup remove:	each.						].		].	"Extraigo los elementos que no estén ya posicionados en Y."	elementsUnderGroup do: [ :each |		( each yPositioned )			ifFalse: [ 				elementsUnderGroup remove:	each.						].		].		"Busco el elemento cuyo layoutRectangle bottom sea maximo"	( elementsUnderGroup size > 0 )		ifTrue: [			maxElement := elementsUnderGroup first.			elementsUnderGroup do: [ :actualElem | 				( actualElem layoutRectangle bottom >= maxElement  layoutRectangle bottom )					ifTrue: [ maxElement := actualElem. ]. 				].			]		ifFalse: [ 			^ nil.			].	^ maxElement.	! !!PLC_LadderView methodsFor: 'layout' stamp: 'EricPernia 7/14/2013 07:11'!maxRightGroupUnderElement: aGraphicElementMorph	"Devuelve true si encuentra un Grupo cuyo layoutRectangle pise el layoutRectangle de aGraphicElementMorph.	Si no encuentra ninguno devuelve nil."		| groupsUnderElement group maxRightGroup | 		"Obtengo el grupo del elemento"	group := self groupFor: aGraphicElementMorph.				"Selecciono los grupos que estén bajo aGraphicElementMorph"	groupsUnderElement := OrderedCollection new.	self groups do: [ :each | 		( each layoutRectangle intersects: aGraphicElementMorph layoutRectangle )			ifTrue: [ groupsUnderElement add: each. ].		].	"Extraigo de la coleccion el grupo perteneciente a aGraphicElementMorph.	Porque sino el grupo siempre pisa a los elementos que lo forman."	groupsUnderElement 		remove: group 		ifAbsent: [ nil. ].		"Busco el grupo cuyo layoutRectangle right sea maximo"	( groupsUnderElement size > 0 )		ifTrue: [			maxRightGroup := groupsUnderElement first.			groupsUnderElement do: [ :actualElem | 				( actualElem layoutRectangle right >= maxRightGroup layoutRectangle right )					ifTrue: [ maxRightGroup := actualElem. ]. 				].			]		ifFalse: [ 			^ nil.			].	^ maxRightGroup.	! !!PLC_LadderView methodsFor: 'connection states' stamp: 'EricPernia 11/5/2013 13:20'!updateOutputsConnectonStates	"Actualiza las capas de estado de conexion de todos los elementos dentro del ladderView"	| connectableBlockLPR graphicElementLPR |		"Busco en el modelo el Riel Izquierdo en el modelo"	connectableBlockLPR := self ladderNetwork leftPowerRailBlock.	"Obtengo el elemento grafico del bloque conectable"	graphicElementLPR := self graphicElementForModelElement: connectableBlockLPR.		"Comienzo a actualizar todos los estados de conexion de los elementos graficos 	comenzando por el LeftPowerRail."	graphicElementLPR updateOutputsConnectonStates.	! !!PLC_LadderView methodsFor: 'loop' stamp: 'EricPernia 8/4/2013 04:28'!refresh	"Refresca la vista la vista"	super refresh.		self drawElements; 							"Dibuja los elemetos en el origen y los agrega a sus colecciones"		exploreModel;								"Crea los grupos de elementos"		updateOutputsConnectonStates;			"Actualiza los estados de conexion de los elementos"		layoutElements;							"Dispone todos los elementos en pantalla"		drawHorizontalLinks;						"Dibuja todos los Horizontal Links"		extentChanged.							"Actualiza el tamaño del ladderView"	"Restauro la lista de seleccionados y el Foco del teclado"	"self restoreUIContext." "ANDA MAL"							"Hago que sea visible"	"self visible: true."! !!PLC_LadderView methodsFor: 'loop' stamp: 'EricPernia 7/17/2013 01:57'!restoreUIContext	"Restauro la lista de seleccionados y el Foco del teclado"			| selectedConnectableBlocks keyboardFocusConnectableBlock |	uiContext ifNotNil: [ 				"Paso todos los elementos a la lista de deseleccionados"		self unselectAll.		"Busco las la lista de bloques conectables seleccionados"		selectedConnectableBlocks := uiContext at: 1.			"Añado a la lista de seleccionados los elementos restantes"		selectedConnectableBlocks do: [ :each |			self addSelectedAndKeyboardFocus: ( self graphicElementForModelElement: each ).			].			"Busco el bloque conectable con foco del teclado"		keyboardFocusConnectableBlock := uiContext at: 2.				"Añado el elemento del foco del teclado"		self addSelectedAndKeyboardFocus: ( self graphicElementForModelElement: keyboardFocusConnectableBlock ).				].! !!PLC_LadderView methodsFor: 'loop' stamp: 'EricPernia 7/17/2013 01:54'!saveUIContext	"Guardo los bloques conectables de los elementos morph seleccionados 	y del elemento morph con foco del teclado, si existen."			| selectedConnectableBlocks keyboardFocusConnectableBlock |			( self selectedElements = nil and: [ self keyboardFocusElement = nil ] )		ifFalse: [ 					selectedConnectableBlocks := OrderedCollection new.						self selectedElements ifNotNil: [				self selectedElements do: [ :each |					selectedConnectableBlocks add: 					( self modelElementForGraphicElement: each ).					].				].			self keyboardFocusElement 				ifNotNil: [  					keyboardFocusConnectableBlock := 						( self modelElementForGraphicElement: self keyboardFocusElement ).					].							uiContext := {selectedConnectableBlocks. keyboardFocusConnectableBlock. }.					].			! !!PLC_LadderView methodsFor: 'model exploration' stamp: 'EricPernia 11/5/2013 13:19'!exploreModel	"Explora el modelo"	| connectableBlockLPR graphicElementLPR |	"Inicializo las colecciones de los grupos de elementos del modelo."	self groups: OrderedCollection new.		"Busco en el modelo el Riel Izquierdo en el modelo"	connectableBlockLPR := self ladderNetwork leftPowerRailBlock.	"Obtengo el elemento grafico del bloque conectable"	graphicElementLPR := self graphicElementForModelElement: connectableBlockLPR.		"Comienzo a explorar todo el modelo comenzando por el LeftPowerRail."	graphicElementLPR exploreModel.					! !!PLC_LadderView methodsFor: 'model exploration' stamp: 'EricPernia 7/17/2013 01:56'!graphicElementForModelElement: aModelElement	"Devuelve el elemento grafico correspondiente al bloque conectable o conexion."	^ self elements keyAtValue: aModelElement.! !!PLC_LadderView methodsFor: 'model exploration' stamp: 'EricPernia 7/9/2013 02:32'!groupFor: anElementOrGroup	"Devuelve el grupo que contiene al elemento o grupo anElementOrGroup."		^ self groups 		detect: [ :group |			group includes: anElementOrGroup.			]		ifNone: [ ^ nil ].! !!PLC_LadderView methodsFor: 'model exploration' stamp: 'EricPernia 7/9/2013 00:54'!wasExplored: aGraphicElement.	"Responde true si el elemento ya fue explorado. Para verificarlo lo busca en sus grupos."	^ self groups anySatisfy: [ :group |		group includes: aGraphicElement.		 ].! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 4/22/2013 01:45'!keyBPressed	"Este mensaje se dispara cuando presionan la tecla B."	self addCoilOnKeyboardFocusElement.! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 5/1/2013 19:45'!keyCPressed	"Este mensaje se dispara cuando presionan la tecla C."		self addNOContactOnKeyboardFocusElement.	"	Transcript show: ' Key C pressed'."	! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 6/29/2013 18:54'!keyFPressed	"Este mensaje se dispara cuando presionan la tecla F."		self addFunctionOnKeyboardFocusElement.	"	Transcript show: ' Key C pressed'."	! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 6/29/2013 18:54'!keyGPressed	"Este mensaje se dispara cuando presionan la tecla G."		self addFunctionBlockOnKeyboardFocusElement.	"	Transcript show: ' Key C pressed'."	! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 4/22/2013 01:45'!keyNPressed	"Este mensaje se dispara cuando presionan la tecla N."	self addNCoilOnKeyboardFocusElement.! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 5/1/2013 23:23'!keyOPressed	"Este mensaje se dispara cuando presionan la tecla O."		self openBranchOnKeyboardFocusElement.! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 5/1/2013 23:25'!keyPPressed	"Este mensaje se dispara cuando presionan la tecla P."		self closeBranchOnSelectedElements.! !!PLC_LadderView methodsFor: 'keyboard events' stamp: 'EricPernia 5/1/2013 19:47'!keyVPressed	"Este mensaje se dispara cuando presionan la tecla V."	self addNCContactOnKeyboardFocusElement.	"		Transcript show: ' Key V pressed'.	"! !!PLC_LadderView methodsFor: 'drawing groups' stamp: 'EricPernia 7/9/2013 02:00'!drawGroups	"Dibuja los grupos de elementos con la misma posición vertical (ciam) del ladderView"		| morph |	self groups do: [ :group |				"Dibujo el rectangulo del grupo"		morph := BorderedMorph new.		morph color: ( Color lightBlue alpha: 0.5 ).		morph borderColor: Color blue.		morph extent: group layoutRectangle extent.		morph position: group layoutRectangle topLeft.				"Añado este rectangulo como submorph"		self addMorph: morph.				].! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 5/1/2013 20:42'!addCoilOnKeyboardFocusElement	"Agrega una Bobina sobre el elemento que tenga el foco del teclado."		| aConnectableBlockOrConnection |		"Busco el Bloque Conectable o conexion del elemento con el Foco del Teclado."	aConnectableBlockOrConnection := self elements at: self keyboardFocusElement.		self ladderController addCoilOn: aConnectableBlockOrConnection.	! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 11/17/2013 06:23'!addFunctionBlockOnKeyboardFocusElement	"Agrega un Bloque Función sobre el elemento que tenga el foco del teclado."		| funBlkList |		"Obtengo el controlador de la lista de funciones de la biblioteca"	funBlkList := PLC_Libraries uniqueInstance functionBlockList.		"Le seteo al list que el resultado me lo mande a mi (self = ladderView)"	funBlkList target: self.		"Le seteo al list que mensaje me tiene que mandar a mi con el resultado como parametro"	funBlkList targetMessage: #addFunctionBlockOnKeyboardFocusElement:.			"Le mando al controlador de la lista de funciones contenido en su	 biblioteca que muestre su vista de Lista de Funciones"	funBlkList openAt: self positionInWorld + ( 554 @ 82 negated ). ! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 11/17/2013 06:03'!addFunctionBlockOnKeyboardFocusElement: aFunctionBlock	"Agrega el Bloque de Función Elegido aFunctionBlock sobre el elemento que tenga el foco del teclado.		addFunctionBlockOnKeyboardFocusElement"		| aConnectableBlockOrConnection |		"Busco el Bloque Conectable o conexion del elemento con el Foco del Teclado."	aConnectableBlockOrConnection := self elements at: self keyboardFocusElement.			self ladderController 		addFunctionBlockCallWithDeclaration: aFunctionBlock		on: 	aConnectableBlockOrConnection.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 11/17/2013 06:24'!addFunctionOnKeyboardFocusElement	"Agrega una Función sobre el elemento que tenga el foco del teclado."		| funList |		"Obtengo el controlador de la lista de funciones"	funList := PLC_Libraries uniqueInstance functionList.		"Le seteo al list que el resultado me lo mande a mi (self = ladderView)"	funList target: self.		"Le seteo al list que mensaje me tiene que mandar a mi con el resultado como parametro"	funList targetMessage: #addFunctionOnKeyboardFocusElement:.			"Le mando al controlador de la lista de funciones contenido en su	 biblioteca que muestre su vista de Lista de Funciones"	funList openAt: self positionInWorld + ( 364 @ 82 negated ). ! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 11/17/2013 05:33'!addFunctionOnKeyboardFocusElement: aFunction	"Agrega la Función Elegida aFunction sobre el elemento que tenga el foco del teclado.		addFunctionBlockOnKeyboardFocusElement"		| aConnectableBlockOrConnection |		"Busco el Bloque Conectable o conexion del elemento con el Foco del Teclado."	aConnectableBlockOrConnection := self elements at: self keyboardFocusElement.			self ladderController 		addFunctionCallWithDeclaration: aFunction		on: 	aConnectableBlockOrConnection.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 5/1/2013 20:42'!addNCContactOnKeyboardFocusElement	"Agrega un Contacto normal cerrado sobre el elemento que tenga el foco del teclado."		| aConnectableBlockOrConnection |		"Busco el Bloque Conectable o conexion del elemento con el Foco del Teclado."	aConnectableBlockOrConnection := self elements at: self keyboardFocusElement.		self ladderController addNCContactOn: aConnectableBlockOrConnection.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 5/1/2013 20:42'!addNCoilOnKeyboardFocusElement	"Agrega una Bobina Negada sobre el elemento que tenga el foco del teclado."		| aConnectableBlockOrConnection |		"Busco el Bloque Conectable o conexion del elemento con el Foco del Teclado."	aConnectableBlockOrConnection := self elements at: self keyboardFocusElement.		self ladderController addNCoilOn: aConnectableBlockOrConnection.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 5/1/2013 20:13'!addNOContactOnKeyboardFocusElement	"Agrega un Contacto normal abierto sobre el elemento que tenga el foco del teclado."		| aConnectableBlockOrConnection |		"Busco el Bloque Conectable o conexion del elemento con el Foco del Teclado."	aConnectableBlockOrConnection := self elements at: self keyboardFocusElement.		self ladderController addNOContactOn: aConnectableBlockOrConnection.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 7/17/2013 01:53'!closeBranchOnSelectedElements	"Cierra una rama entre una conexion o bloque y otra conexion si se puede."		| aPLC_ConnectableBlockOrConnection aPLC_Connection |		aPLC_ConnectableBlockOrConnection := self selectedElements first.	aPLC_ConnectableBlockOrConnection := self modelElementForGraphicElement: aPLC_ConnectableBlockOrConnection.		aPLC_Connection := self selectedElements last.	aPLC_Connection := self modelElementForGraphicElement: aPLC_Connection.		self ladderController closeBranchFrom: aPLC_ConnectableBlockOrConnection to: aPLC_Connection.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 5/1/2013 23:18'!openBranchOnConnection: aGraphicConnection	"Abre una rama sobre una conexion (==)."		| aConnection |		"Busco la conexion del elemento con el Foco del Teclado."	aConnection := self elements at: self keyboardFocusElement.		self ladderController openBranchOnConnection: aConnection.	! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 5/1/2013 23:35'!openBranchOnKeyboardFocusElement	"Abre una rama sobre la conexion que tenga el foco del teclado."		| aConnectableBlockOrConnection |		"Busco la conexion del elemento con el Foco del Teclado."	aConnectableBlockOrConnection := self keyboardFocusElement.		"Evio la peticion al elemento grafico"	aConnectableBlockOrConnection openBranchOnConnectionFrom: self.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 7/17/2013 01:54'!removeCoil: aContact	"Remueve una Bobina."		| aConnectableBlock |		"Busco el Bloque Conectable del elemento grafico."	aConnectableBlock := self modelElementForGraphicElement: aContact.		"Le envio la peticon al controlador"	self ladderController removeCoil: aConnectableBlock.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 7/31/2013 22:13'!removeContact: aContact	"Remueve un Contacto."		| aConnectableBlock |		"Busco el Bloque Conectable del elemento grafico."	aConnectableBlock := self modelElementForGraphicElement: aContact.		"Le envio la peticion al controlador"	self ladderController removeContact: aConnectableBlock.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 7/31/2013 22:13'!removeFunctionCall: aFunctionCallGraphicElementMorph	"Remueve un llamado a Función."		| aConnectableBlock |		"Busco el Bloque Conectable del elemento grafico."	aConnectableBlock := self modelElementForGraphicElement: aFunctionCallGraphicElementMorph.		"Le envio la peticion al controlador"	self ladderController removeFunctionCall: aConnectableBlock.! !!PLC_LadderView methodsFor: 'commands send to controller' stamp: 'EricPernia 7/31/2013 22:13'!removeRightPowerRail: aRightPowerRail	"Remueve un Right Power Rail:."		| aConnectableBlock |		"Busco el Bloque Conectable del elemento grafico."	aConnectableBlock := self modelElementForGraphicElement: aRightPowerRail.		"Le envio la peticion al controlador"	self ladderController removeRightPowerRail: aConnectableBlock.! !!PLC_LadderView methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:52'!groups		^ groups! !!PLC_LadderView methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!groups: anObject		groups := anObject! !!PLC_LadderView methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:41'!ladderController	^ self controller! !!PLC_LadderView methodsFor: 'accessing' stamp: 'EricPernia 8/4/2013 02:29'!ladderController: anObject	self controller: anObject.! !!PLC_LadderView methodsFor: 'grid' stamp: 'EricPernia 10/9/2013 13:58'!gridExtent	"Devuelve el tamaño en pixeles de una celda de la grilla gris."		^ self properties gridExtent.! !!PLC_LadderView methodsFor: 'grid' stamp: 'EricPernia 10/9/2013 13:58'!gridOrigin	"Devuelve la posicion 0@0 de la grilla"	^ self position + self properties gridOrigin.! !!PLC_LadderView methodsFor: 'grid' stamp: 'EricPernia 10/9/2013 13:58'!gridRectangleIn: aPoint	"Rectangulo del tamaño de la grilla"		| rectangle |		rectangle := Rectangle origin: ( 0 @ 0 ) corner: self gridExtent.	^ rectangle translateBy: aPoint * self gridExtent + self gridOrigin.! !!PLC_LadderView methodsFor: 'grid' stamp: 'EricPernia 10/9/2013 13:58'!gridSize	"Devuelve el tamaño de la grilla gris. Es decir, cuantos rectangulos por cuantos tiene la grilla"		^ ( 6 @ 10 ).! !!PLC_LadderView methodsFor: 'drawing' stamp: 'EricPernia 10/9/2013 14:00'!drawGridOn: aCanvas	"Dibujo la grilla."	(0 to: self gridSize y - 1) do: [ :vIndex |		(0 to: self gridSize x - 1) do: [ :hIndex |			aCanvas frameRectangle: ( self gridRectangleIn: (hIndex @ vIndex) )  width: 1 colors: {Color lightGray} dashes: {1}.			].		].! !!PLC_LadderView methodsFor: 'drawing' stamp: 'EricPernia 10/9/2013 14:00'!drawOn: aCanvas	"Dibujo la grilla."	super drawOn: aCanvas.		self properties drawGrid ifTrue: [		self drawGridOn: aCanvas.		].! !!PLC_LadderView methodsFor: 'model accessing' stamp: 'EricPernia 11/5/2013 13:24'!connectableBlocksNetwork	"Devuelve la connectableBlocksNetwork de su controlador."	^ self controller ladderNetwork ! !!PLC_LadderView methodsFor: 'model accessing' stamp: 'EricPernia 11/5/2013 13:22'!ladderNetwork	"Devuelve la ladderNetwork de su controlador."	^ self controller ladderNetwork ! !PLC_View subclass: #PLC_Grid	instanceVariableNames: 'rows morphRows selectedIndex pouDeclarations identifier'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Networks'!!PLC_Grid commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Grid is xxxxxxxxx.Instance Variables	identifier:		<Object>	morphRows:		<Object>	pouDeclarations:		<Object>	rows:		<Object>	selectedIndex:		<Object>identifier	- xxxxxmorphRows	- xxxxxpouDeclarations	- xxxxxrows	- xxxxxselectedIndex	- xxxxx!!PLC_Grid methodsFor: 'initialize-release' stamp: 'EricPernia 11/18/2013 06:34'!initialize	"comment stating purpose of message"	super initialize. "Siempre hay que hacerlo en una subclase de MORPH"		rows := OrderedCollection new.	selectedIndex := 1.			"Cambio el tamño de la grilla"	self extent: 732@195.	"Cambio el color de la grilla"	self color: PLC_GraphicElementProperties uniqueInstance rowColorSelected.	"Cambio la posición de la grilla"	self position: 0@0.	! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 20:54'!cellExtentCategory	"El tamaño de Celda de la columna Categoria"	^ 108@23! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 02:43'!cellExtentDescription	"El tamaño de Celda de la columna Descripcion"	^ 363@23! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 21:33'!cellExtentInitialValue	"El tamaño de Celda de la columna Valor Inicial"	^ 99@23! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 20:53'!cellExtentName	"El tamaño de Celda de la columna Name"	^ 98@23! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 20:53'!cellExtentType	"El tamaño de Celda de la columna Tipo de Datos"	^ 56@23! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 03:00'!colNumberFor: aMorph	"Devuelve numero de columna donde este ubicado el morph"	self morphRows do: [ :col |		(col includes: aMorph)			ifTrue: [				^ col indexOf: aMorph				 ].		].		^ 1.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 02:37'!colPositions	"Es una OC con las posiciones de columnas"	| colExt |	colExt := OrderedCollection new.		colExt add: 0.			colExt add: 		self cellExtentCategory x + 1.			colExt add: 		self cellExtentCategory x 		+ self cellExtentName x + 2.			colExt add: 		self cellExtentCategory x 		+ self cellExtentName x		+ self cellExtentType x + 3.			colExt add: 		self cellExtentCategory x 		+ self cellExtentName x		+ self cellExtentType x 		+ self cellExtentInitialValue x +4.	^ colExt.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 22:35'!colSize	"Devuelve la cantidad de columnas"	^ self rows first size.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 21:11'!colWidths	"Es una OC con los anchos de columnas"	| colExt |	colExt := OrderedCollection new.		colExt add: self cellExtentCategory x.	colExt add: self cellExtentName x.	colExt add: self cellExtentType x.	colExt add: self cellExtentInitialValue x.	colExt add: self cellExtentDescription x.	^ colExt.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 02:52'!createRowsMorphs	"Fila de titulos. Es una OC con los titulos de izquierda a derecha"	| cellMorph morphCol |		morphRows := OrderedCollection new.			morphCol := OrderedCollection new.			( 1 to: self rowSize ) do: [ :rowIndex |				( 1 to: self colSize ) do: [ :colIndex |						cellMorph := PLC_CellMorph newWithText: ( self nameAt: rowIndex at: colIndex ).						cellMorph extent: ( self colWidths at: colIndex ) @ self rowHeight.			cellMorph color: PLC_GraphicElementProperties uniqueInstance rowColorHeader.			cellMorph centerAlign.			cellMorph position: ( self position x + 2 + self colPositions at: colIndex ) 					@ ( self position y + 2 + ( self rowHeight * (rowIndex ) ) + rowIndex ).					cellMorph changed.					cellMorph extentChanged.								morphCol add: cellMorph.						"Lo agrego de submorph"			self addMorph: cellMorph.			"Lo agrego al diccionario elementos"			self elements at: cellMorph put: ( self nameAt: rowIndex at: colIndex ).				"Lo agrego a la lista de seleccionados y le doy el foco del teclado"			self selectedAndKeyboardFocus: cellMorph.										].					morphRows add: morphCol.			morphCol := OrderedCollection new.						].	self extent: ( self extent x @ 		(rows size + 4 + (rows size + 1 * self rowHeight) ) 		).! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 02:50'!createTitleRowMorphs	"Fila de titulos. Es una OC con los titulos de izquierda a derecha"	| titleMorph |		( 1 to: self titleRowNames size ) do: [ :index |		index.				titleMorph := PLC_TitleMorph new.		titleMorph extent: ( self colWidths at: index ) @ self rowHeight ;			backgroundColor: PLC_GraphicElementProperties uniqueInstance rowColorHeader;			backgroundBorderWidth: 1;			leftMargin: 0;			emphasis: 0;			text: ( self titleRowNames  at: index );			centerAlign;			changed;			position: ( self position x + self colPositions at: index ) @ self position y + 2.			"Lo agrego de submorph"		self addMorph: titleMorph.		"Lo agrego al diccionario elementos"		self elements at: titleMorph put: ( self titleRowNames  at: index ).			"Lo agrego a la lista de seleccionados y le doy el foco del teclado"		self selectedAndKeyboardFocus: titleMorph.				].! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 02:00'!morphAt: rowNumber at: colNumber	"Devuelve el morph de la celda ubicada en la fila: rowNumber columna: colNumber"	^ ( self morphRows at: rowNumber ) at: colNumber.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 02:02'!morphsAt: rowNumber	"Devuelve una coleccion de morphs de la fila: rowNumber"	^ ( self morphRows at: rowNumber ).! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 22:32'!nameAt: rowNumber at: colNumber	"Devuelve el texto que va en la celda ubicada en la fila: rowNumber columna: colNumber"	^ ( self rows at: rowNumber ) at: colNumber.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 03:01'!positionNumberFor: aMorph	"Devuelve numero de fila y columna donde este ubicado el morph"	^ (self rowNumberFor: aMorph) @ (self colNumberFor: aMorph)! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 21:10'!rowHeight	"Devuelve el alto de las filas"	^ 23.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/18/2013 02:24'!rowNumberFor: aMorph	"Devuelve numero de fila donde este ubicado el morph"	self morphRows do: [ :col |		(col includes: aMorph)			ifTrue: [				^ self morphRows indexOf: col				 ].		].		^ 1.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 22:36'!rowSize	"Devuelve la cantidad de filas"	^ self rows size.! !!PLC_Grid methodsFor: 'cell' stamp: 'EricPernia 11/17/2013 20:59'!titleRowNames	"Fila de titulos. Es una OC con los titulos de izquierda a derecha"	| titlesRowOC |	titlesRowOC := OrderedCollection new.		titlesRowOC add: 'Categoría'.	titlesRowOC add: 'Nombre'.	titlesRowOC add: 'Tipo'.	titlesRowOC add: 'Valor Inicial'.	titlesRowOC add: 'Descripción'.	^ titlesRowOC.! !!PLC_Grid methodsFor: 'loop' stamp: 'EricPernia 11/18/2013 06:33'!leftClick: anEvent	"Manejador del evento Click con boton izquiedo del mouse"	"(click) sent when the mouse button goes up within doubleClickTime."			| submorphUnderCursor rowNumber |				anEvent hand newKeyboardFocus: self. "Le doy al Network Morph el foco del teclado."	self gotKeyboardFocus.	submorphUnderCursor := self submorphUnderCursor: anEvent.		"self lostKeyboardFocus."	submorphUnderCursor		ifNil: [			self unselectAll.	 "Pasa todos a la lista de deseleccionados y actualiza los estados de los elementos graficos."								]				ifNotNil: [			self unselectAll.	 "Pasa todos a la lista de deseleccionados y actualiza los estados de los elementos graficos."			rowNumber := self rowNumberFor: submorphUnderCursor.						self selectedAndKeyboardFocus: submorphUnderCursor.								(self morphsAt: rowNumber) do: [ :each |				self addSelectedAndKeyboardFocus: each 				].								self selectedIndex: rowNumber.								].			self changed.! !!PLC_Grid methodsFor: 'loop' stamp: 'EricPernia 11/18/2013 06:37'!refresh	"Regresco la vista"			super refresh.		"Elimino sus OC de celdas morphs"	self morphRows: nil.		"Creo las celdas editables Morphs"	self createTitleRowMorphs.	self createRowsMorphs.		"Selecciono la ultima fila que había sido seleccionada"	self unselectAll.	self selectedAndKeyboardFocus: (self morphsAt: selectedIndex) first. 	(self morphsAt: selectedIndex) do: [ :each |		self addSelectedAndKeyboardFocus: each 		].	! !!PLC_Grid methodsFor: 'loop' stamp: 'EricPernia 11/18/2013 06:29'!textChangedIn: aPLC_CellMorph by: aString	"Cambió el texto del morph aPLC_EditaleTagMorph por el del string aString"		"Le cambia el texto. No hace falta refrescar toda la grilla"	"aPLC_CellMorph text: aString."		"	Transcript show: (self positionNumberFor: aPLC_CellMorph) asString , ''."		"Le envio un punto (fila@columna) y el texto al controlador para que modifique el modelo"	self editor 		textChangedInView: (self positionNumberFor: aPLC_CellMorph) 		by: aString.! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 05:15'!identifier		^ identifier! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 05:15'!identifier: anObject		identifier := anObject! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 01:59'!morphRows		^ morphRows! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 01:59'!morphRows: anObject		morphRows := anObject! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 20:49'!pouDeclarations		^ pouDeclarations! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 20:49'!pouDeclarations: anObject		pouDeclarations := anObject! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 20:46'!rows		^ rows! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 20:46'!rows: anObject		rows := anObject! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 20:46'!selectedIndex		^ selectedIndex! !!PLC_Grid methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 20:46'!selectedIndex: anObject		selectedIndex := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Grid class	instanceVariableNames: ''!!PLC_Grid class methodsFor: 'initialize-release' stamp: 'EricPernia 11/18/2013 01:33'!newWithRows: ro	"Nuevo con ciertas filas, que adentro tienen columnas"	| grid |		grid := self new.	grid rows: ro.		"Regresco la vista"	grid refresh.				^ grid.! !