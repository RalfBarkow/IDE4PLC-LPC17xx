"Copyright © 2012-2014 Eric Nicolás Pernia.This file is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>."Object subclass: #PLC_POUBody	instanceVariableNames: 'networks pou'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_POUBody commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_POUBody is xxxxxxxxx.Instance Variables	networks:		<Object>	pou:		<Object>networks	- xxxxxpou	- xxxxx!!PLC_POUBody methodsFor: 'initialize-release' stamp: 'EricPernia 9/3/2013 16:19'!initialize.	"Inicializo el programa Ladder."	self networks: OrderedCollection new.	self addNetwork.! !!PLC_POUBody methodsFor: 'accessing' stamp: 'EricPernia 9/3/2013 16:19'!networks	^ networks! !!PLC_POUBody methodsFor: 'accessing' stamp: 'EricPernia 9/3/2013 16:19'!networks: anObject	networks := anObject! !!PLC_POUBody methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 17:42'!pou	^ pou! !!PLC_POUBody methodsFor: 'accessing' stamp: 'EricPernia 11/18/2013 17:42'!pou: anObject	pou := anObject! !!PLC_POUBody methodsFor: 'add-remove Networks' stamp: 'EricPernia 11/17/2013 17:27'!removeNetwork: aNetworkView	"Remueve un nuevo Network de Bloques Conectables."	self networks 		remove: aNetworkView ladderController ladderNetwork.! !!PLC_POUBody methodsFor: 'test' stamp: 'EricPernia 11/15/2013 02:26'!isUserDefined	"Responde True si es un cuerpo de pou definido por el usuario. si es estandar responde false"	^ true! !!PLC_POUBody methodsFor: 'test' stamp: 'EricPernia 11/17/2013 16:14'!language	"Devuelve el lenguaje del cuerpo de POU"	^ ''! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_POUBody class	instanceVariableNames: ''!!PLC_POUBody class methodsFor: 'instance creation' stamp: 'EricPernia 11/18/2013 17:36'!newWithPOU: aPOU	"comment stating purpose of message"	| body |		body := self new.		body pou: aPOU.		^ body.! !PLC_POUBody subclass: #PLC_StandardBody	instanceVariableNames: 'cCode calledPOUs'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_StandardBody commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_StandardBody is xxxxxxxxx.Instance Variables	cCode:		<Object>	calledPOUs:		<Object>cCode	- xxxxxcalledPOUs	- xxxxx!!PLC_StandardBody methodsFor: 'compilation' stamp: 'EricPernia 11/15/2013 01:34'!generateCodeIn: aProgramAccumulator	"Compila su programa a objetos que lo forman. Estos pueden dar su código C o IL."	"Este cuerpo de POU representa el Cuerpo de POU de las funciones estándar que ya vienen compiladas.	Agrega una instrucción IL que en IL genera, ''Código no mostrado'' y en C devuelve todo el codigo"	| instruction |		instruction := PLC_StandarBody_Instruction new.		instruction cCode: self cCode.			instruction modifiers add: PLC_IL_Modifiers NullModifier. 	aProgramAccumulator add: instruction.		! !!PLC_StandardBody methodsFor: 'accessing' stamp: 'EricPernia 11/15/2013 01:27'!addNetwork	"Añade un nuevo Network de Bloques Conectables programa Ladder."	"No hace nada al ser estandar"! !!PLC_StandardBody methodsFor: 'accessing' stamp: 'EricPernia 11/14/2013 15:38'!cCode		^ cCode! !!PLC_StandardBody methodsFor: 'accessing' stamp: 'EricPernia 11/14/2013 15:38'!cCode: anObject		cCode := anObject! !!PLC_StandardBody methodsFor: 'accessing' stamp: 'EricPernia 11/15/2013 16:55'!calledPOUs		^ calledPOUs! !!PLC_StandardBody methodsFor: 'accessing' stamp: 'EricPernia 11/15/2013 16:55'!calledPOUs: anObject		calledPOUs := anObject! !!PLC_StandardBody methodsFor: 'test' stamp: 'EricPernia 11/15/2013 02:21'!isUserDefined	"Responde True si es un cuerpo de pou definido por el usuario. si es estandar responde false"	^ false! !!PLC_StandardBody methodsFor: 'called POUs' stamp: 'EricPernia 11/15/2013 16:56'!addCalledPOUsIn: aCalledPOU	"Añade sus declaraciones de pou F y FB que llame en sus networks.		LO USAN LOS TIMERS Y CONTADORES PARA AGREGAR SU DETECCIÓN DE FLANCO"		"Añado las declaraciones de Bloques de Funcion estandar"	aCalledPOU addStandardFunctionBlocks: self calledPOUs.		^ aCalledPOU.! !Object subclass: #PLC_ProgramAccumulator_POU	instanceVariableNames: 'compilerDataTypesDecls compilerVarDecls compiledBody'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_ProgramAccumulator_POU commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_ProgramAccumulator_POU is xxxxxxxxx.Instance Variables	compiledBody:		<Object>	compilerDataTypesDecls:		<Object>	compilerVarDecls:		<Object>compiledBody	- xxxxxcompilerDataTypesDecls	- xxxxxcompilerVarDecls	- xxxxx!!PLC_ProgramAccumulator_POU methodsFor: 'initialize-release' stamp: 'EricPernia 11/6/2013 16:54'!initialize	"Inicializo las colecciones de objetos de programa"	"Declaraciones de tipos de datos typeDef"	self compilerDataTypesDecls: PLC_Objects new.		"Declaraciones de variables"	self compilerVarDecls: PLC_VariableCategoryDecl tempVarDecls.		"Cuerpo de programa"	self compiledBody: PLC_Objects new.	! !!PLC_ProgramAccumulator_POU methodsFor: 'accessing' stamp: 'EricPernia 9/7/2013 04:41'!compiledBody		^ compiledBody! !!PLC_ProgramAccumulator_POU methodsFor: 'accessing' stamp: 'EricPernia 9/7/2013 04:41'!compiledBody: anObject		compiledBody := anObject! !!PLC_ProgramAccumulator_POU methodsFor: 'accessing' stamp: 'EricPernia 5/30/2013 18:53'!compilerDataTypesDecls	^ compilerDataTypesDecls! !!PLC_ProgramAccumulator_POU methodsFor: 'accessing' stamp: 'EricPernia 5/30/2013 18:53'!compilerDataTypesDecls: anObject	compilerDataTypesDecls := anObject! !!PLC_ProgramAccumulator_POU methodsFor: 'accessing' stamp: 'EricPernia 5/30/2013 18:53'!compilerVarDecls	^ compilerVarDecls! !!PLC_ProgramAccumulator_POU methodsFor: 'accessing' stamp: 'EricPernia 5/30/2013 18:53'!compilerVarDecls: anObject	compilerVarDecls := anObject! !!PLC_ProgramAccumulator_POU methodsFor: 'add' stamp: 'EricPernia 9/7/2013 04:50'!add: anObject	"Agrega a su OC compiledBody un objeto.	Este mensaje lo usan los elementos de programa gráfico 	para insetar su lista de elementos IL generados."	self compiledBody add: anObject.! !!PLC_ProgramAccumulator_POU methodsFor: 'add' stamp: 'EricPernia 9/7/2013 06:55'!addDataTypeDecl: anObject 	"Agrega a su OC compilcompilerDataTypesDecls un objeto.	Este mensaje lo usan los elementos de programa gráfico 	VL y llamado a F o FB para insetar sus declaraciones de 	tipos de datos generados, por ejemplo para variables cableadas."	self compilerDataTypesDecls add: anObject.! !!PLC_ProgramAccumulator_POU methodsFor: 'add' stamp: 'EricPernia 9/7/2013 06:55'!addVarDecl: anObject 	"Agrega a su OC compilcompilerVarDecls un objeto.	Este mensaje lo usan los elementos de programa gráfico 	VL y llamado a F o FB para insetar sus declaraciones de 	variables generadas, por ejemplo para variables struct 	cableadas."	self compilerVarDecls add: anObject.! !PLC_POUBody subclass: #PLC_LadderBody	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_LadderBody commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_LadderBody is xxxxxxxxx.Instance Variables!!PLC_LadderBody methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 15:02'!generateCodeIn: aProgramAccumulator	"Compila su programa a objetos que lo forman. Estos pueden dar su código C o IL."	self networks do: [ :each | 		each generateCodeIn: aProgramAccumulator.		].! !!PLC_LadderBody methodsFor: 'add-remove Networks' stamp: 'EricPernia 11/18/2013 17:34'!addNetwork	"Añade un nuevo Network de Bloques Conectables."	| net |		net := PLC_LadderNetwork new.	net pouBody: self.	self networks 		add: net.			! !!PLC_LadderBody methodsFor: 'called POUs' stamp: 'EricPernia 11/15/2013 16:47'!addCalledPOUsIn: aCalledPOU	"Añade sus declaraciones de pou F y FB que llame en sus networks."		self networks do: [ :each |				"Añado las declaraciones de Funciones definidas por el usuario"		aCalledPOU addUserFunctions:  each calledUserFunctions.				"Añado las declaraciones de Funciones estandar"		aCalledPOU addStandardFunctions:  each calledStandardFunctions.				"Añado las declaraciones de Bloques de Funcion definidos por el usuario"		aCalledPOU addUserFunctionBlocks:  each calledUserFunctionBlocks.						"Añado las declaraciones de Bloques de Funcion estandar"		aCalledPOU addStandardFunctionBlocks:  each calledStandardFunctionBlocks.		 ].		^ aCalledPOU.! !!PLC_LadderBody methodsFor: 'test' stamp: 'EricPernia 11/17/2013 16:13'!language	"Devuelve el lenguaje del cuerpo de POU"	^ 'LADDER DIAGRAM'! !Object subclass: #PLC_POU_Declarations	instanceVariableNames: 'pouDecl userDataTypesDecls userVarDecls funInstVarDecls'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_POU_Declarations commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_POU_Declarations is xxxxxxxxx.Instance Variables	funInstVarDecls:		<Object>	pouDecl:		<Object>	userDataTypesDecls:		<Object>	userVarDecls:		<Object>funInstVarDecls	- xxxxxpouDecl	- xxxxxuserDataTypesDecls	- xxxxxuserVarDecls	- xxxxx!!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/19/2013 04:57'!funInstVarDecls		^ funInstVarDecls! !!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/19/2013 04:57'!funInstVarDecls: anObject		funInstVarDecls := anObject! !!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 6/20/2013 17:06'!pouDecl		^ pouDecl! !!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 6/20/2013 17:06'!pouDecl: anObject		pouDecl := anObject! !!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 6/8/2013 15:21'!userDataTypesDecls	^ userDataTypesDecls! !!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 6/8/2013 15:21'!userDataTypesDecls: anObject	userDataTypesDecls := anObject! !!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 6/8/2013 14:40'!userVarDecls		^ userVarDecls! !!PLC_POU_Declarations methodsFor: 'accessing' stamp: 'EricPernia 6/8/2013 14:40'!userVarDecls: anObject		userVarDecls := anObject! !!PLC_POU_Declarations methodsFor: 'initialize-release' stamp: 'EricPernia 11/19/2013 05:01'!initialize	"Inicializa las Colecciones de declaraciones de una POU"	"Declaraciones de Tipos de Datos"	userDataTypesDecls := OrderedCollection new.		"Declaraciones de Variables"	userVarDecls := OrderedCollection new.		"PARCHEEEE DECLARCIONES OCULTAS DE INSTANCIAS DE F"	funInstVarDecls := PLC_VariableCategoryDecl funInstVarDecls.! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 20:07'!constantVarDecls	"Devuelve sus declaraciones de variables Internas de valor Constante"	^ self userVarDecls at: 5.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclstempVarDeclsexternVarDecls"! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 20:15'!externVarDecls	"Devuelve sus declaraciones de variables Internas"	^ self userVarDecls at: 7.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclstempVarDeclsexternVarDecls"! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 20:07'!inOutVarDecls	"Devuelve sus declaraciones de variables de Entrada-Salida"	^ self userVarDecls at: 3.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclstempVarDeclsexternVarDecls"! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 20:07'!inputVarDecls	"Devuelve sus declaraciones de variables de Entrada"	^ self userVarDecls at: 1.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclstempVarDeclsexternVarDecls"! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 20:07'!outputVarDecls	"Devuelve sus declaraciones de variables de Salida"	^ self userVarDecls at: 2.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclstempVarDeclsexternVarDecls"! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/16/2013 13:29'!returnVarDecl	"Devuelve su declaracion de variables de Return"	^ self userVarDecls at: 6.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclsreturnVarDecl"! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 20:07'!tempVarDecls	"Devuelve sus declaraciones de variables Internas Temporales"	^ self userVarDecls at: 6.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclstempVarDeclsexternVarDecls"! !!PLC_POU_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 20:07'!varDecls	"Devuelve sus declaraciones de variables Internas"	^ self userVarDecls at: 4.	"inputVarDeclsoutputVarDeclsinOutVarDeclsvarDeclsconstantVarDeclstempVarDeclsexternVarDecls"! !!PLC_POU_Declarations methodsFor: 'instance' stamp: 'EricPernia 11/19/2013 04:58'!structureDeclaration	"Declaracion de tipo de dato estructurado."	| struct |	struct := PLC_StructureDecl 		newWithIdentifier: self structureDeclarationIdentifier.	"AÑADO LAS VARIABLES A LA ESTRUCTURA"	"Variables de Entrada"	self inputVarDecls do: [ :each |		struct add: each.		].		"Variables de Entrada-Salida"	self inOutVarDecls do: [ :each |		struct add: each.		].		"Variables de Salida"	self outputVarDecls do: [ :each |		struct add: each.		].		"Variables Internas"	self varDecls do: [ :each |		struct add: each.		].		self funInstVarDecls do: [ :each |		struct add: each.		].	 		^ struct.! !!PLC_POU_Declarations methodsFor: 'instance' stamp: 'EricPernia 6/22/2013 03:27'!structureDeclarationIdentifier	"Identificador de tipo de dato estructurado."	^ 'Struct_' , self pouDecl typedIdentifier.! !!PLC_POU_Declarations methodsFor: 'instance' stamp: 'EricPernia 6/21/2013 04:52'!typeDeclaration	"Declaracion de tipo de dato derivado."	| type |	type := PLC_TypeDecl 		newWithDataType: self structureDeclaration		andIdentifier: self typeDeclarationIdentifier.	^ type.! !!PLC_POU_Declarations methodsFor: 'instance' stamp: 'EricPernia 6/21/2013 04:52'!typeDeclarationIdentifier	"Identificador de tipo de dato estructurado."	^ 'PLC_' , self pouDecl pouTypeAcronym , '_' , self structureDeclarationIdentifier.! !!PLC_POU_Declarations methodsFor: 'find' stamp: 'EricPernia 11/18/2013 21:09'!includeVarDeclWithIdentifier: aVariableIdentifier	"Busca si tiene en alguna de sus declaraciones una delaracion 	de variable con el identificador aVariableIdentifier"	self userVarDecls do: [ :each |		( each includeVarDeclWithIdentifier: aVariableIdentifier )			ifNotNil: [ ^ each includeVarDeclWithIdentifier: aVariableIdentifier ].		 ].		^ nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_POU_Declarations class	instanceVariableNames: ''!!PLC_POU_Declarations class methodsFor: 'instance creation' stamp: 'EricPernia 6/20/2013 17:13'!functionBlockDeclarationsWithPOUDeclaration: aPOUDecl	"Devuelve una nueva instancia con declaraciones de Bloque de Funcion"	| decls |	decls := self newWithUserVarDecls.		"Declaraciones de Tipos de Datos"	"decls compilerDataTypesDecls.	decls userDataTypesDecls."		"Declaraciones de Variables"	"decls compilerVarDecls."	decls userVarDecls add: PLC_VariableCategoryDecl tempVarDecls.		decls pouDecl: aPOUDecl.		^ decls.! !!PLC_POU_Declarations class methodsFor: 'instance creation' stamp: 'EricPernia 11/16/2013 13:30'!functionDeclarationsWithPOUDeclaration: aPOUDecl	"Devuelve una nueva instancia con declaraciones de Funcion"	| decls |	decls := self newWithUserVarDecls.		"Declaraciones de Variables"	decls userVarDecls add: PLC_VariableCategoryDecl returnVarDecl.		decls pouDecl: aPOUDecl.		^ decls.! !!PLC_POU_Declarations class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 04:21'!newWithUserVarDecls	"Devuelve una nueva instancia con declaraciones"		| decls |	decls := self new.		"Declaraciones de Tipos de Datos"	"decls compilerDataTypesDecls.	decls userDataTypesDecls."		"Declaraciones de Variables"		decls userVarDecls add: PLC_VariableCategoryDecl inputVarDecls.	decls userVarDecls add: PLC_VariableCategoryDecl outputVarDecls.	decls userVarDecls add: PLC_VariableCategoryDecl inOutVarDecls.	decls userVarDecls add: PLC_VariableCategoryDecl varDecls.	decls userVarDecls add: PLC_VariableCategoryDecl constantVarDecls.	^ decls.! !!PLC_POU_Declarations class methodsFor: 'instance creation' stamp: 'EricPernia 11/5/2013 20:11'!programDeclarationsWithPOUDeclaration: aPOUDecl	"Devuelve una nueva instancia con declaraciones de programa"	| decls |	decls := self newWithUserVarDecls.		"Declaraciones de Tipos de Datos"	"decls userDataTypesDecls."		"Declaraciones de Variables"	decls userVarDecls add: PLC_VariableCategoryDecl tempVarDecls.	decls userVarDecls add: PLC_VariableCategoryDecl externVarDecls.		decls pouDecl: aPOUDecl.		^ decls.! !PLC_POU_Declarations subclass: #PLC_Function_Declarations	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_Function_Declarations commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Function_Declarations is xxxxxxxxx.Instance Variables!!PLC_Function_Declarations methodsFor: 'instance' stamp: 'EricPernia 11/16/2013 13:48'!structureDeclaration	"Declaracion de tipo de dato estructurado."	| struct |	struct := PLC_StructureDecl 		newWithIdentifier: self structureDeclarationIdentifier.	"AÑADO LAS VARIABLES A LA ESTRUCTURA"	"Variables de Entrada"	self inputVarDecls do: [ :each |		struct add: each.		].		"Variables de Entrada-Salida"	self inOutVarDecls do: [ :each |		struct add: each.		].		"Variables de Salida"	self outputVarDecls do: [ :each |		struct add: each.		].		"Variables Internas"	self varDecls do: [ :each |		struct add: each.		].		"Variable de Return"	self returnVarDecl do: [ :each |		struct add: each.		].	 		^ struct.! !PLC_ClassWithIdentifier subclass: #PLC_POU	instanceVariableNames: 'pouBody declarations dataType'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_POU commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_POU is xxxxxxxxx.Instance Variables	dataType:		<Object>	declarations:		<Object>	pouBody:		<Object>dataType	- xxxxxdeclarations	- xxxxxpouBody	- xxxxx!!PLC_POU methodsFor: 'accessing' stamp: 'EricPernia 6/22/2013 03:22'!dataType		^ dataType! !!PLC_POU methodsFor: 'accessing' stamp: 'EricPernia 6/22/2013 03:22'!dataType: anObject		dataType := anObject! !!PLC_POU methodsFor: 'accessing' stamp: 'EricPernia 6/8/2013 04:07'!declarations	^ declarations! !!PLC_POU methodsFor: 'accessing' stamp: 'EricPernia 6/8/2013 04:07'!declarations: anObject	declarations := anObject! !!PLC_POU methodsFor: 'accessing' stamp: 'EricPernia 6/5/2013 18:21'!pouBody	^ pouBody! !!PLC_POU methodsFor: 'accessing' stamp: 'EricPernia 6/5/2013 18:21'!pouBody: anObject	pouBody := anObject! !!PLC_POU methodsFor: 'connectableBlocks' stamp: 'EricPernia 6/8/2013 03:37'!connectableBlockInputs	"Cantidad de entradas para el bloque conectable."	^ self inputVarDecls size + self inOutVarDecls size.! !!PLC_POU methodsFor: 'connectableBlocks' stamp: 'EricPernia 6/5/2013 18:22'!connectableBlockOutputs	"Cantidad de salidas para el bloque conectable."	^ self outputVarDecls size + self inOutVarDecls size.! !!PLC_POU methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 16:23'!cCompilePrototype	"Prototipo de Función en C que implementa la POU		Ejemplo:	void ProgEj ( PLC_P_Struct_ProgEj *);"		^ '	void ' , self cPOUName , '( ' , self declarations typeDeclarationIdentifier , ' * );'! !!PLC_POU methodsFor: 'compilation' stamp: 'EricPernia 6/22/2013 03:44'!cPOUName	"Devuelve el nombre en C de la POU"		"Ejemplo: 		PLC_F_ADD_INT"		^ 'PLC_' , self pouTypeAcronym , '_' , self typedIdentifier.! !!PLC_POU methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 19:59'!generateCode	"Genera el acumulador de programa y se lo pasa a sus declaraciones de POU y Cuerpo de POU para que lo llenen"		| progAcc |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.	"Le envio la petición al Cuerpo de POU de que se compile en el acumulador"	self pouBody generateCodeIn: progAcc.		^ progAcc.	! !!PLC_POU methodsFor: 'instance' stamp: 'EricPernia 11/6/2013 12:32'!instanceDecl	"Devuelve una nueva declaracion de variable de instancia de la declaración de Programa o Bloque de Función."	^ self instanceDeclWithIdentifier: nil.! !!PLC_POU methodsFor: 'instance' stamp: 'EricPernia 11/19/2013 03:09'!instanceDeclForForFBWithIdentifier: anIdentifier	"Devuelve una nueva variable de instancia de la declaración de Programa o Bloque de Función."	| instance |		anIdentifier 		ifNil: [			instance := PLC_SymbolicVariableDecl 				newWithDataType: self typeDeclaration 				andInitialValue: nil				andIdentifier: self typedIdentifier , '_VAR'.			]		ifNotNil: [			instance := PLC_SymbolicVariableDecl 				newWithDataType: self typeDeclaration 				andInitialValue: nil				andIdentifier: anIdentifier.			].	^ instance.! !!PLC_POU methodsFor: 'instance' stamp: 'EricPernia 11/7/2013 14:18'!instanceDeclWithIdentifier: anIdentifier	"Devuelve una nueva variable de instancia de la declaración de Programa o Bloque de Función."	| instance |		anIdentifier 		ifNil: [			instance := PLC_InstanceVariableDecl				newWithDataType: self typeDeclaration 				andInitialValue: nil				andIdentifier: self typedIdentifier , '_VAR'.			]		ifNotNil: [			instance := PLC_InstanceVariableDecl 				newWithDataType: self typeDeclaration 				andInitialValue: nil				andIdentifier: anIdentifier.			].	^ instance.! !!PLC_POU methodsFor: 'instance' stamp: 'EricPernia 6/21/2013 04:01'!structureDeclaration	"Declaracion de tipo de dato estructurado."		^ self declarations structureDeclaration.! !!PLC_POU methodsFor: 'instance' stamp: 'EricPernia 6/21/2013 04:31'!typeDeclaration	"Declaracion de tipo de dato derivado."		^ self declarations typeDeclaration.! !!PLC_POU methodsFor: 'typed identifier' stamp: 'EricPernia 6/22/2013 03:29'!typedIdentifier	"Devuelve su identificador con tipo de datos.		Ejemplo: 			ADD_INT	"		self dataType 		ifNil: [ 			^ self identifier.			] 		ifNotNil: [ 			^ self identifier , '_' , self dataType ilCompile.			].! !!PLC_POU methodsFor: 'called POUs' stamp: 'EricPernia 11/15/2013 16:57'!addCalledPOUsIn: aCalledPOU	"Añade sus declaraciones de pou F y FB que llame en su cuerpo"	^ self pouBody addCalledPOUsIn: aCalledPOU.! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 12:56'!addENDeclaration	"Añade la declaración de variable BOOLEANAde entrada EN"	self inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: true 			andIdentifier: 'EN' 		).			! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 11/5/2013 12:56'!addENODeclaration	"Añade la declaración de variable BOOLEANA de salida ENO"	self outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil			andIdentifier: 'ENO' 		).! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 9/7/2013 04:29'!compilerVarDecls	"Devuelve sus declaraciones de variables internas declaradas por el compilador. 	Las conoce el object una vez que la POU fue compilada."	^ self object compilerVarDecls.! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 6/8/2013 17:00'!constantVarDecls	"Devuelve sus declaraciones de variables Internas de valor Constante"	^ self declarations constantVarDecls.! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 11/19/2013 04:55'!funInstVarDecls	"Devuelve sus declaraciones de variables Internas de instancias de Funciones. ES UN PARCHASOOO ESTA CATEGORIA"	^ self declarations funInstVarDecls.! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 6/8/2013 17:00'!inOutVarDecls	"Devuelve sus declaraciones de variables de Entrada-Salida"	^ self declarations inOutVarDecls.! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 6/8/2013 17:00'!inputVarDecls	"Devuelve sus declaraciones de variables de Entrada"	^ self declarations inputVarDecls.! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 6/8/2013 17:00'!outputVarDecls	"Devuelve sus declaraciones de variables de Salida"	^ self declarations outputVarDecls.! !!PLC_POU methodsFor: 'variable declarations' stamp: 'EricPernia 6/8/2013 17:00'!varDecls	"Devuelve sus declaraciones de variables Internas"	^ self declarations varDecls.! !!PLC_POU methodsFor: 'data types declarations' stamp: 'EricPernia 9/7/2013 04:31'!compilerDataTypesDecls	"Devuelve sus declaraciones de Tipos de datos declarados por el compilador	de lenguaje grafico.	Las conoce el object una vez que la POU fue compilada."	^ self object compilerDataTypesDecls.! !!PLC_POU methodsFor: 'data types declarations' stamp: 'EricPernia 6/8/2013 17:01'!userDataTypesDecls	"Devuelve sus declaraciones de Tipos de datos declarados por el usuario"	^ self declarations userDataTypesDecls.! !!PLC_POU methodsFor: 'data types declarations' stamp: 'EricPernia 9/7/2013 05:14'!userVarDecls	"Devuelve sus declaraciones de Variables hechas por el usuario"	^ self declarations userVarDecls.! !!PLC_POU methodsFor: 'parallel' stamp: 'EricPernia 9/13/2013 17:42'!acceptParallel	"Responde true si la POU acepta estar conectada en una rama paralela en Ladder.			Quiero agregar un elemento llamado a POU en la conexión ==		|	c1		 c2			b1	|-----|  |----------|  |-----+-----(  )------|	|				    |	|	c3			    |	|-----|  |---------==----+		|	"	"Se lo delega el llamado a esta declaraion de POU.	Responden True solo un par de Funciones (las de comparación)"		^ false.! !!PLC_POU methodsFor: 'test' stamp: 'EricPernia 11/15/2013 02:27'!isUserDefined	"Responde True si su cuerpo de pou definido por el usuario. si es estandar responde false"	^ self pouBody isUserDefined.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_POU class	instanceVariableNames: ''!!PLC_POU class methodsFor: 'instance creation' stamp: 'EricPernia 6/8/2013 04:15'!newWithName: anIdentifier 	"Nuevo con nombre"	| pou |		pou := self new.	pou identifier: anIdentifier.			^ pou.! !!PLC_POU class methodsFor: 'instance creation' stamp: 'EricPernia 6/22/2013 03:23'!newWithName: anIdentifier andDataType: aPLC_DataType	"Nuevo con nombre y tipo de datos"	| pou |		pou := self newWithName: anIdentifier.			pou dataType: aPLC_DataType.			^ pou.! !PLC_POU subclass: #PLC_FunctionBlock	instanceVariableNames: ''	classVariableNames: 'StdFunctionBlocks StdFunctionBlocksCreated UserFunctionBlocks'	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_FunctionBlock commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_FunctionBlock is xxxxxxxxx.Instance Variables!!PLC_FunctionBlock methodsFor: 'initialize-release' stamp: 'EricPernia 6/21/2013 04:22'!initialize.	"Inicializo la declaración de Bloque de Función."	super initialize.	"Declaraciones de Variables y Tipos de Datos"	self declarations: ( PLC_POU_Declarations functionBlockDeclarationsWithPOUDeclaration: self ).! !!PLC_FunctionBlock methodsFor: 'variable declarations' stamp: 'EricPernia 6/8/2013 17:01'!tempVarDecls	"Devuelve sus declaraciones de variables Internas Temporales"	^ self declarations tempVarDecls.! !!PLC_FunctionBlock methodsFor: 'POU type' stamp: 'EricPernia 6/21/2013 04:41'!pouType	"Devuelve el tipo de POU que es."	^ 'FUNCTION_BLOCK'! !!PLC_FunctionBlock methodsFor: 'POU type' stamp: 'EricPernia 6/21/2013 04:50'!pouTypeAcronym	"Devuelve las siglas del tipo de POU que es."	^ 'FB'! !!PLC_FunctionBlock methodsFor: 'compilation' stamp: 'EricPernia 11/18/2013 17:23'!cCompile	"Definiciónn de Función en C que implementa la POU.		Ejemplo:	void ProgEj ( PLC_P_Struct_ProgEj * pxPOU )	{		// Cuerpo de POU				PLC_IL_LD ( &( pxPOU -> Ent1 ), sizeof (pxPOU -> Ent1 ), BOOL , NullModifier ); // LD Ent1				PLC_IL_AND ( &( pxPOU -> Ent2 ), BOOL , NullModifier ); // AND Ent2				PLC_IL_ST ( &( pxPOU ->Sal), sizeof (pxPOU ->Sal), NullModifier ); // ST Sal	}."		| progAcc cCode |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.			"	LAS POU NO ADMITEN VAR_GLOBAL	y las F no tienen VAR_EXTERN, ni VAR_TEMP y pisan antes del cuerpo de POU las VAR 		Dentro de la estructura de instancia:		self declarations inputVarDecls	self declarations outputVarDecls	self declarations inOutVarDecls	self declarations varDecls		Dentro de la funcion de la POU en C:		self declarations constantVarDecls 		progAcc compilerDataTypesDecls cCompile.	progAcc compilerVarDecls cCompile.	progAcc compiledBody	 cCompile.	"		"Le envio la petición al Cuerpo de POU de que se compile en el acumulador"	self pouBody generateCodeIn: progAcc.		cCode := '	void ' , self cPOUName , '( ' , self declarations typeDeclarationIdentifier , ' *pxPOU )	{			// Declaraciones de Tipos de datos del compilador		'.			cCode := cCode , progAcc compilerDataTypesDecls cCompile , '			// Declaraciones de variables del compilador		'.			cCode := cCode , progAcc compilerVarDecls cCompile , '			// Declaraciones de variables del usuario		',		self declarations constantVarDecls cCompile ,	self declarations tempVarDecls cCompile.			"ACA FALTA QUE EN FUNCTION PISE CONCERO A LAS VAR INTERNAS PARAQUENOTENGA MEMORIA"		cCode := cCode , '			// Cuerpo de POU		',	progAcc compiledBody cCompile.			cCode := cCode, '		}'.		^ cCode.! !!PLC_FunctionBlock methodsFor: 'compilation' stamp: 'EricPernia 11/14/2013 15:43'!ilCompile	"Definición de POU en IL.		Ejemplo:	FUNCTION_BLOCK FBej			(* Declaraciones de POU *)			VAR_INPUT				Ent1 : BOOL ;				Ent2 : BOOL ;			END_VAR						VAR_OUTPUT				Sal : BOOL ;			END_VAR					(* Cuerpo de POU *)					LD Ent1			AND Ent2			ST Sal				END_FUNCTION_BLOCK		"		| progAcc ilCode |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.			"	LAS POU NO ADMITEN VAR_GLOBAL		Dentro de la estructura de instancia:		self declarations inputVarDecls	self declarations outputVarDecls	self declarations inOutVarDecls	self declarations varDecls		Dentro de la funcion de la POU en C:		self declarations constantVarDecls 	self declarations tempVarDecls 	self declarations externVarDecls 		progAcc compilerDataTypesDecls cCompile.	progAcc compilerVarDecls cCompile.	progAcc compiledBody	 cCompile.	"		"Le envio la petición al Cuerpo de POU de que se compile en el acumulador"	self pouBody generateCodeIn: progAcc.		ilCode := '	' , self pouType , ' ' , self identifier , '			 (* Declaraciones de Tipos de datos del compilador *)		'.			ilCode := ilCode , progAcc compilerDataTypesDecls ilCompile , '				 (* Declaraciones de variables del compilador *)		'.			ilCode := ilCode , progAcc compilerVarDecls ilCompile , '			 (* Declaraciones de variables del usuario *)		',	self declarations inputVarDecls ilCompile ,	self declarations outputVarDecls ilCompile ,	self declarations inOutVarDecls ilCompile ,	self declarations varDecls ilCompile ,	self declarations constantVarDecls ilCompile ,	self declarations tempVarDecls ilCompile .		ilCode := ilCode , '			 (* Cuerpo de POU *)		',	progAcc compiledBody ilCompile.			ilCode := ilCode, '				END_' , self pouType.		^ ilCode.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_FunctionBlock class	instanceVariableNames: ''!!PLC_FunctionBlock class methodsFor: 'class initialization' stamp: 'EricPernia 6/21/2013 20:28'!initialize 	"comment stating purpose of message"	super initialize.	StdFunctionBlocksCreated := false.! !!PLC_FunctionBlock class methodsFor: 'Std Counters' stamp: 'EricPernia 11/19/2013 07:06'!createCTDFunctionBlockDeclarationWithType: aDataType	"Crea y devuelve una Declaración del Bloque de Función estándar CTD_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'CTD'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'CD' 		).		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'LD' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'PV' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'Q' 		).				"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'CV' 		).							"Agrego una declaracion de variable interna persistente de instancia"	"( StdFunctionBlocks at: 'R_EDGE_BOOL' ) Obtengo la declaración de REDGE desde la biblioteca"	pouDecl varDecls add: ( 		( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL')			instanceDeclForForFBWithIdentifier: 'R_TRIG_IN'		).	"CUERPO DE LA POU"	"Es un cuerpo estandar"	pouDecl pouBody: PLC_StandardBody new.		"Agrego la POU que llama esta pou estandar en su interior"	pouDecl pouBody calledPOUs: ( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL').		pouDecl pouBody cCode: '			const PLC_INT PVmin = -32768; // Ver esto que esta medio confuso en el estandar,									  // le puse el minimo de PLC Int												// Utilización del FB instancia R_TRIG_IN.		// Lo que sigue implementa: CAL R_TRIG_IN(CLK:=CD, Q=>CD)		(pxPOU->R_TRIG_IN).CLK = pxPOU->CD;	// Completo los parametros VAR_INPUT de REDGE		PLC_FB_R_TRIG_BOOL( &(pxPOU->R_TRIG_IN) );	// Llamo a la función pasandole la estructura por referencia		pxPOU->CD = (pxPOU->R_TRIG_IN).Q;	// Grabo los parametros VAR_OUTPUT de REDGE a las variables													// a las cuales estan igualadas las VAR_OUTPUT de REDGE		if( pxPOU->LD )		{			pxPOU->CV = pxPOU->PV;		}		else		{			if( pxPOU->CD && (pxPOU->CV > PVmin) )			{				(pxPOU->CV)--;			}		}		pxPOU->Q = (pxPOU->CV <= 0);'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Counters' stamp: 'EricPernia 11/19/2013 07:07'!createCTUDFunctionBlockDeclarationWithType: aDataType	"Crea y devuelve una Declaración del Bloque de Función estándar CTUD_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'CTUD'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'CU' 		).		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'CD' 		).		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'R' 		).		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'LD' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'PV' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'QU' 		).				"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'QD' 		).				"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'CV' 		).							"Agrego una declaracion de variable interna persistente de instancia"	"( StdFunctionBlocks at: 'R_EDGE_BOOL' ) Obtengo la declaración de REDGE desde la biblioteca"	pouDecl varDecls add: ( 		( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL')			instanceDeclForForFBWithIdentifier: 'R_TRIG_IN1'		).							"Agrego una declaracion de variable interna persistente de instancia"	"( StdFunctionBlocks at: 'R_EDGE_BOOL' ) Obtengo la declaración de REDGE desde la biblioteca"	pouDecl varDecls add: ( 		( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL')			instanceDeclForForFBWithIdentifier: 'R_TRIG_IN2'		).	"CUERPO DE LA POU"	"Es un cuerpo estandar"	pouDecl pouBody: PLC_StandardBody new.		"Agrego la POU que llama esta pou estandar en su interior"	pouDecl pouBody calledPOUs: ( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL').			pouDecl pouBody cCode: '		const PLC_INT PVmax = 32767; // Ver esto que esta medio confuso en el estandar,									 // le puse el maximo de PLC Int		const PLC_INT PVmin = -32768; // Ver esto que esta medio confuso en el estandar,									  // le puse el minimo de PLC Int		(pxPOU->R_TRIG_IN1).CLK = pxPOU->CU;			PLC_FB_R_TRIG_BOOL( &(pxPOU->R_TRIG_IN1) );			pxPOU->CU = (pxPOU->R_TRIG_IN1).Q;			(pxPOU->R_TRIG_IN2).CLK = pxPOU->CD;			PLC_FB_R_TRIG_BOOL( &(pxPOU->R_TRIG_IN2) );			pxPOU->CD = (pxPOU->R_TRIG_IN2).Q;			if( pxPOU->R )		{			pxPOU->CV = 0;		}		else		{			if( pxPOU->LD )			{				pxPOU->CV = pxPOU->PV;			}			if( !!(pxPOU->CU && pxPOU->CD) )			{				if( pxPOU->CU && ( pxPOU->CV < PVmax) )				{					(pxPOU->CV)++;				}				else				{					if( pxPOU->CD && ( pxPOU->CV > PVmin) )					{						(pxPOU->CV)--;					}				}			}		}		pxPOU->QU = (pxPOU->CV >= pxPOU->PV);		pxPOU->QD = (pxPOU->CV <= 0);'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Counters' stamp: 'EricPernia 11/19/2013 07:07'!createCTUFunctionBlockDeclarationWithType: aDataType	"Crea y devuelve una Declaración del Bloque de Función estándar CTU_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'CTU'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'CU' 		).		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'R' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'PV' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'Q' 		).				"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'CV' 		).							"Agrego una declaracion de variable interna persistente de instancia"	"( StdFunctionBlocks at: 'R_EDGE_BOOL' ) Obtengo la declaración de REDGE desde la biblioteca"	pouDecl varDecls add: ( 		( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL')			instanceDeclForForFBWithIdentifier: 'R_TRIG_IN'		).	"CUERPO DE LA POU"	"Es un cuerpo estandar"	pouDecl pouBody: PLC_StandardBody new.		"Agrego la POU que llama esta pou estandar en su interior"	pouDecl pouBody calledPOUs: ( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL').		pouDecl pouBody cCode: '			const PLC_INT PVmax = 32767;			// Utilización del FB instancia R_TRIG_IN.		// Lo que sigue implementa: CAL R_TRIG_IN(CLK:=CU, Q=>CU)		(pxPOU->R_TRIG_IN).CLK = pxPOU->CU;	// Completo los parametros VAR_INPUT de REDGE		PLC_FB_R_TRIG_BOOL( &(pxPOU->R_TRIG_IN) );	// Llamo a la función pasandole la estructura por referencia		pxPOU->CU = (pxPOU->R_TRIG_IN).Q;	// Grabo los parametros VAR_OUTPUT de REDGE a las variables													// a las cuales estan igualadas las VAR_OUTPUT de REDGE		if( pxPOU->R )		{			pxPOU->CV = 0;		}		else		{			if( pxPOU->CU && (pxPOU->CV < PVmax) )			{				(pxPOU->CV)++;			}		}		pxPOU->Q = (pxPOU->CV >= pxPOU->PV);		'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Edge' stamp: 'EricPernia 11/18/2013 23:31'!createF_TRIGFunctionBlockDeclaration	"Crea y devuelve una Declaración del Bloque de Función estándar F_TRIG_BOOL"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'F_TRIG'		andDataType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'CLK' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'Q' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'M' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		pxPOU->Q = !!(pxPOU->CLK) && !!(pxPOU->M);		pxPOU->M = !!(pxPOU->CLK);'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Edge' stamp: 'EricPernia 11/18/2013 23:30'!createR_TRIGFunctionBlockDeclaration	"Crea y devuelve una Declaración del Bloque de Función estándar R_TRIG_BOOL"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'R_TRIG'		andDataType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'CLK' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'Q' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'M' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		pxPOU->Q = pxPOU->CLK && !!(pxPOU->M);		pxPOU->M = pxPOU->CLK;'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Biestable' stamp: 'EricPernia 11/18/2013 23:25'!createRSFunctionBlockDeclaration	"Crea y devuelve una Declaración del Bloque de Función estándar RS_BOOL"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'RS'		andDataType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'S' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'R1' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'Q1' 		).				"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		pxPOU->Q1 = !!(pxPOU->R1) && ( pxPOU->S || pxPOU->Q1 );'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Biestable' stamp: 'EricPernia 11/18/2013 23:24'!createSRFunctionBlockDeclaration	"Crea y devuelve una Declaración del Bloque de Función estándar SR_BOOL"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'SR'		andDataType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'S1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'R' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'Q1' 		).				"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		pxPOU->Q1 = pxPOU->S1 || ( !!(pxPOU->R) && pxPOU->Q1 );		// Ver si va ~ o !! para negar una variable booleana. Si va !! implementar como las de abajo.'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Timers' stamp: 'EricPernia 11/19/2013 03:57'!createTOFFunctionBlockDeclaration	"Crea y devuelve una Declaración del Bloque de Función estándar TOF_Time"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'TOF'		andDataType: PLC_DataType Time.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.			"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'IN' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'PT' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'Q' 		).				"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'ET' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'START' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'RUNNING' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'EDGE' 		).				"Agrego una declaracion de variable interna persistente de instancia"	"( StdFunctionBlocks at: 'R_EDGE_BOOL' ) Obtengo la declaración de REDGE desde la biblioteca"	pouDecl varDecls add: ( 		( PLC_FunctionBlock StdFunctionBlocks at: 'F_TRIG_BOOL')			instanceDeclForForFBWithIdentifier: 'F_TRIG_IN'		).	"CUERPO DE LA POU"	"Es un cuerpo estandar"	pouDecl pouBody: PLC_StandardBody new.		"Agrego la POU que llama esta pou estandar en su interior"	pouDecl pouBody calledPOUs: ( PLC_FunctionBlock StdFunctionBlocks at: 'F_TRIG_BOOL').			pouDecl pouBody cCode: '		// Utilización del FB instancia F_TRIG_IN.		// Lo que sigue implementa: CAL F_TRIG_IN(CLK:=IN, Q=>EDGE)		(pxPOU->F_TRIG_IN).CLK = pxPOU->IN;		// Completo los parametros VAR_INPUT de FEDGE		PLC_FB_F_TRIG_BOOL( &(pxPOU->F_TRIG_IN) );	// Llamo a la función pasandole la estructura por referencia		pxPOU->EDGE = (pxPOU->F_TRIG_IN).Q;	// Grabo los parametros VAR_OUTPUT de FEDGE a las variables														// a las cuales estan igualadas las VAR_OUTPUT de FEDGE		// Si la entrada IN es 1 , entonces Q = 1 y ET = 0		if ( pxPOU->IN ){			pxPOU->Q = true;			pxPOU->ET = 0;		}		// Si contando == 0 (no esta contando) y hay flanco descendente, arranca a contar		if ( pxPOU->EDGE && !!(pxPOU->RUNNING) ){			pxPOU->START = xTaskGetTickCount();	// Obtiene el tiempo inicial de ticks			pxPOU->RUNNING = true; 					// Comienza a contar el tiempo de pulso		}		// Si está contando		if ( pxPOU->RUNNING ){			pxPOU->ET = xTaskGetTickCount() - pxPOU->START; // Calcula el tiempo transcurrido ET			// Si ET >= PT entonces termina de contar y satura el valor de ET en PT			if ( (pxPOU->ET) >= (pxPOU->PT) ){				pxPOU->ET = pxPOU->PT;			// Satura el valor de ET en PT				pxPOU->RUNNING = false;			// Deja de Contar				pxPOU->Q = false; 					// Apaga la salida de pulso			}		}'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Timers' stamp: 'EricPernia 11/19/2013 03:56'!createTONFunctionBlockDeclaration	"Crea y devuelve una Declaración del Bloque de Función estándar TON_Time"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'TON'		andDataType: PLC_DataType Time.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'IN' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'PT' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'Q' 		).				"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'ET' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'START' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'RUNNING' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'EDGE' 		).				"Agrego una declaracion de variable interna persistente de instancia"	"( StdFunctionBlocks at: 'R_EDGE_BOOL' ) Obtengo la declaración de REDGE desde la biblioteca"	pouDecl varDecls add: ( 		( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL')			instanceDeclForForFBWithIdentifier: 'R_TRIG_IN'		).	"CUERPO DE LA POU"	"Es un cuerpo estandar"	pouDecl pouBody: PLC_StandardBody new.		"Agrego la POU que llama esta pou estandar en su interior"	pouDecl pouBody calledPOUs: ( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL').			pouDecl pouBody cCode: '		// Utilización del FB instancia R_TRIG_IN.		// Lo que sigue implementa: CAL R_TRIG_IN(CLK:=IN, Q=>EDGE)		(pxPOU->R_TRIG_IN).CLK = pxPOU->IN;	// Completo los parametros VAR_INPUT de REDGE		PLC_FB_R_TRIG_BOOL( &(pxPOU->R_TRIG_IN) );	// Llamo a la función pasandole la estructura por referencia		pxPOU->EDGE = (pxPOU->R_TRIG_IN).Q;	// Grabo los parametros VAR_OUTPUT de REDGE a las variables													// a las cuales estan igualadas las VAR_OUTPUT de REDGE		// Si hay flanco ascendente, arranca a contar		if ( pxPOU->EDGE ){			pxPOU->START = xTaskGetTickCount();	// Obtiene el tiempo inicial de ticks			pxPOU->RUNNING = true; 					// Comienza a contar el tiempo de pulso		}		// Si está contando		if ( pxPOU->RUNNING ){			pxPOU->ET = xTaskGetTickCount() - pxPOU->START; 	// Calcula el tiempo transcurrido ET			// Si ET >= PT entonces termina de contar y satura el valor de ET en PT			if ( (pxPOU->ET) >= (pxPOU->PT) ){				pxPOU->Q = true; 				// Enciende la salida de pulso				pxPOU->ET = pxPOU->PT;		// Satura el valor de ET en PT				pxPOU->RUNNING = false;		// Deja de Contar			}		}		// Si la entrada IN es 0 , entonces ET y Q quedan en 0		if ( !!(pxPOU->IN) ){			pxPOU->ET = 0;				// ET = 0			pxPOU->Q = false; 				// Apaga la salida de pulso			pxPOU->RUNNING = false;		// Deja de Contar		}'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'Std Timers' stamp: 'EricPernia 11/19/2013 03:56'!createTPFunctionBlockDeclaration	"Crea y devuelve una Declaración del Bloque de Función estándar TP_Time"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'TP'		andDataType: PLC_DataType Time.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunctionBlock: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'IN' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'PT' 		).					"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'Q' 		).				"Agrego una declaracion de variable de salida"	pouDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'ET' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: pouDecl dataType			andInitialValue: nil 			andIdentifier: 'START' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'RUNNING' 		).				"Agrego una declaracion de variable interna persistente"	pouDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'EDGE' 		).				"Agrego una declaracion de variable interna persistente de instancia"	"( StdFunctionBlocks at: 'R_EDGE_BOOL' ) Obtengo la declaración de REDGE desde la biblioteca"	pouDecl varDecls add: ( 		( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL')			instanceDeclForForFBWithIdentifier: 'R_TRIG_IN'		).	"CUERPO DE LA POU"	"Es un cuerpo estandar"	pouDecl pouBody: PLC_StandardBody new.		"Agrego la POU que llama esta pou estandar en su interior"	pouDecl pouBody calledPOUs: ( PLC_FunctionBlock StdFunctionBlocks at: 'R_TRIG_BOOL').		pouDecl pouBody cCode: '		// Utilización del FB instancia R_TRIG_IN.		// Lo que sigue implementa: CAL R_TRIG_IN(CLK:=IN, Q=>EDGE)		(pxPOU->R_TRIG_IN).CLK = pxPOU->IN;	// Completo los parametros VAR_INPUT de REDGE		PLC_FB_R_TRIG_BOOL( &(pxPOU->R_TRIG_IN) );	// Llamo a la función pasandole la estructura por referencia		pxPOU->EDGE = (pxPOU->R_TRIG_IN).Q;	// Grabo los parametros VAR_OUTPUT de REDGE a las variables													// a las cuales estan igualadas las VAR_OUTPUT de REDGE		// Si contando == 0 (no esta contando) y hay flanco ascendente, arranca a contar		if ( pxPOU->EDGE && !!(pxPOU->RUNNING) ){			pxPOU->START = xTaskGetTickCount();	// Obtiene el tiempo inicial de ticks			pxPOU->RUNNING = true; 				// Comienza a contar el tiempo de pulso			pxPOU->Q = true; 					// Enciende la salida de pulso		}		// Si está contando		if ( pxPOU->RUNNING ){			pxPOU->ET = xTaskGetTickCount() - pxPOU->START; 	// Calcula el tiempo transcurrido ET = t1 - t0			// Si ET >= PT entonces termina de contar y satura el valor de ET en PT			if ( pxPOU->ET >= pxPOU->PT ){				pxPOU->Q = false;				// Apaga la salida de pulso				pxPOU->ET = pxPOU->PT;			// Satura el valor de ET en PT				pxPOU->RUNNING = false;			// Deja de contar			}		}		// Si la entrada IN es 0 y No está contando		if ( !!(pxPOU->IN) && !!(pxPOU->RUNNING) ){			pxPOU->ET = 0;		}'.			^ pouDecl.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:43'!StdFunctionBlocks	"Devuelve el diccionario."		^ StdFunctionBlocks.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:43'!UserFunctionBlocks	"Devuelve el diccionario."		^ UserFunctionBlocks.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 6/22/2013 03:32'!addStdFunctionBlock: aFunctionBlockDecl	"Añade una declaración de Bloque de Función."			StdFunctionBlocks at: aFunctionBlockDecl typedIdentifier put: aFunctionBlockDecl.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 6/22/2013 03:31'!addUserFunctionBlock: aFunctionBlockDecl	"Añade una declaración de Bloque de Función."			UserFunctionBlocks at: aFunctionBlockDecl typedIdentifier put: aFunctionBlockDecl.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 11/22/2013 16:46'!clearFunctionBlocks	"Borra los diccionarios."			self clearStdFunctionBlocks.	self clearUserFunctionBlocks.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 11/19/2013 00:04'!clearStdFunctionBlocks	"Borra el diccionario."			StdFunctionBlocks := Dictionary new.		StdFunctionBlocksCreated := false.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:26'!clearUserFunctionBlocks	"Borra el diccionario."			UserFunctionBlocks := Dictionary new.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 11/22/2013 16:48'!createStdFunctionBlocks	"Crea los Bloques de Función Estándar."			StdFunctionBlocks := Dictionary new.		self createStdFunctionBlockDeclarations. 		StdFunctionBlocksCreated := true.! !!PLC_FunctionBlock class methodsFor: 'instance creation' stamp: 'EricPernia 11/19/2013 00:03'!newWithName: anIdentifier andDataType: aPLC_DataType	"Nuevo con nombre y tipo de datos"	| pou |		pou := self newWithName: anIdentifier.			pou dataType: aPLC_DataType.			^ pou.! !!PLC_FunctionBlock class methodsFor: 'Std Function Blocks' stamp: 'EricPernia 11/18/2013 23:36'!createBiestableFunctionBlockDeclarations	"Crea y guarda en la biblioteca los bloques de funcion de temporizadores"		"SR"	self createSRFunctionBlockDeclaration.		"RS"	self createRSFunctionBlockDeclaration.! !!PLC_FunctionBlock class methodsFor: 'Std Function Blocks' stamp: 'EricPernia 11/19/2013 07:00'!createCounterFunctionBlockDeclarations	"Crea y guarda en la biblioteca los bloques de funcion Contadores"		"CTU"	self createCTUFunctionBlockDeclarationWithType: PLC_DataType Int.	"CTD"	self createCTDFunctionBlockDeclarationWithType:  PLC_DataType Int.		"CTUD"	self createCTUDFunctionBlockDeclarationWithType:  PLC_DataType Int.		! !!PLC_FunctionBlock class methodsFor: 'Std Function Blocks' stamp: 'EricPernia 11/18/2013 23:37'!createEdgeFunctionBlockDeclarations	"Crea y guarda en la biblioteca los bloques de funcion de temporizadores"		"R_TRIG"	self createR_TRIGFunctionBlockDeclaration.		"F_TRIG"	self createF_TRIGFunctionBlockDeclaration.! !!PLC_FunctionBlock class methodsFor: 'Std Function Blocks' stamp: 'EricPernia 11/19/2013 07:02'!createStdFunctionBlockDeclarations	"Crea y guarda en la biblioteca los bloques de funcion de temporizadores"		"BIESTABLES"	self createBiestableFunctionBlockDeclarations.		"EDGE DETECTORS"	self createEdgeFunctionBlockDeclarations.		"TIMERS"	self createTimerFunctionBlockDeclarations.		"COUNTERS"	self createCounterFunctionBlockDeclarations.! !!PLC_FunctionBlock class methodsFor: 'Std Function Blocks' stamp: 'EricPernia 11/15/2013 05:58'!createTimerFunctionBlockDeclarations	"Crea y guarda en la biblioteca los bloques de funcion de temporizadores"		"TP"	self createTPFunctionBlockDeclaration.		"TON"	self createTONFunctionBlockDeclaration.		"TOF"	self createTOFFunctionBlockDeclaration.! !PLC_POU subclass: #PLC_Function	instanceVariableNames: 'instance'	classVariableNames: 'StdFunctions StdFunctionsCreated UserFunctions'	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_Function commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Function is xxxxxxxxx.Instance Variables	instance:		<Object>instance	- xxxxx!!PLC_Function methodsFor: 'initialize-release' stamp: 'EricPernia 11/16/2013 13:50'!initialize.	"Inicializo la declaración de Función."	super initialize.	"Declaraciones de Variables y Tipos de Datos"	self declarations: ( PLC_Function_Declarations functionDeclarationsWithPOUDeclaration: self ).! !!PLC_Function methodsFor: 'accessing' stamp: 'EricPernia 11/16/2013 13:41'!return	^ self declarations returnVarDecl first! !!PLC_Function methodsFor: 'POU type' stamp: 'EricPernia 6/21/2013 04:41'!pouType	"Devuelve el tipo de POU que es."	^ 'FUNCTION'! !!PLC_Function methodsFor: 'POU type' stamp: 'EricPernia 6/21/2013 04:50'!pouTypeAcronym	"Devuelve las siglas del tipo de POU que es."	^ 'F'! !!PLC_Function methodsFor: 'instance' stamp: 'EricPernia 11/15/2013 01:43'!instanceDecl	"Devuelve la variable de instancia única de la declaración de Función."	instance		ifNil: [ 			instance :=  self instanceDeclWithIdentifier: nil.			].			^ instance.! !!PLC_Function methodsFor: 'instance' stamp: 'EricPernia 11/15/2013 01:44'!instanceDeclWithIdentifier: anIdentifier	"Devuelve una nueva variable de instancia de la declaración de Programa o Bloque de Función."		anIdentifier 		ifNil: [			instance := PLC_InstanceVariableDecl				newWithDataType: self typeDeclaration 				andInitialValue: nil				andIdentifier: self typedIdentifier , '_VAR'.			]		ifNotNil: [			instance := PLC_InstanceVariableDecl 				newWithDataType: self typeDeclaration 				andInitialValue: nil				andIdentifier: anIdentifier.			].	^ instance.! !!PLC_Function methodsFor: 'instance' stamp: 'EricPernia 6/21/2013 05:38'!resetInstance	"Borra la variable de instancia en caso de modificación de la Declaración de Función."	instance := nil.! !!PLC_Function methodsFor: 'compilation' stamp: 'EricPernia 11/16/2013 14:09'!cCompile	"Definiciónn de Función en C que implementa la POU.		Ejemplo:	void ProgEj ( PLC_P_Struct_ProgEj * pxPOU )	{		// Cuerpo de POU				PLC_IL_LD ( &( pxPOU -> Ent1 ), sizeof (pxPOU -> Ent1 ), BOOL , NullModifier ); // LD Ent1				PLC_IL_AND ( &( pxPOU -> Ent2 ), BOOL , NullModifier ); // AND Ent2				PLC_IL_ST ( &( pxPOU ->Sal), sizeof (pxPOU ->Sal), NullModifier ); // ST Sal	}."		| progAcc cCode |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.			"	LAS POU NO ADMITEN VAR_GLOBAL	y las F no tienen VAR_EXTERN, ni VAR_TEMP y pisan antes del cuerpo de POU las VAR 		Dentro de la estructura de instancia:		self declarations inputVarDecls	self declarations outputVarDecls	self declarations inOutVarDecls	self declarations varDecls		Dentro de la funcion de la POU en C:		self declarations constantVarDecls 		progAcc compilerDataTypesDecls cCompile.	progAcc compilerVarDecls cCompile.	progAcc compiledBody	 cCompile.	"		"Le envio la petición al Cuerpo de POU de que se compile en el acumulador"	self pouBody generateCodeIn: progAcc.		cCode := '	void ' , self cPOUName , '( ' , self declarations typeDeclarationIdentifier , ' *pxPOU )	{			// Declaraciones de Tipos de datos del compilador		'.			cCode := cCode , progAcc compilerDataTypesDecls cCompile , '			// Declaraciones de variables del compilador		'.			cCode := cCode , progAcc compilerVarDecls cCompile , '			// Declaraciones de variables del usuario		',		self declarations constantVarDecls cCompile.			"ACA FALTA QUE EN FUNCTION PISE CONCERO A LAS VAR INTERNAS PARAQUENOTENGA MEMORIA"		cCode := cCode , '			// Cuerpo de POU		',	progAcc compiledBody cCompile.			cCode := cCode, '		}'.		^ cCode.! !!PLC_Function methodsFor: 'compilation' stamp: 'EricPernia 11/16/2013 13:45'!ilCompile	"Definición de POU en IL.		Ejemplo:	FUNCTION Fej : INT			(* Declaraciones de POU *)			VAR_INPUT				Ent1 : BOOL ;				Ent2 : BOOL ;			END_VAR						VAR_OUTPUT				Sal : BOOL ;			END_VAR					(* Cuerpo de POU *)					LD Ent1			AND Ent2			ST Sal				END_FUNCTION		"		| progAcc ilCode |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.			"	LAS POU NO ADMITEN VAR_GLOBAL		Dentro de la estructura de instancia:		self declarations inputVarDecls	self declarations outputVarDecls	self declarations inOutVarDecls	self declarations varDecls		Dentro de la funcion de la POU en C:		self declarations constantVarDecls 	self declarations tempVarDecls 	self declarations externVarDecls 		progAcc compilerDataTypesDecls cCompile.	progAcc compilerVarDecls cCompile.	progAcc compiledBody	 cCompile.	"		"Le envio la petición al Cuerpo de POU de que se compile en el acumulador"	self pouBody generateCodeIn: progAcc.		ilCode := '	' , self pouType , ' ' , self identifier , ' : ' , self return dataType ilCompile , '			 (* Declaraciones de Tipos de datos del compilador *)		'.			ilCode := ilCode , progAcc compilerDataTypesDecls ilCompile , '				 (* Declaraciones de variables del compilador *)		'.			ilCode := ilCode , progAcc compilerVarDecls ilCompile , '			 (* Declaraciones de variables del usuario *)		',	self declarations inputVarDecls ilCompile ,	self declarations outputVarDecls ilCompile ,	self declarations inOutVarDecls ilCompile ,	self declarations varDecls ilCompile ,	self declarations constantVarDecls ilCompile .		ilCode := ilCode , '			 (* Cuerpo de POU *)		',	progAcc compiledBody ilCompile.			ilCode := ilCode, '				END_' , self pouType.		^ ilCode.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Function class	instanceVariableNames: ''!!PLC_Function class methodsFor: 'Std Logical' stamp: 'EricPernia 11/15/2013 04:49'!createAndFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar AND_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'AND'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			pxPOU->OUT = pxPOU->IN1 & pxPOU->IN2;			// Las POU Funcion copian su valor de rerotno al CR			CR.VALUE.INT = pxPOU->OUT;			CR.TYPE = ' , 			self return dataType ilCompile , ';		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Comparison' stamp: 'EricPernia 11/17/2013 14:19'!createEQFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar EQ_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'EQ'		andDataType: aDataType		andFunctionResultType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			// Cargo el valor de IN1 al CR // LD IN1			PLC_IL_LD( &(pxPOU->IN1), sizeof(pxPOU->IN1), ' , pouDecl return dataType ilCompile , ', NullModifier);								// Hago la compración de IN2 contra el CR el resultado se guara en el CR // EQ IN2			PLC_IL_EQ(&(pxPOU->IN2), ' , pouDecl return dataType ilCompile , ');									// Almaceno el CR en OUT // ST OUT  // Las POU Funcion copian su valor de rerotno al CR, en este caso es al reves			PLC_IL_ST( &(pxPOU->OUT), sizeof(pxPOU->OUT), NullModifier); 		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Comparison' stamp: 'EricPernia 11/17/2013 01:23'!createGEFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar GE_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'GE'		andDataType: aDataType		andFunctionResultType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			// Cargo el valor de IN1 al CR // LD IN1			PLC_IL_LD( &(pxPOU->IN1), sizeof(pxPOU->IN1), ' , pouDecl return dataType ilCompile , ', NullModifier);								// Hago la compración de IN2 contra el CR el resultado se guara en el CR // EQ IN2			PLC_IL_GE(&(pxPOU->IN2), ' , pouDecl return dataType ilCompile , ')										// Almaceno el CR en OUT // ST OUT  // Las POU Funcion copian su valor de rerotno al CR, en este caso es al reves			PLC_IL_ST( &(pxPOU->OUT), sizeof(pxPOU->OUT), NullModifier); 		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Comparison' stamp: 'EricPernia 11/17/2013 01:23'!createGTFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar GT_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'GT'		andDataType: aDataType		andFunctionResultType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			// Cargo el valor de IN1 al CR // LD IN1			PLC_IL_LD( &(pxPOU->IN1), sizeof(pxPOU->IN1), ' , pouDecl return dataType ilCompile , ', NullModifier);								// Hago la compración de IN2 contra el CR el resultado se guara en el CR // EQ IN2			PLC_IL_GT(&(pxPOU->IN2), ' , pouDecl return dataType ilCompile , ')										// Almaceno el CR en OUT // ST OUT  // Las POU Funcion copian su valor de rerotno al CR, en este caso es al reves			PLC_IL_ST( &(pxPOU->OUT), sizeof(pxPOU->OUT), NullModifier); 		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Comparison' stamp: 'EricPernia 11/17/2013 01:23'!createLEFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar LE_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'LE'		andDataType: aDataType		andFunctionResultType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			// Cargo el valor de IN1 al CR // LD IN1			PLC_IL_LD( &(pxPOU->IN1), sizeof(pxPOU->IN1), ' , pouDecl return dataType ilCompile , ', NullModifier);								// Hago la compración de IN2 contra el CR el resultado se guara en el CR // EQ IN2			PLC_IL_LE(&(pxPOU->IN2), ' , pouDecl return dataType ilCompile , ')										// Almaceno el CR en OUT // ST OUT  // Las POU Funcion copian su valor de rerotno al CR, en este caso es al reves			PLC_IL_ST( &(pxPOU->OUT), sizeof(pxPOU->OUT), NullModifier); 		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Comparison' stamp: 'EricPernia 11/17/2013 01:23'!createLTFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar LT_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'LT'		andDataType: aDataType		andFunctionResultType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			// Cargo el valor de IN1 al CR // LD IN1			PLC_IL_LD( &(pxPOU->IN1), sizeof(pxPOU->IN1), ' , pouDecl return dataType ilCompile , ', NullModifier);								// Hago la compración de IN2 contra el CR el resultado se guara en el CR // EQ IN2			PLC_IL_LT(&(pxPOU->IN2), ' , pouDecl return dataType ilCompile , ')										// Almaceno el CR en OUT // ST OUT  // Las POU Funcion copian su valor de rerotno al CR, en este caso es al reves			PLC_IL_ST( &(pxPOU->OUT), sizeof(pxPOU->OUT), NullModifier); 		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Comparison' stamp: 'EricPernia 11/17/2013 01:23'!createNEFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar NE_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'NE'		andDataType: aDataType		andFunctionResultType: PLC_DataType Bool.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			// Cargo el valor de IN1 al CR // LD IN1			PLC_IL_LD( &(pxPOU->IN1), sizeof(pxPOU->IN1), ' , pouDecl return dataType ilCompile , ', NullModifier);								// Hago la compración de IN2 contra el CR el resultado se guara en el CR // EQ IN2			PLC_IL_NE(&(pxPOU->IN2), ' , pouDecl return dataType ilCompile , ')										// Almaceno el CR en OUT // ST OUT  // Las POU Funcion copian su valor de rerotno al CR, en este caso es al reves			PLC_IL_ST( &(pxPOU->OUT), sizeof(pxPOU->OUT), NullModifier); 		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/15/2013 05:16'!createArithmeticFunctionDeclarations	"Crea y guarda en la biblioteca las funciones Aritméticas"		"ADD"	self createAddFunctionDeclarationWithType: PLC_DataType Int.	self createAddFunctionDeclarationWithType: PLC_DataType DInt.	self createAddFunctionDeclarationWithType: PLC_DataType USInt.	self createAddFunctionDeclarationWithType: PLC_DataType UInt.	self createAddFunctionDeclarationWithType: PLC_DataType SInt.	self createAddFunctionDeclarationWithType: PLC_DataType UDInt.	self createAddFunctionDeclarationWithType: PLC_DataType Real.	self createAddFunctionDeclarationWithType: PLC_DataType LReal.	self createAddFunctionDeclarationWithType: PLC_DataType Time.		"SUB"	self createSubFunctionDeclarationWithType: PLC_DataType Int.	self createSubFunctionDeclarationWithType: PLC_DataType DInt.	self createSubFunctionDeclarationWithType: PLC_DataType USInt.	self createSubFunctionDeclarationWithType: PLC_DataType UInt.	self createSubFunctionDeclarationWithType: PLC_DataType SInt.	self createSubFunctionDeclarationWithType: PLC_DataType UDInt.	self createSubFunctionDeclarationWithType: PLC_DataType Real.	self createSubFunctionDeclarationWithType: PLC_DataType LReal.	self createSubFunctionDeclarationWithType: PLC_DataType Time.		"MUL"	self createMulFunctionDeclarationWithType: PLC_DataType Int.	self createMulFunctionDeclarationWithType: PLC_DataType DInt.	self createMulFunctionDeclarationWithType: PLC_DataType USInt.	self createMulFunctionDeclarationWithType: PLC_DataType UInt.	self createMulFunctionDeclarationWithType: PLC_DataType SInt.	self createMulFunctionDeclarationWithType: PLC_DataType UDInt.	self createMulFunctionDeclarationWithType: PLC_DataType Real.	self createMulFunctionDeclarationWithType: PLC_DataType LReal.	self createMulFunctionDeclarationWithType: PLC_DataType Time.		"DIV"	self createDivFunctionDeclarationWithType: PLC_DataType Int.	self createDivFunctionDeclarationWithType: PLC_DataType DInt.	self createDivFunctionDeclarationWithType: PLC_DataType USInt.	self createDivFunctionDeclarationWithType: PLC_DataType UInt.	self createDivFunctionDeclarationWithType: PLC_DataType SInt.	self createDivFunctionDeclarationWithType: PLC_DataType UDInt.	self createDivFunctionDeclarationWithType: PLC_DataType Real.	self createDivFunctionDeclarationWithType: PLC_DataType LReal.	self createDivFunctionDeclarationWithType: PLC_DataType Time.		"MOD (No permite Reales)"	self createModFunctionDeclarationWithType: PLC_DataType Int.	self createModFunctionDeclarationWithType: PLC_DataType DInt.	self createModFunctionDeclarationWithType: PLC_DataType USInt.	self createModFunctionDeclarationWithType: PLC_DataType UInt.	self createModFunctionDeclarationWithType: PLC_DataType SInt.	self createModFunctionDeclarationWithType: PLC_DataType UDInt.	self createModFunctionDeclarationWithType: PLC_DataType Time.	! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/15/2013 05:23'!createComparisonFunctionDeclarations	"Crea y guarda en la biblioteca las funciones de Comparación"		"EQ - No tiene sentido comparar por igual en reales"	self createEQFunctionDeclarationWithType: PLC_DataType Int.	self createEQFunctionDeclarationWithType: PLC_DataType DInt.	self createEQFunctionDeclarationWithType: PLC_DataType USInt.	self createEQFunctionDeclarationWithType: PLC_DataType UInt.	self createEQFunctionDeclarationWithType: PLC_DataType SInt.	self createEQFunctionDeclarationWithType: PLC_DataType UDInt.	self createEQFunctionDeclarationWithType: PLC_DataType Time.		"NE - No tiene sentido comparar por distinto en reales"	self createNEFunctionDeclarationWithType: PLC_DataType Int.	self createNEFunctionDeclarationWithType: PLC_DataType DInt.	self createNEFunctionDeclarationWithType: PLC_DataType USInt.	self createNEFunctionDeclarationWithType: PLC_DataType UInt.	self createNEFunctionDeclarationWithType: PLC_DataType SInt.	self createNEFunctionDeclarationWithType: PLC_DataType UDInt.	self createNEFunctionDeclarationWithType: PLC_DataType Time.		"GT"	self createGTFunctionDeclarationWithType: PLC_DataType Int.	self createGTFunctionDeclarationWithType: PLC_DataType DInt.	self createGTFunctionDeclarationWithType: PLC_DataType USInt.	self createGTFunctionDeclarationWithType: PLC_DataType UInt.	self createGTFunctionDeclarationWithType: PLC_DataType SInt.	self createGTFunctionDeclarationWithType: PLC_DataType UDInt.	self createGTFunctionDeclarationWithType: PLC_DataType Real.	self createGTFunctionDeclarationWithType: PLC_DataType LReal.	self createGTFunctionDeclarationWithType: PLC_DataType Time.		"GE - No tiene sentido comparar por mayor o igual en reales"	self createGEFunctionDeclarationWithType: PLC_DataType Int.	self createGEFunctionDeclarationWithType: PLC_DataType DInt.	self createGEFunctionDeclarationWithType: PLC_DataType USInt.	self createGEFunctionDeclarationWithType: PLC_DataType UInt.	self createGEFunctionDeclarationWithType: PLC_DataType SInt.	self createGEFunctionDeclarationWithType: PLC_DataType UDInt.	self createGEFunctionDeclarationWithType: PLC_DataType Time.		"LT"	self createLTFunctionDeclarationWithType: PLC_DataType Int.	self createLTFunctionDeclarationWithType: PLC_DataType DInt.	self createLTFunctionDeclarationWithType: PLC_DataType USInt.	self createLTFunctionDeclarationWithType: PLC_DataType UInt.	self createLTFunctionDeclarationWithType: PLC_DataType SInt.	self createLTFunctionDeclarationWithType: PLC_DataType UDInt.	self createLTFunctionDeclarationWithType: PLC_DataType Real.	self createLTFunctionDeclarationWithType: PLC_DataType LReal.	self createLTFunctionDeclarationWithType: PLC_DataType Time.		"LE - No tiene sentido comparar por menor o igual en reales"	self createLEFunctionDeclarationWithType: PLC_DataType Int.	self createLEFunctionDeclarationWithType: PLC_DataType DInt.	self createLEFunctionDeclarationWithType: PLC_DataType USInt.	self createLEFunctionDeclarationWithType: PLC_DataType UInt.	self createLEFunctionDeclarationWithType: PLC_DataType SInt.	self createLEFunctionDeclarationWithType: PLC_DataType UDInt.	self createLEFunctionDeclarationWithType: PLC_DataType Time.! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/15/2013 05:21'!createMovFunctionDeclarations	"Crea y guarda en la biblioteca las funciones Mov"		"MOV"	self createMovFunctionDeclarationWithType: PLC_DataType Int.	self createMovFunctionDeclarationWithType: PLC_DataType DInt.	self createMovFunctionDeclarationWithType: PLC_DataType USInt.	self createMovFunctionDeclarationWithType: PLC_DataType UInt.	self createMovFunctionDeclarationWithType: PLC_DataType SInt.	self createMovFunctionDeclarationWithType: PLC_DataType UDInt.	self createMovFunctionDeclarationWithType: PLC_DataType Real.	self createMovFunctionDeclarationWithType: PLC_DataType LReal.	self createMovFunctionDeclarationWithType: PLC_DataType Time.! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/18/2013 22:21'!createStandardFunctionDeclarations	"Crea y guarda en la biblioteca las funciones estandar"			"MOV"	self createMovFunctionDeclarations .		"Aritméticas"	self createArithmeticFunctionDeclarations.		"Comparación"	self createComparisonFunctionDeclarations.	! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/18/2013 22:22'!createTFArithmeticFunctionDeclarations	"Crea y guarda en la biblioteca las funciones Aritméticas"		"ADD"	self createAddFunctionDeclarationWithType: PLC_DataType Int.	"self createAddFunctionDeclarationWithType: PLC_DataType DInt.	self createAddFunctionDeclarationWithType: PLC_DataType USInt.	self createAddFunctionDeclarationWithType: PLC_DataType UInt.	self createAddFunctionDeclarationWithType: PLC_DataType SInt.	self createAddFunctionDeclarationWithType: PLC_DataType UDInt.	self createAddFunctionDeclarationWithType: PLC_DataType Real.	self createAddFunctionDeclarationWithType: PLC_DataType LReal."	self createAddFunctionDeclarationWithType: PLC_DataType Time.		"SUB"	self createSubFunctionDeclarationWithType: PLC_DataType Int.	"self createSubFunctionDeclarationWithType: PLC_DataType DInt.	self createSubFunctionDeclarationWithType: PLC_DataType USInt.	self createSubFunctionDeclarationWithType: PLC_DataType UInt.	self createSubFunctionDeclarationWithType: PLC_DataType SInt.	self createSubFunctionDeclarationWithType: PLC_DataType UDInt.	self createSubFunctionDeclarationWithType: PLC_DataType Real.	self createSubFunctionDeclarationWithType: PLC_DataType LReal."	self createSubFunctionDeclarationWithType: PLC_DataType Time.		"MUL"	self createMulFunctionDeclarationWithType: PLC_DataType Int.	"self createMulFunctionDeclarationWithType: PLC_DataType DInt.	self createMulFunctionDeclarationWithType: PLC_DataType USInt.	self createMulFunctionDeclarationWithType: PLC_DataType UInt.	self createMulFunctionDeclarationWithType: PLC_DataType SInt.	self createMulFunctionDeclarationWithType: PLC_DataType UDInt.	self createMulFunctionDeclarationWithType: PLC_DataType Real.	self createMulFunctionDeclarationWithType: PLC_DataType LReal."	self createMulFunctionDeclarationWithType: PLC_DataType Time.		"DIV"	self createDivFunctionDeclarationWithType: PLC_DataType Int.	"self createDivFunctionDeclarationWithType: PLC_DataType DInt.	self createDivFunctionDeclarationWithType: PLC_DataType USInt.	self createDivFunctionDeclarationWithType: PLC_DataType UInt.	self createDivFunctionDeclarationWithType: PLC_DataType SInt.	self createDivFunctionDeclarationWithType: PLC_DataType UDInt.	self createDivFunctionDeclarationWithType: PLC_DataType Real.	self createDivFunctionDeclarationWithType: PLC_DataType LReal."	self createDivFunctionDeclarationWithType: PLC_DataType Time.		"MOD (No permite Reales)"	self createModFunctionDeclarationWithType: PLC_DataType Int.	"self createModFunctionDeclarationWithType: PLC_DataType DInt.	self createModFunctionDeclarationWithType: PLC_DataType USInt.	self createModFunctionDeclarationWithType: PLC_DataType UInt.	self createModFunctionDeclarationWithType: PLC_DataType SInt.	self createModFunctionDeclarationWithType: PLC_DataType UDInt."	self createModFunctionDeclarationWithType: PLC_DataType Time.	! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/18/2013 22:20'!createTFComparisonFunctionDeclarations	"Crea y guarda en la biblioteca las funciones de Comparación"		"EQ - No tiene sentido comparar por igual en reales"	self createEQFunctionDeclarationWithType: PLC_DataType Int.	"self createEQFunctionDeclarationWithType: PLC_DataType DInt.	self createEQFunctionDeclarationWithType: PLC_DataType USInt.	self createEQFunctionDeclarationWithType: PLC_DataType UInt.	self createEQFunctionDeclarationWithType: PLC_DataType SInt.	self createEQFunctionDeclarationWithType: PLC_DataType UDInt."	self createEQFunctionDeclarationWithType: PLC_DataType Time.		"NE - No tiene sentido comparar por distinto en reales"	self createNEFunctionDeclarationWithType: PLC_DataType Int.	"self createNEFunctionDeclarationWithType: PLC_DataType DInt.	self createNEFunctionDeclarationWithType: PLC_DataType USInt.	self createNEFunctionDeclarationWithType: PLC_DataType UInt.	self createNEFunctionDeclarationWithType: PLC_DataType SInt.	self createNEFunctionDeclarationWithType: PLC_DataType UDInt."	self createNEFunctionDeclarationWithType: PLC_DataType Time.		"GT"	self createGTFunctionDeclarationWithType: PLC_DataType Int.	"self createGTFunctionDeclarationWithType: PLC_DataType DInt.	self createGTFunctionDeclarationWithType: PLC_DataType USInt.	self createGTFunctionDeclarationWithType: PLC_DataType UInt.	self createGTFunctionDeclarationWithType: PLC_DataType SInt.	self createGTFunctionDeclarationWithType: PLC_DataType UDInt.	self createGTFunctionDeclarationWithType: PLC_DataType Real.	self createGTFunctionDeclarationWithType: PLC_DataType LReal."	self createGTFunctionDeclarationWithType: PLC_DataType Time.		"GE - No tiene sentido comparar por mayor o igual en reales"	self createGEFunctionDeclarationWithType: PLC_DataType Int.	"self createGEFunctionDeclarationWithType: PLC_DataType DInt.	self createGEFunctionDeclarationWithType: PLC_DataType USInt.	self createGEFunctionDeclarationWithType: PLC_DataType UInt.	self createGEFunctionDeclarationWithType: PLC_DataType SInt.	self createGEFunctionDeclarationWithType: PLC_DataType UDInt."	self createGEFunctionDeclarationWithType: PLC_DataType Time.		"LT"	self createLTFunctionDeclarationWithType: PLC_DataType Int.	"self createLTFunctionDeclarationWithType: PLC_DataType DInt.	self createLTFunctionDeclarationWithType: PLC_DataType USInt.	self createLTFunctionDeclarationWithType: PLC_DataType UInt.	self createLTFunctionDeclarationWithType: PLC_DataType SInt.	self createLTFunctionDeclarationWithType: PLC_DataType UDInt.	self createLTFunctionDeclarationWithType: PLC_DataType Real.	self createLTFunctionDeclarationWithType: PLC_DataType LReal."	self createLTFunctionDeclarationWithType: PLC_DataType Time.		"LE - No tiene sentido comparar por menor o igual en reales"	self createLEFunctionDeclarationWithType: PLC_DataType Int.	"self createLEFunctionDeclarationWithType: PLC_DataType DInt.	self createLEFunctionDeclarationWithType: PLC_DataType USInt.	self createLEFunctionDeclarationWithType: PLC_DataType UInt.	self createLEFunctionDeclarationWithType: PLC_DataType SInt.	self createLEFunctionDeclarationWithType: PLC_DataType UDInt."	self createLEFunctionDeclarationWithType: PLC_DataType Time.! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/18/2013 22:22'!createTFMovFunctionDeclarations	"Crea y guarda en la biblioteca las funciones Mov"		"MOV"	self createMovFunctionDeclarationWithType: PLC_DataType Int.	"self createMovFunctionDeclarationWithType: PLC_DataType DInt.	self createMovFunctionDeclarationWithType: PLC_DataType USInt.	self createMovFunctionDeclarationWithType: PLC_DataType UInt.	self createMovFunctionDeclarationWithType: PLC_DataType SInt.	self createMovFunctionDeclarationWithType: PLC_DataType UDInt.	self createMovFunctionDeclarationWithType: PLC_DataType Real.	self createMovFunctionDeclarationWithType: PLC_DataType LReal."	self createMovFunctionDeclarationWithType: PLC_DataType Time.! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/18/2013 22:21'!createTFStandardFunctionDeclarations	"Crea y guarda en la biblioteca las funciones estandar"			"MOV"	self createTFMovFunctionDeclarations .		"Aritméticas"	self createTFArithmeticFunctionDeclarations.		"Comparación"	self createTFComparisonFunctionDeclarations.	! !!PLC_Function class methodsFor: 'std functions' stamp: 'EricPernia 11/5/2013 12:56'!createTestIntFunctionDeclaration	"Crea y devuelve una Declaración de Función estándar TEST_INT"	| function |		"Declaracion de funcionTEST_INT"	function := PLC_Function		newWithName: 'TEST'		andDataType: PLC_DataType Int		andFunctionResultType: PLC_DataType Int.			PLC_Function addStdFunction: function.	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	function addENDeclaration.	function addENODeclaration.		"Agrego una declaracion de variable de entrada"	function inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Int			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	function inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Int			andInitialValue: nil 			andIdentifier: 'IN2' 		).				"Agrego una declaracion de variable de salida"	function outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Int			andInitialValue: nil 			andIdentifier: 'OUT1' 		).				"Agrego una declaracion de variable de salida"	function outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Int			andInitialValue: nil 			andIdentifier: 'OUT2' 		).				"Agrego una declaracion de variable de entrada-salida"	function inOutVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'IOc vcv v cvxc vcxv xcvx cv vcxv' 		).				"Agrego una declaracion de variable de entrada-salida"	function inOutVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Int			andInitialValue: nil 			andIdentifier: 'IO2 aaa sa asas aasasas asa' 		).			^ function.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:37'!StdFunctions	"Devuelve el diccionario."			^ StdFunctions.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:38'!UserFunctions	"Devuelve el diccionario."			^ UserFunctions.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 6/22/2013 03:31'!addStdFunction: aFunctionDecl	"Añade una declaración de Función."			StdFunctions at: aFunctionDecl typedIdentifier put: aFunctionDecl.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 6/22/2013 03:31'!addUserFunction: aFunctionDecl	"Añade una declaración de Función."			UserFunctions at: aFunctionDecl typedIdentifier put: aFunctionDecl.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 11/22/2013 16:37'!clearFunctions	"Borra los diccionarios."			self clearStdFunctions.	self clearUserFunctions.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:25'!clearStdFunctions	"Borra el diccionario."			StdFunctions := Dictionary new.		StdFunctionsCreated := false.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:25'!clearUserFunctions	"Borra el diccionario."			UserFunctions := Dictionary new.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 11/22/2013 16:45'!createStdFunctions	"Crea los Bloques de Función Estándar."			StdFunctions := Dictionary new.		self createTFStandardFunctionDeclarations. "Si la saco TF a este metodo crea todas sino crea solo con tipos INT y TIME"		StdFunctionsCreated := true.	! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 11/16/2013 13:40'!newWithName: anIdentifier andDataType: aPLC_DataType	"Nuevo con nombre y tipo de datos"	| function |		function := self newWithName: anIdentifier.		function dataType: aPLC_DataType.		function declarations returnVarDecl add: ( PLC_SymbolicVariableDecl		newWithDataType: aPLC_DataType 		andInitialValue: nil 		andIdentifier: 'OUT' ).	"La variable de RETURN se llama OUT No Ret o Ret_Val"			function dataType: aPLC_DataType.			"Agregar a diccionario de Funciones"	"Hacerrrrrrrrrr de la forma :	PLC_FunctionDeclaration  add: function."			^ function.! !!PLC_Function class methodsFor: 'instance creation' stamp: 'EricPernia 11/16/2013 13:40'!newWithName: anIdentifier andDataType: aPLC_DataType andFunctionResultType: anotherPLC_DataType	"Nuevo con nombre y tipo de datos		ESTE METODO SIRVE PARA HACER LAS FUNCIONES DE COMPARACION POR EJEJMPLO. 		Sirve para que una función tenga un tipo de datos de Return distinto al tipo de datos de la POU (de sobrecarga)"	| function |		function := self newWithName: anIdentifier.			function dataType: aPLC_DataType.		function declarations returnVarDecl add: ( PLC_SymbolicVariableDecl		newWithDataType: anotherPLC_DataType 		andInitialValue: nil 		andIdentifier: 'OUT' ).			"Agregar a diccionario de Funciones"	"Hacerrrrrrrrrr de la forma :	PLC_FunctionDeclaration  add: function."			^ function.! !!PLC_Function class methodsFor: 'class initialization' stamp: 'EricPernia 11/22/2013 16:38'!initialize 	"comment stating purpose of message"	super initialize.		self clearFunctions.! !!PLC_Function class methodsFor: 'Std Mov' stamp: 'EricPernia 11/17/2013 01:20'!createMovFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar MOV_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'MOV'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN' 		).									"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			pxPOU->OUT = pxPOU->IN;			// Las POU Funcion copian su valor de rerotno al CR			CR.VALUE.INT = pxPOU->OUT;			CR.TYPE = ' , 			pouDecl return dataType ilCompile , ';		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Arithmetic' stamp: 'EricPernia 11/18/2013 23:08'!createAddFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar ADD_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'ADD'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).				"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			pxPOU->OUT = pxPOU->IN1 + pxPOU->IN2;			// Las POU Funcion copian su valor de rerotno al CR			CR.VALUE.INT = pxPOU->OUT;			CR.TYPE = ' , 			pouDecl return dataType ilCompile , ';		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Arithmetic' stamp: 'EricPernia 11/17/2013 01:22'!createDivFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar DIV_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'DIV'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			pxPOU->OUT = pxPOU->IN1 / pxPOU->IN2;			// Las POU Funcion copian su valor de rerotno al CR			CR.VALUE.INT = pxPOU->OUT;			CR.TYPE = ' , 			pouDecl return dataType ilCompile , ';		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Arithmetic' stamp: 'EricPernia 11/17/2013 01:22'!createModFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar MOD_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'MOD'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			pxPOU->OUT = pxPOU->IN1 % pxPOU->IN2;			// Las POU Funcion copian su valor de rerotno al CR			CR.VALUE.INT = pxPOU->OUT;			CR.TYPE = ' , 			pouDecl return dataType ilCompile , ';		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Arithmetic' stamp: 'EricPernia 11/17/2013 01:21'!createMulFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar MUL_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'MUL'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			pxPOU->OUT = pxPOU->IN1 * pxPOU->IN2;			// Las POU Funcion copian su valor de rerotno al CR			CR.VALUE.INT = pxPOU->OUT;			CR.TYPE = ' , 			pouDecl return dataType ilCompile , ';		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !!PLC_Function class methodsFor: 'Std Arithmetic' stamp: 'EricPernia 11/17/2013 01:21'!createSubFunctionDeclarationWithType: aDataType	"Crea y devuelve una Declaración de Función estándar SUB_aDataType"	| pouDecl |		"DECLARACION DE POU"	pouDecl := self		newWithName: 'SUB'		andDataType: aDataType.			"Agrego la función a la biblioteca de funciones estándar"			self addStdFunction: pouDecl.		"DECLARACIONES DE VARIABLES DE LA POU"	"Agrego una declaracion de variable de entrada 	EN y una de salida ENO, ambas booleanas."	pouDecl addENDeclaration.	pouDecl addENODeclaration.		"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN1' 		).					"Agrego una declaracion de variable de entrada"	pouDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: aDataType			andInitialValue: nil 			andIdentifier: 'IN2' 		).					"CUERPO DE LA POU"	pouDecl pouBody: PLC_StandardBody new.	pouDecl pouBody cCode: '		extern PLC_SymbolicRegister CR;		// Chequeo EN / ENO		if( pxPOU->EN )		{			// Hacer chequeo de si se paso del rango y si se paso poner ENO a 0			// Si da bien el chequeo:			pxPOU->ENO = true;			pxPOU->OUT = pxPOU->IN1 - pxPOU->IN2;			// Las POU Funcion copian su valor de rerotno al CR			CR.VALUE.INT = pxPOU->OUT;			CR.TYPE = ' , 			pouDecl return dataType ilCompile , ';		}		else		{			pxPOU->ENO = pxPOU->EN;		}'.			^ pouDecl.! !PLC_POU subclass: #PLC_Program	instanceVariableNames: ''	classVariableNames: 'Programs'	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_Program commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Program is xxxxxxxxx.Instance Variables!!PLC_Program methodsFor: 'initialize-release' stamp: 'EricPernia 6/21/2013 04:23'!initialize.	"Inicializo la declaración de Programa."	super initialize.	"Declaraciones de Variables y Tipos de Datos"	self declarations: ( PLC_POU_Declarations programDeclarationsWithPOUDeclaration: self ).! !!PLC_Program methodsFor: 'variable declarations' stamp: 'EricPernia 6/8/2013 17:01'!tempVarDecls	"Devuelve sus declaraciones de variables Internas Temporales"	^ self declarations tempVarDecls.! !!PLC_Program methodsFor: 'POU type' stamp: 'EricPernia 6/21/2013 04:41'!pouType	"Devuelve el tipo de POU que es."	^ 'PROGRAM'! !!PLC_Program methodsFor: 'POU type' stamp: 'EricPernia 6/21/2013 04:51'!pouTypeAcronym	"Devuelve las siglas del tipo de POU que es."	^ 'P'! !!PLC_Program methodsFor: 'compilation' stamp: 'EricPernia 11/19/2013 05:06'!cCompile	"Definiciónn de Función en C que implementa la POU.		Ejemplo:	void ProgEj ( PLC_P_Struct_ProgEj * pxPOU )	{		// Cuerpo de POU				PLC_IL_LD ( &( pxPOU -> Ent1 ), sizeof (pxPOU -> Ent1 ), BOOL , NullModifier ); // LD Ent1				PLC_IL_AND ( &( pxPOU -> Ent2 ), BOOL , NullModifier ); // AND Ent2				PLC_IL_ST ( &( pxPOU ->Sal), sizeof (pxPOU ->Sal), NullModifier ); // ST Sal	}."		| progAcc cCode |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.			"	LAS POU NO ADMITEN VAR_GLOBAL		Dentro de la estructura de instancia:		self declarations inputVarDecls	self declarations outputVarDecls	self declarations inOutVarDecls	self declarations varDecls		Dentro de la funcion de la POU en C:		self declarations constantVarDecls 	self declarations tempVarDecls 	self declarations externVarDecls 		progAcc compilerDataTypesDecls cCompile.	progAcc compilerVarDecls cCompile.	progAcc compiledBody	 cCompile.	"		"Le envio la petición al Cuerpo de POU de que se compile en el acumulador"	self pouBody generateCodeIn: progAcc.		cCode := '	void ' , self cPOUName , '( ' , self declarations typeDeclarationIdentifier , ' *pxPOU )	{			// Declaraciones de Tipos de datos del compilador		'.			cCode := cCode , progAcc compilerDataTypesDecls cCompile , '			// Declaraciones de variables del compilador		'.			cCode := cCode , progAcc compilerVarDecls cCompile , '			// Declaraciones de variables del usuario		',		self declarations constantVarDecls cCompile ,	self declarations tempVarDecls cCompile ,	self declarations externVarDecls cCompile.			cCode := cCode , '			// Cuerpo de POU		',	progAcc compiledBody cCompile.			cCode := cCode, '		}'.		^ cCode.			! !!PLC_Program methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 22:47'!ilCompile	"Definición de POU en IL.		Ejemplo:	PROGRAM ProgEj			(* Declaraciones de POU *)			VAR_INPUT				Ent1 : BOOL ;				Ent2 : BOOL ;			END_VAR						VAR_OUTPUT				Sal : BOOL ;			END_VAR					(* Cuerpo de POU *)					LD Ent1			AND Ent2			ST Sal				END_PROGRAM		"		| progAcc ilCode |		"Creo el acumulador de objetos de programa."	progAcc := PLC_ProgramAccumulator_POU new.			"	LAS POU NO ADMITEN VAR_GLOBAL		Dentro de la estructura de instancia:		self declarations inputVarDecls	self declarations outputVarDecls	self declarations inOutVarDecls	self declarations varDecls		Dentro de la funcion de la POU en C:		self declarations constantVarDecls 	self declarations tempVarDecls 	self declarations externVarDecls 		progAcc compilerDataTypesDecls cCompile.	progAcc compilerVarDecls cCompile.	progAcc compiledBody	 cCompile.	"		"Le envio la petición al Cuerpo de POU de que se compile en el acumulador"	self pouBody generateCodeIn: progAcc.		ilCode := '	' , self pouType , ' ' , self identifier , '			 (* Declaraciones de Tipos de datos del compilador *)		'.			ilCode := ilCode , progAcc compilerDataTypesDecls ilCompile , '				 (* Declaraciones de variables del compilador *)		'.			ilCode := ilCode , progAcc compilerVarDecls ilCompile , '			 (* Declaraciones de variables del usuario *)		',	self declarations inputVarDecls ilCompile ,	self declarations outputVarDecls ilCompile ,	self declarations inOutVarDecls ilCompile ,	self declarations varDecls ilCompile ,	self declarations constantVarDecls ilCompile ,	self declarations tempVarDecls ilCompile ,	self declarations externVarDecls ilCompile.		ilCode := ilCode , '			 (* Cuerpo de POU *)		',	progAcc compiledBody ilCompile.			ilCode := ilCode, '				END_' , self pouType.		^ ilCode.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Program class	instanceVariableNames: ''!!PLC_Program class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:44'!Programs	"Devuelve el diccionario."		^ Programs.! !!PLC_Program class methodsFor: 'instance creation' stamp: 'EricPernia 6/22/2013 03:31'!addProgram: aProgramDecl	"Añade una declaración de Programa."			Programs at: aProgramDecl typedIdentifier put: aProgramDecl.! !!PLC_Program class methodsFor: 'instance creation' stamp: 'EricPernia 6/21/2013 20:30'!clearPrograms	"Borra el diccionario."			Programs := Dictionary new.! !Object subclass: #PLC_Objects	instanceVariableNames: 'objects'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_Objects commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Objects is xxxxxxxxx.Instance Variables	objects:		<Object>objects	- xxxxx!!PLC_Objects methodsFor: 'add-remove objects' stamp: 'EricPernia 11/5/2013 14:08'!add: anObject	"Agrega a su OC objects un objeto"	self objects add: anObject.! !!PLC_Objects methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 14:08'!cCompile	"Devuelve el string del código C del objectProgram"		| string |		string := ''.		self objects do: [ :each |		string := string ,  each cCompile.		].		^ string.! !!PLC_Objects methodsFor: 'compilation' stamp: 'EricPernia 11/5/2013 14:08'!ilCompile	"Devuelve el string del código IL del objectProgram"		| string |		string := ''.		self objects do: [ :each |		string := string ,  each ilCompile.		].		^ string.! !!PLC_Objects methodsFor: 'initialize-release' stamp: 'EricPernia 11/5/2013 14:07'!initialize	"Inicializaciones deñ ObjectProgram"	self objects: OrderedCollection new.! !!PLC_Objects methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 14:07'!objects		^ objects! !!PLC_Objects methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 14:07'!objects: anObject		objects := anObject! !PLC_POUBody subclass: #PLC_InstructionListBody	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Declarations-POU'!!PLC_InstructionListBody commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_InstructionListBody is xxxxxxxxx.Instance Variables!!PLC_InstructionListBody methodsFor: 'compilation' stamp: 'EricPernia 9/7/2013 05:03'!addNetwork	"Añade un nuevo Network de Bloques Conectables programa Ladder."	"HACERRRRRRRRRRRRRRRRRRRRRRRR"	self networks add: 1.! !!PLC_InstructionListBody methodsFor: 'compilation' stamp: 'EricPernia 10/31/2012 14:17'!objectCompileIn: aObjectProgram	"Compila su programa a objetos que lo forman. Estos pueden dar su código C o IL."	"DEBE CONVERTIR UN STRING DE INSTRUCCIONES IL EN OBJETOS IL"! !!PLC_InstructionListBody methodsFor: 'test' stamp: 'EricPernia 11/17/2013 16:14'!language	"Devuelve el lenguaje del cuerpo de POU"	^ 'INSTRUCTION LIST'! !PLC_FunctionBlock initialize!PLC_Function initialize!