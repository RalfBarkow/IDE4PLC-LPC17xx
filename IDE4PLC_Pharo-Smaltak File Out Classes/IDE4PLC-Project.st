"Copyright © 2012-2014 Eric Nicolás Pernia.This file is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>."Object subclass: #PLC_DevicePhysicalAddress	instanceVariableNames: 'device locationPrefix sizePrefix index'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_DevicePhysicalAddress commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_DevicePhysicalAddress is xxxxxxxxx.Instance Variables	device:		<Object>	index:		<Object>	locationPrefix:		<Object>	sizePrefix:		<Object>device	- xxxxxindex	- xxxxxlocationPrefix	- xxxxxsizePrefix	- xxxxx!!PLC_DevicePhysicalAddress methodsFor: 'device' stamp: 'EricPernia 11/4/2013 18:22'!slot	"Devuelve su numero de Slot o RANURA pidiendoselo a su Dispositivo"	"^ self device slot."		self device 		ifNil: [ 			^ 0.			] 		ifNotNil:[ 			^ self device slot.			 ] .	! !!PLC_DevicePhysicalAddress methodsFor: 'compilation' stamp: 'EricPernia 11/4/2013 18:27'!cCompile 	"Devuelve el string de código C de este Objeto de Programa"	"Ejemplo: I0.X.x6"	| sizePref |	self sizePrefix		ifNil: [ 			sizePref := 'X'.			] 		ifNotNil:[ 			sizePref := self sizePrefix.			 ] .		^ self locationPrefix, self slot asString , '.' , sizePref , '.' , sizePref asLowercase , self index asString.! !!PLC_DevicePhysicalAddress methodsFor: 'compilation' stamp: 'EricPernia 11/4/2013 18:30'!ilCompile 	"Devuelve el string de código IL de este Objeto de Programa"	"Ejemplo: %IX0.6"	| sizePref |	self sizePrefix		ifNil: [ 			sizePref := ''.			] 		ifNotNil:[ 			sizePref := self sizePrefix.			 ] .		^ '%' , self locationPrefix , sizePref , self slot asString , '.' , self index asString.! !!PLC_DevicePhysicalAddress methodsFor: 'initialize-release' stamp: 'EricPernia 11/4/2013 18:05'!initialize	"Inicializa el pin del PLC"! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:19'!device	"Es el dispositivo que contiene a esta direccion fisica"		^ device! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:00'!device: anObject		device := anObject! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:23'!index	"El ultimo numero que da el numero de Io O por ejemplo"		index		ifNil: [ 			^ 0.			] 		ifNotNil:[ 			^ index.			 ] .! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:00'!index: anObject		index := anObject! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:23'!locationPrefix	"I, Q o M"		locationPrefix		ifNil: [ 			^ 'M'.			] 		ifNotNil:[ 			^ locationPrefix.			 ] .! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:17'!locationPrefix: anObject		locationPrefix := anObject! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:28'!sizePrefix	"nil, X, B, W, D o L"		^ sizePrefix! !!PLC_DevicePhysicalAddress methodsFor: 'accessing' stamp: 'EricPernia 11/4/2013 18:16'!sizePrefix: anObject		sizePrefix := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_DevicePhysicalAddress class	instanceVariableNames: ''!!PLC_DevicePhysicalAddress class methodsFor: 'instance creation' stamp: 'EricPernia 11/4/2013 18:13'!newWithDevice: aDevice locationPrefix: aLocation sizePrefix: aSize index: anIndex	"Crea una nueva instancia con los parametros indicados"	| physicalAddress |		physicalAddress := self new.		physicalAddress device: aDevice.	physicalAddress locationPrefix: aLocation.	physicalAddress sizePrefix: aSize.	physicalAddress index: anIndex.		^ physicalAddress.! !PLC_ClassWithIdentifier subclass: #PLC_HardwareConfiguration	instanceVariableNames: 'softwareConfiguration devices devicesChange'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_HardwareConfiguration commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_HardwareConfiguration is xxxxxxxxx.Instance Variables	devices:		<Object>	devicesChange:		<Object>	softwareConfiguration:		<Object>devices	- xxxxxdevicesChange	- xxxxxsoftwareConfiguration	- xxxxx!!PLC_HardwareConfiguration methodsFor: 'initialize-release' stamp: 'EricPernia 11/8/2013 03:13'!initialize	"Inicializaciones de Recurso"	devices := OrderedCollection new.		"Creo la Ranura 0. Es un dispositivo vacio con ese nombre"	self addDevice: (PLC_DevicePLC voidDeviceWithNumber: 0). 		self devicesChange: false.! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 00:17'!devices		^ devices! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 00:17'!devices: anObject		devices := anObject! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 02:03'!devicesChange		^ devicesChange! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 02:03'!devicesChange: anObject		devicesChange := anObject! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 02:56'!hardConfigName	^ self identifier! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 02:55'!hardConfigName: anObject		identifier := anObject! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 00:17'!softwareConfiguration		^ softwareConfiguration! !!PLC_HardwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 00:17'!softwareConfiguration: anObject		softwareConfiguration := anObject! !!PLC_HardwareConfiguration methodsFor: 'devices' stamp: 'EricPernia 11/5/2013 02:06'!addDevice: aDevice	"Añade un dispositivo en un nuevo slot"	self devices add: aDevice.		aDevice hardwareConfiguration: self.		self devicesChange: true.! !!PLC_HardwareConfiguration methodsFor: 'devices' stamp: 'EricPernia 11/5/2013 02:12'!addDevice: aDevice at: index	"Añade el dispositivo aDevice en el slot de indice index"	self devices at: index + 1 put: aDevice.		aDevice hardwareConfiguration: self.		self devicesChange: true.! !!PLC_HardwareConfiguration methodsFor: 'devices' stamp: 'EricPernia 11/5/2013 02:07'!addSlot	"Añade un nuevo slot"	self devices add: nil.		self devicesChange: true.! !!PLC_HardwareConfiguration methodsFor: 'devices' stamp: 'EricPernia 11/5/2013 02:11'!removeDeviceAt: index	"Remueve el dispositivo en el índice indicado"	self devices removeAt: index + 1.		self devicesChange: true.! !!PLC_HardwareConfiguration methodsFor: 'devices' stamp: 'EricPernia 11/5/2013 02:12'!removeSlotAt: index	"Remueve el un nuevo slot en el índice dado"	self devices removeAt: index + 1.		self devicesChange: true.! !!PLC_HardwareConfiguration methodsFor: 'devices' stamp: 'EricPernia 11/5/2013 01:41'!slotFor: aDevice	"Devuelve el numero de slot a la dirección fisica pidiendoselo a la configuración de hardware"	^ ( self devices indexOf: aDevice ifAbsent: [ ^ nil ] ) - 1.! !!PLC_HardwareConfiguration methodsFor: 'software configuration' stamp: 'EricPernia 11/8/2013 03:17'!createSoftwareConfiguration	"Crea la Configuración de Software a partir de sus dispositivos"		"Si hubo un cambio de dispositivos, debe crear de nuevo la configuración de software"	self devicesChange		ifTrue: [ 						"Crea la Configuración de Software"			self softwareConfiguration: (				PLC_SoftwareConfiguration 					newFromHardwareConfiguration: self				).							"Avisa que ya no hay mas cambios"			self devicesChange: false.						].	^ self softwareConfiguration.		! !!PLC_HardwareConfiguration methodsFor: 'software configuration' stamp: 'EricPernia 11/5/2013 03:19'!program	"Devuelve la Configuración de Software, si no Existía, la Crea"	self softwareConfiguration		ifNil: [ 			self createSoftwareConfiguration.			].		^ self softwareConfiguration.! !!PLC_HardwareConfiguration methodsFor: 'software configuration' stamp: 'EricPernia 11/8/2013 02:46'!resources	"Devuelve una Ordered Collection de Recursos a partir de sus dispositivos"		^ self devices 		collect: [ :device | 			device resource 			].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_HardwareConfiguration class	instanceVariableNames: ''!!PLC_HardwareConfiguration class methodsFor: 'instance creation' stamp: 'EricPernia 11/8/2013 02:58'!newWithName: aString	"Crea una nueva isntancia con el nombre indicado"	| hardConfig |		hardConfig := self new.	hardConfig hardConfigName: aString.		^ hardConfig.! !PLC_ClassWithIdentifier subclass: #PLC_SoftwareConfiguration	instanceVariableNames: 'hardwareConfiguration declarations resources'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_SoftwareConfiguration commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_SoftwareConfiguration is xxxxxxxxx.Instance Variables	declarations:		<Object>	hardwareConfiguration:		<Object>	resources:		<Object>declarations	- xxxxxhardwareConfiguration	- xxxxxresources	- xxxxx!!PLC_SoftwareConfiguration methodsFor: 'initialize-release' stamp: 'EricPernia 11/8/2013 02:15'!initialize	"Inicializaciones de Recurso"	self resources: OrderedCollection new.		"POR AHORA COMO SOLO HAGO QUE CONFIGURACION TENGA 	SOLO DECLARACIONES DE VARIABLES GLOBALES NO HACE FALTA EL 	OBJETO PLC_SOFT_CONFIG_DECLARATIONS"	self declarations: PLC_VariableCategoryDecl globalVarDecls.! !!PLC_SoftwareConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 16:21'!cCompile	"Llama al compilador y grabador para que genere los archivos C y H."	PLC_CompilerAndWriter uniqueInstance		cCompile: self.! !!PLC_SoftwareConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/1/2013 18:09'!calledPOUs	"Devuelve un Set con las POU que llama cada Configuración de 	Programa de cada uno de sus Recursos."	| pouSet |		pouSet := Set new.		self resources do: [ :each |		pouSet addAll: each calledPOUs.		].	^ pouSet.! !!PLC_SoftwareConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 04:41'!ilCompile	"Devuelve un String con el Configuración de Software Compilada a código IL."	| ilCode |		ilCode := 'CONFIGURATION ' 	, self softConfigName	, '		(* Declaraciones de Configuracion *)'.	self globalVarDecls		ifNotNil: [ 			ilCode := ilCode ,			self globalVarDecls ilCompile , ''.			].		ilCode := ilCode ,'		(* Recursos *)'.	self resources		ifNotNil: [ 			self resources do: [ :each | 				ilCode := ilCode , each ilCompile , ''.				].			].	ilCode := ilCode ,'		END_CONFIGURATION'.	^ ilCode.	! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:49'!declarations		^ declarations! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:49'!declarations: anObject		declarations := anObject! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 04:36'!globalVarDecls		^ self declarations! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:49'!hardwareConfiguration		^ hardwareConfiguration! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:49'!hardwareConfiguration: anObject		hardwareConfiguration := anObject! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:49'!resources		^ resources! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:49'!resources: anObject		resources := anObject! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:50'!softConfigName		^ identifier! !!PLC_SoftwareConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:49'!softConfigName: anObject		identifier := anObject! !!PLC_SoftwareConfiguration methodsFor: 'resources' stamp: 'EricPernia 11/7/2013 17:52'!addResource: aResource	"Añade a la Configuración de Software el recurso aResource que le llega como parámetro"	self resources add: aResource.		aResource softwareConfiguration: self.		^ aResource.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_SoftwareConfiguration class	instanceVariableNames: ''!!PLC_SoftwareConfiguration class methodsFor: 'instance creation' stamp: 'EricPernia 11/8/2013 03:10'!newFromHardwareConfiguration: aHardConfig	"Crea una nueva isntancia a partir de la Configuración de Hardware recibida como parámetro"	| softConfig |		"Creo la Configuración de Software"	softConfig := self new.		"Le asigno la Configuración de Hardware a la de Software"	softConfig hardwareConfiguration: aHardConfig.		"Le agrego a  la Configuración de Software los Recursos 	que me provea la Configuración de Hardware"	aHardConfig resources do: [  :each |		softConfig addResource: each.		].		softConfig softConfigName: 		aHardConfig hardConfigName.		^ softConfig.	! !Object subclass: #PLC_CalledPOU	instanceVariableNames: 'standardFunctions userFunctions standardFunctionBlocks userFunctionBlocks standardPrograms userPrograms'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_CalledPOU commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_CalledPOU is xxxxxxxxx.Instance Variables	standardFunctionBlocks:		<Object>	standardFunctions:		<Object>	standardPrograms:		<Object>	userFunctionBlocks:		<Object>	userFunctions:		<Object>	userPrograms:		<Object>standardFunctionBlocks	- xxxxxstandardFunctions	- xxxxxstandardPrograms	- xxxxxuserFunctionBlocks	- xxxxxuserFunctions	- xxxxxuserPrograms	- xxxxx!!PLC_CalledPOU methodsFor: 'add - remove' stamp: 'EricPernia 11/15/2013 16:38'!addStandardFunctionBlocks: aPOUDeclsOrderedCollection	"Añade las declaraciones que le llegan como una Ordered Collection"		self standardFunctionBlocks addAll: aPOUDeclsOrderedCollection asSet.! !!PLC_CalledPOU methodsFor: 'add - remove' stamp: 'EricPernia 11/15/2013 18:25'!addStandardFunctions: aPOUDeclsOrderedCollection	"Añade las declaraciones que le llegan como una Ordered Collection"		self standardFunctions addAll: aPOUDeclsOrderedCollection asSet.! !!PLC_CalledPOU methodsFor: 'add - remove' stamp: 'EricPernia 11/15/2013 16:38'!addUserFunctionBlocks: aPOUDeclsOrderedCollection	"Añade las declaraciones que le llegan como una Ordered Collection"		self userFunctionBlocks addAll: aPOUDeclsOrderedCollection asSet.! !!PLC_CalledPOU methodsFor: 'add - remove' stamp: 'EricPernia 11/15/2013 16:39'!addUserFunctions: aPOUDeclsOrderedCollection	"Añade las declaraciones que le llegan como una Ordered Collection"		self userFunctions addAll: aPOUDeclsOrderedCollection asSet.! !!PLC_CalledPOU methodsFor: 'add - remove' stamp: 'EricPernia 11/8/2013 12:56'!addUserPrograms: aPOUCallsOrderedCollection	"Añade las declaraciones de programas a ártir de los llamados a programas que	 le llegan como una Ordered Collection"		| pouDecls |		pouDecls := aPOUCallsOrderedCollection collect: [ :each | 		each declaration.		].	self userPrograms addAll: pouDecls asSet.! !!PLC_CalledPOU methodsFor: 'initialize-release' stamp: 'EricPernia 11/8/2013 12:43'!initialize	"Inicializo las colecciones, son set para evitar repetidos."	standardFunctions := Set new.	userFunctions := Set new.		standardFunctionBlocks := Set new.	userFunctionBlocks := Set new.		standardPrograms := Set new.	userPrograms := Set new.! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!standardFunctionBlocks		^ standardFunctionBlocks! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!standardFunctionBlocks: anObject		standardFunctionBlocks := anObject! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!standardFunctions		^ standardFunctions! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!standardFunctions: anObject		standardFunctions := anObject! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!standardPrograms		^ standardPrograms! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!standardPrograms: anObject		standardPrograms := anObject! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!userFunctionBlocks		^ userFunctionBlocks! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!userFunctionBlocks: anObject		userFunctionBlocks := anObject! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!userFunctions		^ userFunctions! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!userFunctions: anObject		userFunctions := anObject! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!userPrograms		^ userPrograms! !!PLC_CalledPOU methodsFor: 'accessing' stamp: 'EricPernia 11/8/2013 12:43'!userPrograms: anObject		userPrograms := anObject! !PLC_ClassWithIdentifier subclass: #PLC_TaskConfiguration	instanceVariableNames: 'inputDecls inputAssignments programConfigurations resource'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_TaskConfiguration commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_TaskConfiguration is xxxxxxxxx.Instance Variables	inputAssignments:		<Object>	inputDecls:		<Object>	programConfigurations:		<Object>	resource:		<Object>inputAssignments	- xxxxxinputDecls	- xxxxxprogramConfigurations	- xxxxxresource	- xxxxx!!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 16:34'!cCompile	"Devuelve la definicion de función de Tarea de freeRTOS en lenguaje C.		Ejemplo:/*-----------------------------------------------------------*/void vPeriodicTask_TareaEj(void *pvParameters){	portTickType xLastWakeTime;	/* La variable xLastWakeTime necesita ser inicializada con el conteo actual	de ticks. Nótese que este es el único momento que se accede a esta variable.	De aquí en adelante xLastWakeTime es manejada automáticamente por la función	API vTaskDelayUntil(). */	xLastWakeTime = xTaskGetTickCount(); 	// xTaskGetTickCount() es la función API del S.O.  	// freeRTOS para obtener el conteo de Ticks del Sistema.		/* DECLARACIÓN DE INSTANCIAS DE LOS PROGRAMAS ASOCIADOS	PLC_P_Struct_ProgEj es un tipo de datos estructurado	que contiene todas las declaraciones de variables de	ProgEj como miembros */	PLC_P_Struct_ProgEj ProgEj_Instance;	/* Cada tarea del S.O. contiene un bucle infinito */	for( ;; )	{			/* Leo las entradas físicas */		entradas = Read_IN();		/* Convierto de Uint8_t a campo de bits*/		I = Convert_Uint8_t_2_PLC_1ByteRegister(entradas);						/* LLAMADOS A PROGRAMAS ASOCIADOS A LA TAREA PLC */				// Lectura de parámetros de entrada		ProgEj_Instance.Ent1 = I0.b0;		ProgEj_Instance.Ent2 = I0.b1;				// Llamo al Programa		ProgEj(&ProgEj_Instance);				// Escritura de parámetros de salida		Q0.b0 = ProgEj_Instance.Sal;						/* Escritura de salidas físicas */		salidas = Convert_PLC_Digital_PORT_8_2_Uint8_t(Q0);		Write_OUT(salidas);						/* Trarea periódica cada 20ms utilizando la API 		del S.O. freeRTOS de Dealay Periódico. 		Se pone el parámetro en ms / portTICK_RATE_MS. */		vTaskDelayUntil(&xLastWakeTime, (20/portTICK_RATE_MS));			}}"		| task |		task := '	/*---------------------------------------------------------------------------------------------------------*/void vPeriodicTask_', self taskName,'(void *pvParameters){	portTickType xLastWakeTime;	/* La variable xLastWakeTime necesita ser inicializada con el conteo actual	de ticks. Nótese que este es el único momento que se accede a esta variable.	De aquí en adelante xLastWakeTime es manejada automáticamente por la función	API vTaskDelayUntil(). */	xLastWakeTime = xTaskGetTickCount(); 	/* xTaskGetTickCount() es la función API del S.O. freeRTOS para obtener el conteo 	de Ticks del Sistema.*/		/* DECLARACIONES DE INSTANCIAS DE LOS PROGRAMAS ASOCIADOS A LA TAREA */		'.	"Declaraciones de variables de instancia de Programa sin valor inicial"	 self programConfigurations do: [ :each |		task := task , each instanceOperand declaration cCompileWithoutInitialValue , ';			'.		 ].		task := task , '	/* Cada tarea del S.O. freeRTOS contiene un bucle infinito */		for( ;; )	{			/* Lectura de las entradas físicas */		entradas = Read_IN();		I0 = Convert_Uint8_t_2_PLC_1ByteRegister(entradas);						/* LLAMADOS A PROGRAMAS ASOCIADOS A LA TAREA PLC */		' .			"Llamados a Programa compilados a C"	 self programConfigurations do: [ :each |		task := task , each cCompile , '		'.		 ].			task := task , 			'		/* Escritura de salidas físicas */		salidas = Convert_PLC_1ByteRegister_2_Uint8_t( Q0 );		Write_OUT(salidas);						/* Trarea periódica cada Xms utilizando la API del S.O. freeRTOS de Dealay 		Periódico. Se pone el parámetro en ms / portTICK_RATE_MS. */		vTaskDelayUntil( &xLastWakeTime, ( '			, self taskCInterval 		, ' / portTICK_RATE_MS ) );			}}'.							^ task.			! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/1/2013 20:41'!cCompilePrototype	"Devuelve el prototipo de función de Tarea de freeRTOS en lenguaje C.		Ejemplo:	void vPeriodicTask_TareaEj(void *);		"		| task |		task := '		void vPeriodicTask_'	, self taskName	, '(void *);'.			^ task.			! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/1/2013 20:00'!cPOUName	"Devuelve el nombre en C de la POU"		"Ejemplo: 		PLC_F_ADD_INT"		^ self declaration cPOUName.! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 16:31'!cTaskCreate	"Devuelve la API de creación de esta Tarea de freeRTOS en lenguaje C.		Ejemplo:	void vPeriodicTask_TareaEj(void *);		"		| task |		task := '		/* Crea una instancia de la tarea periodica con prioridad X. */	xTaskCreate( vPeriodicTask_'	, self taskName	, ', "Tarea periódica '		, self taskName		, '", 512, NULL, '		, self taskCPriority 		, ', NULL );'.			^ task.			! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/7/2013 23:31'!ilCompile	"Compila el elemento IL Configuración de Tarea a IL."	"Por ejemplo:			TASK TareaEj ( 	INTERVAL := T#50 ms , PRIORITY := 1) ;'			"		^ '			TASK ' 		, self taskName , ' ( ' 		,  ( self inputAssignments at: 2 ) ilCompile , 'ms , ' 		,  ( self inputAssignments at: 3 ) ilCompile , ' ) ;'.			! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/1/2013 20:00'!instanceName	"Devuelve el nombre de la Instancia de la POU"		^ self instance identifier.! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/1/2013 20:00'!pouName	"Devuelve el identificador de la POU"		^ self declaration identifier.! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/1/2013 22:30'!taskCInterval	"Devuelve el valor de Periodicidad de la Tarea c como String."		| plcInterval |		plcInterval := (self inputAssignments at: 2) actualArgument dataValue.		^ plcInterval asString.! !!PLC_TaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/7/2013 19:26'!taskCPriority	"Devuelve el valor de prioridad de la Tarea c como String."		"Las prioridades de TASK CONFIGURATION de PLC pueden ir de 0 (más prioritaria)	a 9 (menor prioridad). Es al revés que en las Tareas freeRTOS. 	Guardo la Prioridad 0 (la menor prioridad en freeRTOS) para la tarea cíclica.	Las demas pueden tener de 1 a 9.	Entonces: PrioridadFreeRTOS = 10 - PrioridadIEC para las tareas periódicas."		| plcPriority |		plcPriority := (self inputAssignments at: 3) actualArgument dataValue.		^ ( 10 - plcPriority ) asString.! !!PLC_TaskConfiguration methodsFor: 'initialize-release' stamp: 'EricPernia 11/5/2013 12:43'!createInitialInputAssignments	"Crea las asignaciones iniciales a las variables de entrada de la Tarea"	self inputAssignments: OrderedCollection new.		self inputAssignments add: 			( PLC_InputAssignment				newWithFormalParameter: 					( PLC_Variable 						newWithDeclaration: (self inputDecls at: 1)						andDataValue: nil )				andActtualArgument:					( PLC_Literal newWithDataType: PLC_DataType Bool andDataValue: false )			).			self inputAssignments add: 			( PLC_InputAssignment				newWithFormalParameter: 					( PLC_Variable 						newWithDeclaration: (self inputDecls at: 2)						andDataValue: nil )				andActtualArgument:					( PLC_Literal newWithDataType: PLC_DataType Time andDataValue: 0 )			).			self inputAssignments add: 			( PLC_InputAssignment				newWithFormalParameter: 					( PLC_Variable 						newWithDeclaration: (self inputDecls at: 3)						andDataValue: nil )				andActtualArgument:					( PLC_Literal newWithDataType: PLC_DataType UInt andDataValue: 0 )			).	! !!PLC_TaskConfiguration methodsFor: 'initialize-release' stamp: 'EricPernia 11/5/2013 12:56'!createInputVarDecls	"Crea las asignaciones iniciales a las variables de entrada de la Tarea"	self inputDecls: PLC_VariableCategoryDecl inputVarDecls.		self inputDecls add: ( 	PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Bool		andInitialValue: true 		andIdentifier: 'SINGLE' 	).		self inputDecls add: ( 	PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType Time		andInitialValue: 0 		andIdentifier: 'INTERVAL' 	).		self inputDecls add: ( 	PLC_SymbolicVariableDecl 		newWithDataType: PLC_DataType UInt		andInitialValue: 0 		andIdentifier: 'PRIORITY' 	).! !!PLC_TaskConfiguration methodsFor: 'initialize-release' stamp: 'EricPernia 11/1/2013 22:17'!initialize	"Inicializaciones"	self createInputVarDecls.		self createInitialInputAssignments.		self programConfigurations: OrderedCollection new.! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:04'!inputAssignments		^ inputAssignments! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:04'!inputAssignments: anObject		inputAssignments := anObject! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:04'!inputDecls		^ inputDecls! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:04'!inputDecls: anObject		inputDecls := anObject! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:52'!programConfigurations		^ programConfigurations! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:52'!programConfigurations: anObject		programConfigurations := anObject! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 18:02'!resource		^ resource! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 18:02'!resource: anObject		resource := anObject.! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:32'!taskName		^ self identifier! !!PLC_TaskConfiguration methodsFor: 'accessing' stamp: 'EricPernia 11/1/2013 20:33'!taskName: aString		self identifier: aString.! !!PLC_TaskConfiguration methodsFor: 'program configurations' stamp: 'EricPernia 11/8/2013 16:40'!addProgConfig: aProgConfig	"Añade a la Tarea la Configuración de programa aProgConfig que le llega como parámetro"	| set |		"Con el set evito que una tarea tenga configuraciones de programas repetidas"	set := self programConfigurations asSet.	set add: aProgConfig.	self programConfigurations: set asOrderedCollection.		aProgConfig task: self.		^ aProgConfig.! !!PLC_TaskConfiguration methodsFor: 'program configurations' stamp: 'EricPernia 11/7/2013 17:58'!removeProgConfig: aProgConfig	"Remueve de la Tarea la Configuración de programa aProgConfig que le llega como parámetro"	self programConfigurations remove: aProgConfig.		aProgConfig task: nil.	^ aProgConfig.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_TaskConfiguration class	instanceVariableNames: ''!!PLC_TaskConfiguration class methodsFor: 'instance creation' stamp: 'EricPernia 11/1/2013 21:22'!newWithName: aTaskName	"Crea una nueva Configuracción de Tarea con nombre aTaskName."	| taskConfig |		taskConfig := self new.		taskConfig taskName: aTaskName.	^ taskConfig.! !Object subclass: #PLC_DevicePLC	instanceVariableNames: 'hardwareConfiguration deviceName digitalInputs digitalOutputs analogInputs analogOutputs cpu'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_DevicePLC commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_DevicePLC is xxxxxxxxx.Instance Variables	analogInputs:		<Object>	analogOutputs:		<Object>	cpu:		<Object>	deviceName:		<Object>	digitalInputs:		<Object>	digitalOutputs:		<Object>	hardwareConfiguration:		<Object>analogInputs	- xxxxxanalogOutputs	- xxxxxcpu	- xxxxxdeviceName	- xxxxxdigitalInputs	- xxxxxdigitalOutputs	- xxxxxhardwareConfiguration	- xxxxx!!PLC_DevicePLC methodsFor: 'initialize-release' stamp: 'EricPernia 5/31/2013 01:41'!initialize	"comment stating purpose of message"	| temporary variable names |		deviceName  := ''.		digitalInputs := OrderedCollection new.	digitalOutputs := OrderedCollection new.		analogInputs := OrderedCollection new.	analogOutputs := OrderedCollection new.! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!analogInputs	^ analogInputs! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!analogInputs: anObject	analogInputs := anObject! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!analogOutputs	^ analogOutputs! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!analogOutputs: anObject	analogOutputs := anObject! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!cpu	^ cpu! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!cpu: anObject	cpu := anObject! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!deviceName	^ deviceName! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!deviceName: anObject	deviceName := anObject! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!digitalInputs	^ digitalInputs! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!digitalInputs: anObject	digitalInputs := anObject! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!digitalOutputs	^ digitalOutputs! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 01:32'!digitalOutputs: anObject	digitalOutputs := anObject! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 00:43'!hardwareConfiguration	^ hardwareConfiguration! !!PLC_DevicePLC methodsFor: 'accessing' stamp: 'EricPernia 11/5/2013 00:44'!hardwareConfiguration: anObject	hardwareConfiguration := anObject! !!PLC_DevicePLC methodsFor: 'collections' stamp: 'EricPernia 11/5/2013 00:42'!includesDigitalInput: aString.	"Devuelve true si contiene la entrada digital que recibe como parametro.	Este metodo se utiliza para validar los actualArguments"	^ self digitalInputs anySatisfy: [ :each |		each ilCompile = aString.		].! !!PLC_DevicePLC methodsFor: 'collections' stamp: 'EricPernia 11/5/2013 00:42'!includesDigitalOutput: aString.	"Devuelve true si contiene la salida digital que recibe como parametro	Este metodo se utiliza para validar los actualArguments"	^ self digitalOutputs anySatisfy: [ :each |		each ilCompile = aString.		].! !!PLC_DevicePLC methodsFor: 'physical address' stamp: 'EricPernia 11/5/2013 00:47'!slot	"Devuelve el numero de slot a la dirección fisica pidiendoselo a la configuración de hardware"	self hardwareConfiguration		ifNil: [			^ 0.			]		ifNotNil: [			^ self hardwareConfiguration slotFor: self.			].		 	! !!PLC_DevicePLC methodsFor: 'resource' stamp: 'EricPernia 11/8/2013 04:03'!resource	"Devuelve el recurso que crea si tiene CPU"	| res |		self cpu 		ifNil: [ 			^ nil.			]		ifNotNil: [ 						"Creo el recurso y le asigno el porcesador y nombre, 			la config de soft se la agrega la config cuando hace add"			res := PLC_Resource 				newWithName: self deviceName 				andSoftConfig: nil 				andProcessor: self cpu.				"res := PLC_Resource 	newWithName: 'RecursoEj' 	andSoftConfig: nil 	andProcessor: PLC_CPU lpc1769."							"Agrego las Declaraciones de las variables Globales de 			Entradas digitales (%I0) del PLC al RECURSO"			self digitalInputs do: [ :each |				res globalVarDecls add: ( 					PLC_LocatedVariableDecl 						newWithDataType: PLC_DataType Bool 						andInitialValue: nil 						andPhysicalAddress: each					).					].							"Agrego las Declaraciones de las variables Globales de 			Salidas digitales (%Q0) del PLC al RECURSO"			self digitalOutputs do: [ :each |				res globalVarDecls add: ( 					PLC_LocatedVariableDecl 						newWithDataType: PLC_DataType Bool 						andInitialValue: nil 						andPhysicalAddress: each					).					].							^ res.			]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_DevicePLC class	instanceVariableNames: ''!!PLC_DevicePLC class methodsFor: 'instance creation' stamp: 'EricPernia 11/8/2013 04:09'!plericLPC1769	"Devuelve una instancia de PLC PLeriC"	| devicePLC |		devicePLC := self new.		devicePLC deviceName: 'PLeriC_LPC1769'.	devicePLC cpu: PLC_CPU lpc1769.		"Entradas Digitales"		devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 0 ).	devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 1 ).	devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 2 ).	devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 3 ).	devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 4 ).	devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 5 ).	devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 6 ).	devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'X' index: 7 ).			"devicePLC digitalInputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'I' sizePrefix: 'B' index: 0 )."			"Salidas Digitales"		devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 0 ).	devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 1 ).	devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 2 ).	devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 3 ).	devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 4 ).	devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 5 ).	devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 6 ).	devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'X' index: 7 ).			"devicePLC digitalOutputs add: 		( PLC_DevicePhysicalAddress newWithDevice: devicePLC locationPrefix: 'Q' sizePrefix: 'B' index: 0 )."		^ devicePLC.! !!PLC_DevicePLC class methodsFor: 'instance creation' stamp: 'EricPernia 11/8/2013 02:51'!voidDeviceWithNumber: aNumber	"Devuelve un dispositivo vacio para crear la ranura vacia con el numero que le llega como parametro"	| devicePLC |		devicePLC := self new.		devicePLC deviceName: 'Ranura_' , aNumber asString.		^ devicePLC.! !Object subclass: #PLC_Resource_Declarations	instanceVariableNames: 'resourceDecl userDataTypesDecls userVarDecls'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_Resource_Declarations commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Resource_Declarations is xxxxxxxxx.Instance Variables	resourceDecl:		<Object>	userDataTypesDecls:		<Object>	userVarDecls:		<Object>resourceDecl	- xxxxxuserDataTypesDecls	- xxxxxuserVarDecls	- xxxxx!!PLC_Resource_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:19'!resourceDecl		^ resourceDecl! !!PLC_Resource_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:19'!resourceDecl: anObject		resourceDecl := anObject! !!PLC_Resource_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:16'!userDataTypesDecls	^ userDataTypesDecls! !!PLC_Resource_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:16'!userDataTypesDecls: anObject	userDataTypesDecls := anObject! !!PLC_Resource_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:16'!userVarDecls		^ userVarDecls! !!PLC_Resource_Declarations methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:16'!userVarDecls: anObject		userVarDecls := anObject! !!PLC_Resource_Declarations methodsFor: 'initialize-release' stamp: 'EricPernia 11/7/2013 20:16'!initialize	"Inicializa las Colecciones de declaraciones de una POU"	"Declaraciones de Tipos de Datos"	userDataTypesDecls := OrderedCollection new.		"Declaraciones de Variables"	userVarDecls := OrderedCollection new.! !!PLC_Resource_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/7/2013 20:18'!externVarDecls	"Devuelve sus declaraciones de variables VAR_EXTERN"	^ self userVarDecls at: 2.	"globalVarDeclsexternalVarDecls"! !!PLC_Resource_Declarations methodsFor: 'variable declarations' stamp: 'EricPernia 11/7/2013 20:17'!globalVarDecls	"Devuelve sus declaraciones de variables VAR_GLOBAL"	^ self userVarDecls at: 1.	"globalVarDeclsexternalVarDecls"! !!PLC_Resource_Declarations methodsFor: 'instance' stamp: 'EricPernia 11/7/2013 20:22'!structureDeclaration	"Declaracion de tipo de dato estructurado."	| struct |	struct := PLC_StructureDecl 		newWithIdentifier: self structureDeclarationIdentifier.	"AÑADO LAS VARIABLES A LA ESTRUCTURA"	"Variables Globales"	self globalVarDecls do: [ :each |		struct add: each.		].		"Variables Externas"	self externVarDecls do: [ :each |		struct add: each.		].	 		^ struct.! !!PLC_Resource_Declarations methodsFor: 'instance' stamp: 'EricPernia 11/7/2013 20:22'!structureDeclarationIdentifier	"Identificador de tipo de dato estructurado."	^ 'Struct_' , self resourceDecl identifier.! !!PLC_Resource_Declarations methodsFor: 'instance' stamp: 'EricPernia 11/7/2013 20:16'!typeDeclaration	"Declaracion de tipo de dato derivado."	| type |	type := PLC_TypeDecl 		newWithDataType: self structureDeclaration		andIdentifier: self typeDeclarationIdentifier.	^ type.! !!PLC_Resource_Declarations methodsFor: 'instance' stamp: 'EricPernia 11/8/2013 02:17'!typeDeclarationIdentifier	"Identificador de tipo de dato estructurado."	^ 'PLC_' , self resourceDecl pouTypeAcronym , '_' , self structureDeclarationIdentifier.! !!PLC_Resource_Declarations methodsFor: 'find' stamp: 'EricPernia 11/7/2013 20:16'!includeVarDeclWithIdentifier: aVariableIdentifier	"Busca si tiene en alguna de sus declaraciones una delaracion 	de variable con el identificador aVariableIdentifier"	^ self userVarDecls includeVarDeclWithIdentifier: aVariableIdentifier.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Resource_Declarations class	instanceVariableNames: ''!!PLC_Resource_Declarations class methodsFor: 'instance creation' stamp: 'EricPernia 11/7/2013 20:29'!newWithResourceDeclaration: aResourceDecl	"Devuelve una nueva instancia con el recurso que le llega como parametro"	| decls |	decls := self new.		"Categorías de Declaraciones de Variables"	decls userVarDecls add: PLC_VariableCategoryDecl globalVarDecls.	decls userVarDecls add: PLC_VariableCategoryDecl externVarDecls.		"Le agrego el Recurso"	decls resourceDecl: aResourceDecl.		^ decls.! !Object subclass: #PLeriC	instanceVariableNames: ''	classVariableNames: 'pou'	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLeriC commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLeriC is xxxxxxxxx.Instance Variables!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLeriC class	instanceVariableNames: ''!!PLeriC class methodsFor: 'class initialization' stamp: 'EricPernia 11/26/2013 20:16'!initialize	"Esta clase inicializa todas las que usa el proyecto"	super initialize."			OS PROCESS			========="	"Ejecutar una vez"	Gofer it 	      squeaksource: 'MetacelloRepository';  	     package: 'ConfigurationOfOSProcess';   	    load.	"Ejecutar una vez"	(ConfigurationOfOSProcess project version: #stable) load.	"Ejecutar una vez"	OSProcess thisOSProcess stdOut.	"Ejecutar cada vez que quiero abrir algo, por ejemplo:"	"OSProcess command: 'calc'.""			 PARSER			======"	"Pharo Smalltalk is the main development environment of PetitParser. 	To load the core library evaluate the following code:"	Gofer new	    renggli: 'petit'; 	    package: 'PetitParser';	    load.	"To get the full toolset, including a dedicated editor and some 	experimental tools, use the following Metacello script: 	(No funciona en Pharo 1.3)"	"Gofer new	    renggli: 'petit';	    package: 'ConfigurationOfPetitParser';	    load.	(Smalltalk at: #ConfigurationOfPetitParser)	    perform: #loadDefault.""			INSTANCIAS UNICAS			============="	"Clase con identificador"	"PLC_ClassWithIdentifier initialize."	"Compilador y grabador (usa PLC_FileSystem y OSProcess)"	PLC_CompilerAndWriter clearInstance.	"Es el que usa FileStream para finalmente crear los 	archivos .C, .H y .IL"	PLC_FileSystem clearInstance.	"Tipos de datos"	PLC_DataType clearTypes.	"PLC_DataType createDataTypes."	"Funciones y Bloques de Función"	PLC_Function clearFunctions.	PLC_Function createStdFunctions.	PLC_FunctionBlock clearFunctionBlocks.	PLC_FunctionBlock createStdFunctionBlocks.	PLC_Program clearPrograms.	"Elementos de lenguajes gráficos"	"PLC_Element initialize."	PLC_Element clearElements.	"PLC_GraphicFunctionBlockCall initialize.	PLC_VerticalLink initialize."	"Elementos IL"	"PLC_IL_Modifiers initialize."	PLC_IL_Modifiers clearInstances.	"Morphs de los elementos gráficos"	PLC_GraphicElementProperties clearInstance.	"Estados de los Morphs de los elementos gráfico"	PLC_Aligns clearAligns.	PLC_GraphicElementState clearStates.	"Bibliotecas"	PLC_Libraries clearInstance.! !!PLeriC class methodsFor: 'class initialization' stamp: 'EricPernia 5/17/2014 02:20'!initializeGUI	"Esta clase inicializa la parte visual del proyecto"	"GUI - Iconos de escritorio"	PLC_DesktopIcon blueTheme.	PLC_DesktopIcon blackTheme.	PLC_DesktopIcon screen1920x1080.	PLC_DesktopIcon screen800x600.	PLC_DesktopIcon createIcons.		"CAMBIAR FONDO EN PARO"	World backgroundImage: (ImageReadWriter formFromFileNamed: 'IDE4PLC_files/GUI_Images/background.jpg') layout: #scaled.	"CANCELAR MENU WORD SIGUE ANDANDO CON ESC, HAY QUE REESCRIBIR EL METODO""PasteUpMorph>>handlesMouseDown: evt	^false"	"^false" "ERIC: Lo puedo poner a flase para que no activen el menu word. Viene en true"	! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/18/2013 16:49'!bootLPCLink	PLC_CompilerAndWriter uniqueInstance bootLPCLink.! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/19/2013 15:47'!cCompileConfigSoft	(self createConfigSoftWithPOU: pou ) cCompile.! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/18/2013 16:15'!createConfigSoftWithPOU: aPOU	| programitaDecl  pouCall categoriaDeInstancia declDeInstancia operandoInstancia 	tarea proyecto configHard configSoft recurso |	programitaDecl := aPOU.	"--------------------------------------------------------------------------------------------------------------"					"PROYECTO					------------------"	proyecto := PLC_Project newWithName: 'Trabajo_Final'.	proyecto libraries.	proyecto hardwareConfigurations.	proyecto projectName.	proyecto identifier.	proyecto addHardwareConfiguration: (		PLC_HardwareConfiguration 			newWithName: 'Config_Ejemplo'		).			"proyecto explore."					"--------------------------------------------------------------------------------------------------------------"				"CONFIGURACION DE HARDWARE DESDE PROYECTO				------------------------------------------------------------------------------"	configHard := proyecto hardwareConfigurations first.	configHard addDevice: PLC_DevicePLC plericLPC1769 at: 0.	"--------------------------------------------------------------------------------------------------------------"				"CONFIGURACION DE SOFTWARE DESDE LA DE HARDWARE				----------------------------------------------------------------------------------------"	"Para crear y almacenar una Configuracioón de software en la de hardware"	configSoft := configHard createSoftwareConfiguration.	"--------------------------------------------------------------------------------------------------------------"				"RECURSO DESDE LA CONFIGURACION DE SOFTWARE				-------------------------------------------------------------------------------"	recurso := configSoft resources first.	recurso ilCompile.					"--------------------------------------------------------------------------------------------------------------"			"CREO UNA TAREA PERIODICA			 -------------------------------------------"					tarea := PLC_TaskConfiguration newWithName: 'TareaPer'.	"--------------------------------------------------------------------------------------------------------------"			"DECLARACION DE VARIABLE DE INSTANCIA (del Programa) EN RECURSO			 -----------------------------------------------------------------------------------------------------------"				"Obtengo la Categoría VAR_GLOBAL en Recurso"	categoriaDeInstancia := recurso globalVarDecls.	"Es la declaracion de variable de instancia que voy a poner en la lista de VAR_GLOBAL en Recurso"	declDeInstancia := programitaDecl instanceDecl.	"Agrego la variable a la categoria, Declara la instancia en el Recurso"	categoriaDeInstancia add: declDeInstancia.	"CREACION DE OPERANDO VARIABLE INSTANCIA A PARTIR DE SU DECLARACION:"	"Creo un operando instancia desde la declaracion. ESTO LO VA A TENER QUE HACER EL PARSER EN IL"	operandoInstancia :=  declDeInstancia operand.			"--------------------------------------------------------------------------------------------------------------"			"CREO UNA CONFIGURACION DE (o llamado a) PROGRAMA			 --------------------------------------------------------------------------------------"	"Le asigno la instancia creada"		pouCall := PLC_ProgramConfiguration 		newFromDeclaration: programitaDecl 		andInstanceOperand: operandoInstancia.					"--------------------------------------------------------------------------------------------------------------"			"AÑADO LAS CONFIG DE TAREA y PROGRAMA ALRECURSO 				-------------------------------------------------------------------------------------"										"Agrego al recurso configuraciones de Tareas y Programas"		recurso addProgConfig: pouCall.	recurso addTaskConfig: tarea.	"--------------------------------------------------------------------------------------------------------------"			"CONFIGURO LA TAREA PERIODICA			 ---------------------------------------------------"					"PRIORIDAD"	(tarea inputAssignments at: 3) actualArgument dataValue: 9.	"PERIODICIDAD cada 20 ms"	(tarea inputAssignments at: 2) actualArgument dataValue: 20. 	"--------------------------------------------------------------------------------------------------------------"			"CONFIGURO LA CONFIG DE PROGRAMA			 ---------------------------------------------------------"			"Asigno una las entradas del llamado a programa con direcciones fisicas  %IX0.0"				(pouCall inputAssignments at: 1) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 1) 					andDataValue: nil				).	"globalVarDecls at: 1 = %I0.0"				(pouCall inputAssignments at: 2) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 2) 					andDataValue: nil				).			(pouCall inputAssignments at: 3) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 3) 					andDataValue: nil				).			(pouCall inputAssignments at: 4) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 4) 					andDataValue: nil				).			(pouCall inputAssignments at: 5) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 5) 					andDataValue: nil				).			(pouCall inputAssignments at: 6) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 6) 					andDataValue: nil				).			(pouCall inputAssignments at: 7) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 7) 					andDataValue: nil				).			(pouCall inputAssignments at: 8) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 8) 					andDataValue: nil				).	"Asigno una las salidas del llamado a programa con direcciones fisicas  %QX0.0"				(pouCall outputAssignments at: 1) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 9) 					andDataValue: nil				).	"recurso globalVarDecls at: 9 = %Q0.0"			(pouCall outputAssignments at: 2) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 10) 					andDataValue: nil				).				(pouCall outputAssignments at: 3) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 11) 					andDataValue: nil				).				(pouCall outputAssignments at: 4) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 12) 					andDataValue: nil				).				(pouCall outputAssignments at: 5) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 13) 					andDataValue: nil				).				(pouCall outputAssignments at: 6) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 14) 					andDataValue: nil				).				(pouCall outputAssignments at: 7) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 15) 					andDataValue: nil				).				(pouCall outputAssignments at: 8) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 16) 					andDataValue: nil				).		"--------------------------------------------------------------------------------------------------------------"			"ASOCIO CONFIG DE TAREA CON CONFIG PROGRAMA			-------------------------------------------------------------------------------"				"Añado la configuracion de programa o llamado a programa a la tarea (asociacion)"	tarea addProgConfig: pouCall.	"--------------------------------------------------------------------------------------------------------------"	^ configSoft.		! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/19/2013 16:06'!createProgDecl	| programitaDecl |	"Acá hago de cuenta que toque el ícono 'Nueva POU'  y elegí PROGRAMA" 	programitaDecl := PLC_Program		newWithName: 'MAIN_PROG' 		andDataType: PLC_DataType Bool.	"y cuerpo en lenguaje Ladder. El cuerpo añade una network automaticamente"	programitaDecl pouBody: (PLC_LadderBody newWithPOU: programitaDecl).	"Agrego una declaracion de variable de entrada. 	Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E0' 		).		"Agrego una declaracion de variable de entrada. Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E1' 		).		"Agrego una declaracion de variable de entrada. Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E2' 		).		"Agrego una declaracion de variable de entrada. Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E3' 		).		"Agrego una declaracion de variable de entrada. Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E4' 		).		"Agrego una declaracion de variable de entrada. Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E5' 		).		"Agrego una declaracion de variable de entrada. Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E6' 		).		"Agrego una declaracion de variable de entrada. Cuando hace add le agrega su categoría automaticamente"	programitaDecl inputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'E7' 		).										"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S0' 		).						"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S1' 		).						"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S2' 		).		"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S3' 		).		"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S4' 		).		"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S5' 		).		"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S6' 		).		"Agrego una declaracion de variable de salida"	programitaDecl outputVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'S7' 		).	"Agrego una declaracion de variable temporal"	programitaDecl tempVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Bool			andInitialValue: nil 			andIdentifier: 'MEM' 		).	"Agrego una declaracion de variable temporal"	programitaDecl tempVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Time			andInitialValue: nil 			andIdentifier: 'A' 		).		"Agrego una declaracion de variable temporal"	programitaDecl tempVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Time			andInitialValue: nil 			andIdentifier: 'B' 		).	"Agrego una declaracion de variable temporal"	programitaDecl tempVarDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Time			andInitialValue: nil 			andIdentifier: 'C' 		).					"Agrego una declaracion de variable interna persistente 'ACC = Acumulador' "	programitaDecl varDecls add: ( 		PLC_SymbolicVariableDecl 			newWithDataType: PLC_DataType Time			andInitialValue: nil 			andIdentifier: 'ACC' 		).	^ programitaDecl.		! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/18/2013 16:35'!createProyectWithPOU: aPOU	| programitaDecl  pouCall categoriaDeInstancia declDeInstancia operandoInstancia 	tarea proyecto configHard configSoft recurso |	programitaDecl := aPOU.	"--------------------------------------------------------------------------------------------------------------"					"PROYECTO					------------------"	proyecto := PLC_Project newWithName: 'Trabajo_Final'.	proyecto libraries.	proyecto hardwareConfigurations.	proyecto projectName.	proyecto identifier.	proyecto addHardwareConfiguration: (		PLC_HardwareConfiguration 			newWithName: 'Config_Ejemplo'		).			"proyecto explore."					"--------------------------------------------------------------------------------------------------------------"				"CONFIGURACION DE HARDWARE DESDE PROYECTO				------------------------------------------------------------------------------"	configHard := proyecto hardwareConfigurations first.	configHard addDevice: PLC_DevicePLC plericLPC1769 at: 0.	"--------------------------------------------------------------------------------------------------------------"				"CONFIGURACION DE SOFTWARE DESDE LA DE HARDWARE				----------------------------------------------------------------------------------------"	"Para crear y almacenar una Configuracioón de software en la de hardware"	configSoft := configHard createSoftwareConfiguration.	"--------------------------------------------------------------------------------------------------------------"				"RECURSO DESDE LA CONFIGURACION DE SOFTWARE				-------------------------------------------------------------------------------"	recurso := configSoft resources first.	recurso ilCompile.					"--------------------------------------------------------------------------------------------------------------"			"CREO UNA TAREA PERIODICA			 -------------------------------------------"					tarea := PLC_TaskConfiguration newWithName: 'MAIN_TASK'.	"--------------------------------------------------------------------------------------------------------------"			"DECLARACION DE VARIABLE DE INSTANCIA (del Programa) EN RECURSO			 -----------------------------------------------------------------------------------------------------------"				"Obtengo la Categoría VAR_GLOBAL en Recurso"	categoriaDeInstancia := recurso globalVarDecls.	"Es la declaracion de variable de instancia que voy a poner en la lista de VAR_GLOBAL en Recurso"	declDeInstancia := programitaDecl instanceDecl.	"Agrego la variable a la categoria, Declara la instancia en el Recurso"	categoriaDeInstancia add: declDeInstancia.	"CREACION DE OPERANDO VARIABLE INSTANCIA A PARTIR DE SU DECLARACION:"	"Creo un operando instancia desde la declaracion. ESTO LO VA A TENER QUE HACER EL PARSER EN IL"	operandoInstancia :=  declDeInstancia operand.			"--------------------------------------------------------------------------------------------------------------"			"CREO UNA CONFIGURACION DE (o llamado a) PROGRAMA			 --------------------------------------------------------------------------------------"	"Le asigno la instancia creada"		pouCall := PLC_ProgramConfiguration 		newFromDeclaration: programitaDecl 		andInstanceOperand: operandoInstancia.					"--------------------------------------------------------------------------------------------------------------"			"AÑADO LAS CONFIG DE TAREA y PROGRAMA ALRECURSO 				-------------------------------------------------------------------------------------"										"Agrego al recurso configuraciones de Tareas y Programas"		recurso addProgConfig: pouCall.	recurso addTaskConfig: tarea.	"--------------------------------------------------------------------------------------------------------------"			"CONFIGURO LA TAREA PERIODICA			 ---------------------------------------------------"					"PRIORIDAD"	(tarea inputAssignments at: 3) actualArgument dataValue: 9.	"PERIODICIDAD cada 20 ms"	(tarea inputAssignments at: 2) actualArgument dataValue: 20. 	"--------------------------------------------------------------------------------------------------------------"			"CONFIGURO LA CONFIG DE PROGRAMA			 ---------------------------------------------------------"			"Asigno una las entradas del llamado a programa con direcciones fisicas  %IX0.0"				(pouCall inputAssignments at: 1) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 1) 					andDataValue: nil				).	"globalVarDecls at: 1 = %I0.0"				(pouCall inputAssignments at: 2) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 2) 					andDataValue: nil				).			(pouCall inputAssignments at: 3) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 3) 					andDataValue: nil				).			(pouCall inputAssignments at: 4) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 4) 					andDataValue: nil				).			(pouCall inputAssignments at: 5) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 5) 					andDataValue: nil				).			(pouCall inputAssignments at: 6) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 6) 					andDataValue: nil				).			(pouCall inputAssignments at: 7) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 7) 					andDataValue: nil				).			(pouCall inputAssignments at: 8) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 8) 					andDataValue: nil				).	"Asigno una las salidas del llamado a programa con direcciones fisicas  %QX0.0"				(pouCall outputAssignments at: 1) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 9) 					andDataValue: nil				).	"recurso globalVarDecls at: 9 = %Q0.0"			(pouCall outputAssignments at: 2) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 10) 					andDataValue: nil				).				(pouCall outputAssignments at: 3) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 11) 					andDataValue: nil				).				(pouCall outputAssignments at: 4) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 12) 					andDataValue: nil				).				(pouCall outputAssignments at: 5) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 13) 					andDataValue: nil				).				(pouCall outputAssignments at: 6) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 14) 					andDataValue: nil				).				(pouCall outputAssignments at: 7) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 15) 					andDataValue: nil				).				(pouCall outputAssignments at: 8) 			actualArgument: (				PLC_Location 					newWithDeclaration: (recurso globalVarDecls at: 16) 					andDataValue: nil				).		"--------------------------------------------------------------------------------------------------------------"			"ASOCIO CONFIG DE TAREA CON CONFIG PROGRAMA			-------------------------------------------------------------------------------"				"Añado la configuracion de programa o llamado a programa a la tarea (asociacion)"	tarea addProgConfig: pouCall.	"--------------------------------------------------------------------------------------------------------------"	^ proyecto.		! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/18/2013 16:49'!downloadProgram	PLC_CompilerAndWriter uniqueInstance downloadSoftwareConfig.! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/19/2013 16:23'!open	"PARCHASOOO - Se lo manda el icono de biblioteca para resetear la pou"	| pouEditor |	pou := nil.			"Creo un nuevo editor de POU - Para que cargue los cambios en la pou"	pouEditor := PLC_POU_Editor 		newWithPOU: PLeriC pou		andColor: ( Color r: 1 g: 1 b: 1 alpha: 0.5 )  		andBorderColor: Color black 		andTitleColor:  PLC_GraphicElementProperties uniqueInstance programColor 		andTitleName: 'POU: PROGRAMA'.				"Le asigno el editor"	PLC_DesktopIcon pou action: pouEditor.! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/19/2013 16:06'!pou	pou ifNil: [		pou := self createProgDecl.		].		^ pou! !!PLeriC class methodsFor: 'SERVICIOS PARA LA PRESENTACION' stamp: 'EricPernia 11/19/2013 15:44'!pou: obj	pou := obj.! !Object subclass: #PLC_Libraries	instanceVariableNames: 'programDecls funcionBlockDecls functionDecls stdFuncionBlocks stdFuncions ilInstructions ladderElements dataTypes programList ladderElementList functionList functionBlockList'	classVariableNames: 'Instance'	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_Libraries commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Libraries is xxxxxxxxx.Instance Variables	dataTypes:		<Object>	funcionBlockDecls:		<Object>	functionBlockList:		<Object>	functionDecls:		<Object>	functionList:		<Object>	ilInstructions:		<Object>	ladderElementList:		<Object>	ladderElements:		<Object>	programDecls:		<Object>	programList:		<Object>	stdFuncionBlocks:		<Object>	stdFuncions:		<Object>dataTypes	- xxxxxfuncionBlockDecls	- xxxxxfunctionBlockList	- xxxxxfunctionDecls	- xxxxxfunctionList	- xxxxxilInstructions	- xxxxxladderElementList	- xxxxxladderElements	- xxxxxprogramDecls	- xxxxxprogramList	- xxxxxstdFuncionBlocks	- xxxxxstdFuncions	- xxxxx!!PLC_Libraries methodsFor: 'lists' stamp: 'EricPernia 11/17/2013 05:24'!clearLists		functionList := nil.	functionBlockList := nil.	programList := nil.	ladderElementList := nil.! !!PLC_Libraries methodsFor: 'lists' stamp: 'EricPernia 11/18/2013 23:55'!functionBlockList		functionBlockList ifNil: [		functionBlockList :=	PLC_ListSelector			newWithLibrary: PLC_FunctionBlock StdFunctionBlocks			andColor: PLC_GraphicElementProperties uniqueInstance functionBlockHeaderColor			andBorderColor: PLC_GraphicElementProperties uniqueInstance functionBlockColor.		].		^ functionBlockList! !!PLC_Libraries methodsFor: 'lists' stamp: 'EricPernia 11/18/2013 22:33'!functionBlockList: anObject		functionBlockList := anObject! !!PLC_Libraries methodsFor: 'lists' stamp: 'EricPernia 11/17/2013 05:21'!functionList	"Devuelve el controlador de la lista de funciones"	functionList ifNil: [		functionList := PLC_ListSelector 			newWithLibrary: PLC_Function StdFunctions			andColor: PLC_GraphicElementProperties uniqueInstance functionHeaderColor			andBorderColor: PLC_GraphicElementProperties uniqueInstance functionColor.		].		^ functionList! !!PLC_Libraries methodsFor: 'lists' stamp: 'EricPernia 11/17/2013 05:16'!functionList: anObject		functionList := anObject! !!PLC_Libraries methodsFor: 'library' stamp: 'EricPernia 11/5/2013 12:43'!dataTypeLibrary	"Devuelve biblioteca de todos los tipos de datos.	Esto es un array con todos los identificadores de los tipos de datos."	^ PLC_DataType AllDataTypeNameStrings.! !!PLC_Libraries methodsFor: 'library' stamp: 'EricPernia 11/5/2013 12:43'!ilInstructionsLibrary 	"Devuelve la biblioteca de todos las Instrucciones del lenguaje IL.	Esto es un array con todos los identificadores de los tipos de datos."	^ PLC_DataType AllDataTypeNameStrings.! !!PLC_Libraries methodsFor: 'library' stamp: 'EricPernia 11/5/2013 12:43'!ladderElementLibrary 	"Devuelve la biblioteca de todos los Elementos Ladder ( ej: contacto, bobina, VL)	Esto es un array con todos los identificadores de los tipos de datos."	^ PLC_DataType AllDataTypeNameStrings.! !!PLC_Libraries methodsFor: 'library' stamp: 'EricPernia 11/5/2013 12:43'!programDeclationLibrary 	"Devuelve la biblioteca de todos los Programas declarados	Esto es un array con todos los identificadores de los tipos de datos."	^ PLC_DataType AllDataTypeNameStrings.	" Posibles bibliotecas:	------------------------------		funcionBlockDeclationLibrary	functionDeclationLibrary	standardFuncionBlockLibrary 	standardFuncionLibrary 		ilInstructionsLibrary 	ladderElementLibrary 	dataTypeLibrary 		variableDeclarationLibrary 	variableTypesLibrary 	plcDevices	literals"! !!PLC_Libraries methodsFor: 'library' stamp: 'EricPernia 11/5/2013 12:43'!standardFuncionBlockLibrary 	"Devuelve la biblioteca de todos los Bloques de Función estándar.	Esto es un array con todos los identificadores de los tipos de datos."	^ PLC_DataType AllDataTypeNameStrings.! !!PLC_Libraries methodsFor: 'library' stamp: 'EricPernia 11/18/2013 22:29'!standardFuncionLibrary 	"Devuelve la biblioteca de todos las Funciones  estándar.	Esto es un array con todos los identificadores de los tipos de datos."	^ PLC_Function StdFunctions.! !!PLC_Libraries methodsFor: 'initialize-release' stamp: 'EricPernia 11/17/2013 05:17'!initialize 	"Inicializo las librerias"			"	programDecls 		funcionBlockDecls 		functionDecls 	stdFuncionBlocks 	stdFuncions 		ilInstructions 	ladderElements	dataTypes	variableDeclarations	variableTypes	plcDevices	literals	"! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!dataTypes		^ dataTypes! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!dataTypes: anObject		dataTypes := anObject! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!funcionBlockDecls		^ funcionBlockDecls! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!functionDecls		^ functionDecls! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!functionDecls: anObject		functionDecls := anObject! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!ilInstructions		^ ilInstructions! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!ilInstructions: anObject		ilInstructions := anObject! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:25'!ladderElementList		ladderElementList ifNil: [		ladderElementList := PLC_ListSelector			newWithLibrary: PLC_Function StdFunctions			andColor: PLC_GraphicElementProperties uniqueInstance functionBlockHeaderColor			andBorderColor: PLC_GraphicElementProperties uniqueInstance functionBlockColor.		].		^ ladderElementList! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!ladderElements		^ ladderElements! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!ladderElements: anObject		ladderElements := anObject! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!programDecls		^ programDecls! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!programDecls: anObject		programDecls := anObject! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:23'!programList	programList ifNil: [		programList :=	PLC_ListSelector			newWithLibrary: PLC_Function StdFunctions			andColor: PLC_GraphicElementProperties uniqueInstance programHeaderColor			andBorderColor: PLC_GraphicElementProperties uniqueInstance programColor.		].		^ programList! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!stdFuncionBlocks		^ stdFuncionBlocks! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!stdFuncionBlocks: anObject		stdFuncionBlocks := anObject! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!stdFuncions		^ stdFuncions! !!PLC_Libraries methodsFor: 'accessing' stamp: 'EricPernia 11/17/2013 05:16'!stdFuncions: anObject		stdFuncions := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Libraries class	instanceVariableNames: ''!!PLC_Libraries class methodsFor: 'instance creation' stamp: 'EricPernia 5/31/2013 13:16'!clearInstance 	"Devuelve la unica instancia de esta clase."	Instance ifNotNil: 		[		Instance := nil.		].! !!PLC_Libraries class methodsFor: 'instance creation' stamp: 'EricPernia 5/31/2013 13:16'!uniqueInstance 	"Devuelve la unica instancia de esta clase."	Instance ifNil: 		[		Instance := self new.		].		^ Instance.! !Object subclass: #PLC_Identifier	instanceVariableNames: 'identifier'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_Identifier commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Identifier is xxxxxxxxx.Instance Variables	identifier:		<Object>identifier	- xxxxx!!PLC_Identifier methodsFor: 'initialize-release' stamp: 'EricPernia 10/31/2012 00:18'!initialize	"Inicializaciones del identificador"	self identifier: 'id'	! !!PLC_Identifier methodsFor: 'accessing' stamp: 'EricPernia 10/31/2012 00:17'!identifier	^ identifier! !!PLC_Identifier methodsFor: 'accessing' stamp: 'EricPernia 10/31/2012 00:17'!identifier: anObject	identifier := anObject! !!PLC_Identifier methodsFor: 'testing' stamp: 'EricPernia 10/31/2012 00:38'!doNotContainALastUnderlineCharacter: aString	"Responde true si NO contiene un guion bajo como ultimo caracter."	aString ifEmpty: [^false].		^( aString last = $_) not.	"Si da flase deberia mostrar este mensaje de error"		"'Entidad de PLC no válida. No puede terminar con guion bajo.'"! !!PLC_Identifier methodsFor: 'testing' stamp: 'EricPernia 10/31/2012 00:37'!doNotContainConsecutiveUnderlines: aString	"Responde true si NO contiene guiones bajos consecutivos en el string"	aString size > 1		ifTrue: [			^(1 to: aString size - 1) allSatisfy: [ :idx | 				( ((aString at: idx) = $_) and:					((aString at: (idx +1)) = $_) ) not 				]. 			]		ifFalse: [ 			^ true.			]! !!PLC_Identifier methodsFor: 'testing' stamp: 'EricPernia 5/10/2013 12:26'!isValidStringContentForIdentifier: aString	"Responde si el string contiene solo letras, dígitos y guiones bajos. 	Además chequea que no contenga 2 o mas guiones bajos 	consecutivos para utilizarse como nombre de identificador."	^ ( aString allSatisfy: [ :each | each isLetter or: [ each isDigit or: [ each = $_ ] ] ] )  	and: [		( self underlineCorrectsForIdentifier: aString )		and: [			self isValidStringFirstCharacterForIdentifier: aString.			].		].						"Si da flase deberia mostrar este mensaje de error"	"'Identificador No válido. Debe comenzar con una letra o guion bajo y luego puede contener letras, digitos o guiones bajos no consecutivos.'"! !!PLC_Identifier methodsFor: 'testing' stamp: 'EricPernia 10/31/2012 00:30'!isValidStringFirstCharacterForIdentifier: aString	"Responde si el string contiene una letra o guion bajo como primer caracter para utilizarse como nombre de identificador."	^ aString first isLetter or: [ aString first = $_ ].	"Si da flase deberia mostrar este mensaje de error"		"'Identificador No válido. Debe comenzar con una letra o guion bajo y luego puede contener letras, digitos o guiones bajos.'"! !!PLC_Identifier methodsFor: 'testing' stamp: 'EricPernia 10/31/2012 00:29'!isValidStringForIdentifier: aString	"Responde si el string es un nombre de identificador válido."	^ (self isValidStringSizeForIdentifier: aString) and: 		(self isValidStringContentForIdentifier: aString)! !!PLC_Identifier methodsFor: 'testing' stamp: 'EricPernia 10/31/2012 00:28'!isValidStringSizeForIdentifier: aString	"Responde si el string tiene el largo valido para utilizarse como nombre de identificador."	^ aString size <= 31.	"Si da flase deberia mostrar este mensaje de error"	" 'Identificador No válido. Puede tener como máximo 31 caracteres.'"! !!PLC_Identifier methodsFor: 'testing' stamp: 'EricPernia 10/31/2012 00:28'!underlineCorrectsForIdentifier: aString	"Responde true si el string no contiene caracteres guiones bajos consecutivos y	NO contiene un guion bajo como ultimo caracter."	^ (self doNotContainConsecutiveUnderlines: aString) and:		[self doNotContainALastUnderlineCharacter: aString ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Identifier class	instanceVariableNames: ''!!PLC_Identifier class methodsFor: 'as yet unclassified' stamp: 'EricPernia 10/31/2012 00:43'!validatePLCIdentifier: aString	"Valida si el string aString es un nombre de identificador, si es así lo devuelve, si no, lanza un error."	| identifier |		identifier := self new.		( identifier isValidStringForIdentifier: aString )		ifTrue: [			^ aString.			] 		ifFalse: [			self error: 'Identificador no válido. Cierre esta ventana y asigne un identificador según IEC 61131-3 : 2002.'.			]! !PLC_ClassWithIdentifier subclass: #PLC_Project	instanceVariableNames: 'hardwareConfigurations libraries'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_Project commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Project is xxxxxxxxx.Instance Variables	hardwareConfigurations:		<Object>	libraries:		<Object>hardwareConfigurations	- xxxxxlibraries	- xxxxx!!PLC_Project methodsFor: 'Hardware Configuration' stamp: 'EricPernia 11/3/2013 02:51'!addHardwareConfiguration	"Añade una nueva Configuración de Hardware vacía"	| hardConfig |		hardConfig := PLC_HardwareConfiguration new.	hardwareConfigurations add: hardConfig.		^ hardConfig.! !!PLC_Project methodsFor: 'Hardware Configuration' stamp: 'EricPernia 11/2/2013 14:10'!addHardwareConfiguration: hardConfig	"Añade la Configuración de Hardware que le llega como parámetro"	hardwareConfigurations add: hardConfig.		^ hardConfig.! !!PLC_Project methodsFor: 'Hardware Configuration' stamp: 'EricPernia 11/5/2013 02:16'!removeHardwareConfiguration: hardConfig	"Añade la Configuración de Hardware que le llega como parámetro"	hardwareConfigurations remove: hardConfig.		^ hardConfig.! !!PLC_Project methodsFor: 'initialize-release' stamp: 'EricPernia 11/5/2013 03:08'!initialize.	"Inicializo el Proyecto."	libraries := PLC_Libraries uniqueInstance.		hardwareConfigurations := OrderedCollection new.	! !!PLC_Project methodsFor: 'accessing' stamp: 'EricPernia 11/2/2013 14:08'!hardwareConfigurations		^ hardwareConfigurations! !!PLC_Project methodsFor: 'accessing' stamp: 'EricPernia 11/2/2013 14:08'!hardwareConfigurations: anObject		hardwareConfigurations := anObject! !!PLC_Project methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 13:39'!libraries	^ libraries! !!PLC_Project methodsFor: 'accessing' stamp: 'EricPernia 5/31/2013 13:39'!libraries: anObject	libraries := anObject! !!PLC_Project methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 03:10'!projectName	^ self identifier! !!PLC_Project methodsFor: 'accessing' stamp: 'EricPernia 11/2/2013 14:04'!projectName: anObject		self identifier: anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Project class	instanceVariableNames: ''!!PLC_Project class methodsFor: 'instance creation' stamp: 'EricPernia 5/31/2013 13:30'!newWithName: aString 	"Crea una nueva isntancia con el nombre indicado"	| project |		project := self new.	project projectName: aString.		^ project.! !PLC_ClassWithIdentifier subclass: #PLC_Resource	instanceVariableNames: 'softwareConfiguration processor taskConfigurations programConfigurations declarations'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_Resource commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_Resource is xxxxxxxxx.Instance Variables	declarations:		<Object>	processor:		<Object>	programConfigurations:		<Object>	softwareConfiguration:		<Object>	taskConfigurations:		<Object>declarations	- xxxxxprocessor	- xxxxxprogramConfigurations	- xxxxxsoftwareConfiguration	- xxxxxtaskConfigurations	- xxxxx!!PLC_Resource methodsFor: 'initialize-release' stamp: 'EricPernia 11/8/2013 15:10'!initialize	"Inicializaciones de Recurso"	taskConfigurations := OrderedCollection new.	programConfigurations := OrderedCollection new.		declarations := PLC_Resource_Declarations newWithResourceDeclaration: self.		self addTaskConfig: (		PLC_CyclicTaskConfiguration 			newWithName: 'PLeriCScanCycle'		).! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/1/2013 18:02'!cComplie	"Devuelve un String con el Recurso Compilado a código C."	^ 'Recurso compliado en C.'! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 15:36'!cMainC	" Devuelve un String con el Código C que va en el archivo main.c "	| cCode |		cCode := '/* * main.c * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * */// Todos los inlcudes juntos#include "PLeriC.h"/*-----------------------------------------------------------*/int main( void ){	extern PLC_SymbolicRegister CR;	// Se inicializa el Current Result (CR) con el tipo Booleano a true;	CR.TYPE = BOOL;	CR.VALUE.BOOL = true;	// Se inicializa las E/S del Hardware - IMPORTANTE SINO NO ANDA NADA	IO_init();	/* CREACION DE INSTANCIAS DE TAREAS */'.		self taskConfigurations do: [ :each |		cCode := cCode , each cTaskCreate.		].		cCode := cCode , '		/* INICIO DEL PLANIFICADOR	Se inicia el Planificador para que las tareas comiencen a ejecutarse. */		vTaskStartScheduler();	/* Si todo va bien nunca se llegará aquí ya que el planificador estará 	corriendo. Si se ha llegado, entonces es probable que no haya 	suficiente memoria disponible en el heap para crear la tarea Idle. */	for( ;; );	return 0;}/*-----------------------------------------------------------*/void vApplicationMallocFailedHook( void ){	/* This function will only be called if an API call to create a task, queue	or semaphore fails because there is too little heap RAM remaining. */	for( ;; );}/*-----------------------------------------------------------*/void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName ){	/* This function will only be called if a task overflows its stack.  Note	that stack overflow checking does slow down the context switch	implementation. */	for( ;; );}/*-----------------------------------------------------------*/void vApplicationIdleHook( void ){	/* This example does not use the idle hook to perform any processing. */}/*-----------------------------------------------------------*/void vApplicationTickHook( void ){	/* This example does not use the tick hook to perform any processing. */}'.	^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/15/2013 17:06'!cStandardFunctionBlocksC	" Devuelve un String con el Código C que va en el archivo PLC_StdFunctionBlocks.c "	| cCode |		cCode := '/* * PLC_StdFunctionBlocks.c * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* Includes */#include "PLeriC.h"/* PLC Standard Functions - Functions Declarations *//* Los FB se implementan como funciones de C que no retornan valores * y que reciben como parametro un puntero a la estructura de la * FB instancia, que debe ser declarada como STATIC en la funcion * contenedora.*/'.		self calledPOUs standardFunctionBlocks do: [ :each |		cCode := cCode , each cCompile.		].		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/15/2013 17:11'!cStandardFunctionBlocksH	" Devuelve un String con el Código C que va en el archivo PLC_StdFunctionBlocks.h "	| cCode |		cCode := '/* * PLC_StdFunctionBlocks.h * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* En este archivo se guardan los prototipos de funciones * en C de los Bloques de Funcion (FUNCTION_BLOCK) del  * PLC estandar y los tipos de datos para sus instaniancias */#ifndef PLC_STDFB_H_	#define PLC_STDFB_H_		/* Declaraciones de typedef de estructura con las variables de los Bloques de Funcion  */'.		self calledPOUs standardFunctionBlocks do: [ :each |		cCode := cCode , each typeDeclaration cCompile , ''.		].		cCode := cCode , '	/* Prototipos de Funciones en C que implementan los Bloques de Funcion  */'.		self calledPOUs standardFunctionBlocks do: [ :each |		cCode := cCode , each cCompilePrototype.		].		cCode := cCode , '	#endif /* PLC_STDFB_H_ */'.		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/15/2013 17:08'!cStandardFunctionsC	" Devuelve un String con el Código C que va en el archivo PLC_StdFunctions.c "	| cCode |		cCode := '/* * PLC_StdFunctions.c * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* Includes */#include "PLeriC.h"/* PLC Standard Functions - Functions Declarations *//* Las F se implementan como funciones de C que no retornan valores * y que reciben como parametro un puntero a la estructura de la * F, esta variable estructura del tipo de la funcion es unica por * no como el caso de los FB que tienen una variable de su tipo de * estructura por  instancia.*//*-------------------------------------------------------------*/// MOVE SOBRECARGADAvoid PLC_F_MOVE(void* sourceValue, void* destinationValue, uint16_t lenght){	// sourceValue y destinationValue DEBEN SER DEL MISMO TIPO	// VOLCADO DE MEMORIA	PLC_BYTE *source;	PLC_BYTE *destination;	uint16_t i = 0;	source = sourceValue;	destination = destinationValue;	for( i = 0; i < lenght; i++ )	{		*destination = *source;		destination++;		source++;	}}/*-------------------------------------------------------------*/'.		self calledPOUs standardFunctions do: [ :each |		cCode := cCode , each cCompile.		].		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/15/2013 17:12'!cStandardFunctionsH	" Devuelve un String con el Código C que va en el archivo PLC_StdFunctions.h "	| cCode |		cCode := '/* * PLC_StdFunctions.h * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* En este archivo se guardan los prototipos de funciones * en C de las Funciones (FUNCTION) del PLC estandar y * los tipos de datos para sus instaniancias */#ifndef PLC_STDF_H_	#define PLC_STDF_H_		/* Declaraciones de typedef de estructura con las variables de las Funciones */'.		self calledPOUs standardFunctions do: [ :each |		cCode := cCode , each typeDeclaration cCompile , ''.		].		cCode := cCode , '	/* Prototipos de Funciones en C que implementan las Funciones */'.		self calledPOUs standardFunctions do: [ :each |		cCode := cCode , each cCompilePrototype.		].		cCode := cCode , '	#endif /* PLC_STDF_H_ */'.		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 16:01'!cUserProgramsC	" Devuelve un String con el Código C que va en el archivo PLC_UserPrograms.c "	| cCode |		cCode := '/* * PLC_UserPrograms.c * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* Includes */#include "PLeriC.h"/* En este archivo se guardan las definiciones de funciones * en C de los Programas (PROGRAM) del PLC creadas por * el usuario */'.		self calledPOUs userPrograms do: [ :each |		cCode := cCode , each cCompile.		].		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 16:00'!cUserProgramsH	" Devuelve un String con el Código C que va en el archivo PLC_UserPrograms.h "	| cCode |		cCode := '/* * PLC_UserPrograms.h * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* En este archivo se guardan los prototipos de funciones * en C de los Programas (PROGRAM) del PLC creadas por * el usuario y los tipos de datos para sus instaniancias  */#ifndef PLC_USER_PROGRAMS_H_	#define PLC_USER_PROGRAMS_H_	/* Declaraciones de typedef de estructura con las variables del Programa */'.		self calledPOUs userPrograms do: [ :each |		cCode := cCode , each typeDeclaration cCompile , ''.		].		cCode := cCode , '	/* Prototipos de Funciones en C que implementan los Programas */'.		self calledPOUs userPrograms do: [ :each |		cCode := cCode , each cCompilePrototype.		].		cCode := cCode , '	#endif /* PLC_USER_PROGRAMS_H_ */'.		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 16:02'!cUserTasksC	" Devuelve un String con el Código C que va en el archivo PLC_UserTasks.c "	| cCode |		cCode := '/* * PLC_UserTasks.c * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* En este archivo se guardan las declaraciones de funciones * en C de las Tareas (TASK) del PLC creadas por el usuario. * Estas se implementan como funciones periódicas de FreeRtos * con un mutex cada una.*//* Includes */#include "PLeriC.h"	/* Las entradas y salidas fisicas del PLC son variables Globales públicas del tipo volatile */	volatile uint8_t entradas;	volatile uint8_t salidas;	/* Registros de I/O y Memoria como variables globales públicas */	PLC_1ByteRegister  I0;	PLC_1ByteRegister  Q0;	PLC_1KByteRegister M0;	extern PLC_SymbolicRegister CR;		/* Declaraciones de variables simbólicas localizadas */'.	"--------------------------------------------------------------------------------------------------------------	ACA AGREGAR LA COMPILACION DE LAS VARIABLES SIMBOLICAS LOCATED	------------------------------------------------------------------------------------------------------------------"		cCode := cCode , 	'	/* Definiciones de funciones de tareas de freeRTOS que implementan las Tareas del PLC. */'.		self taskConfigurations do: [ :each |		cCode := cCode , each cCompile.		].		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 16:00'!cUserTasksH	" Devuelve un String con el Código C que va en el archivo PLC_UserTasks.h "	| cCode |		cCode := '/* * PLC_UserTasks.h * *  Created on: 2012-02-04 *      Author: Eric N. Pernia * * Archivo generado desde Pharo-Smalltalk  * *//* En este archivo se guardan los prototipos de funciones * en C de las Tareas (TASK) del PLC creadas por el usuario. * Estas se implementan como funciones periódicas de FreeRtos * con un mutex cada una.*/#ifndef PLC_USER_TASKS_H_	#define PLC_USER_TASKS_H_	/* Prototipos de funciones de tareas de freeRTOS que implementan las Tareas del PLC. */'.		self taskConfigurations do: [ :each |		cCode := cCode , each cCompilePrototype.		].		cCode := cCode , '	#endif /* PLC_USER_TASKS_H_ */'.		^ cCode.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/15/2013 15:52'!calledPOUs	"Devuelve un Set con las POU que llama cada Configuración de Programa del Recurso 	y las declaraciones de programas de cada Configuración de Programa."	| pouDecls |		pouDecls := PLC_CalledPOU new.		"Le paso una OC de llamados a programas"	pouDecls addUserPrograms: self programConfigurations.		"Le pido a cada declaracion de programa que usa cada 	configuración de programa que agregue sus pou F y FB 	que llame en su cuerpo"	self programConfigurations do: [ :progConfig |		progConfig declaration addCalledPOUsIn: pouDecls.		 ].		^ pouDecls.! !!PLC_Resource methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 04:05'!ilCompile	"Devuelve un String con el Recurso Compilado a código IL."	| res |		res := '			RESOURCE ' 	, self resourceName 	, ' ON ' 	, self processor identifier	, '				(* Declaraciones de Recurso *)'.	self globalVarDecls		ifNotNil: [ 			res := res ,			self globalVarDecls ilCompile , ''.			].			self externVarDecls		ifNotNil: [ 			res := res ,			self externVarDecls ilCompile , ''.			].	res := res ,'			(* Configuraciones de Tarea *)' .	self taskConfigurations		ifNotNil: [ 			self taskConfigurations do: [ :each | 				res := res , each ilCompile , ''.				].			].	res := res ,'								(* Configuraciones de Programa *)			'.	self programConfigurations		ifNotNil: [ 			self programConfigurations do: [ :each | 				res := res , each ilCompile , ''.				].			].	res := res ,'					END_RESOURCE'.			^ res.	! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!declarations		^ declarations! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!declarations: anObject		declarations := anObject! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:31'!processor		^ processor! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/7/2013 20:31'!processor: anObject		processor := anObject! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!programConfigurations		^ programConfigurations! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!programConfigurations: anObject		programConfigurations := anObject! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!resourceName		^ identifier! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!resourceName: anObject		identifier := anObject! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!softwareConfiguration		^ softwareConfiguration! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!softwareConfiguration: anObject		softwareConfiguration := anObject! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!taskConfigurations		^ taskConfigurations! !!PLC_Resource methodsFor: 'accessing' stamp: 'EricPernia 11/3/2013 02:57'!taskConfigurations: anObject		taskConfigurations := anObject! !!PLC_Resource methodsFor: 'program and task configurations' stamp: 'EricPernia 11/7/2013 18:14'!addProgConfig: aProgConfig	"Añade al Recurso la Configuración de Programa aProgConfig que le llega como parámetro"	self programConfigurations add: aProgConfig.		^ aProgConfig.! !!PLC_Resource methodsFor: 'program and task configurations' stamp: 'EricPernia 11/7/2013 18:07'!addTaskConfig: aTaskConfig	"Añade al Recurso la Configuración de Tarea aTaskConfig que le llega como parámetro"	self taskConfigurations add: aTaskConfig.		aTaskConfig resource: self.		^ aTaskConfig.! !!PLC_Resource methodsFor: 'program and task configurations' stamp: 'EricPernia 11/7/2013 18:07'!removeProgConfig: aProgConfig	"Remueve del Recurso la Configuración de Programa que le llega como parámetro"	self programConfigurations remove: aProgConfig.	^ aProgConfig.! !!PLC_Resource methodsFor: 'program and task configurations' stamp: 'EricPernia 11/7/2013 18:07'!removeTaskConfig: aTaskConfig	"Remueve del Recurso la Configuración de Tarea que le llega como parámetro"	self taskConfigurations remove: aTaskConfig.		aTaskConfig resource: nil.	^ aTaskConfig.! !!PLC_Resource methodsFor: 'declarations' stamp: 'EricPernia 11/7/2013 22:58'!externVarDecls	"Devuelve sis declaraciones de variables globales"	^ self declarations externVarDecls.! !!PLC_Resource methodsFor: 'declarations' stamp: 'EricPernia 11/7/2013 22:58'!globalVarDecls	"Devuelve sis declaraciones de variables globales"	^ self declarations globalVarDecls.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_Resource class	instanceVariableNames: ''!!PLC_Resource class methodsFor: 'instance creation' stamp: 'EricPernia 11/8/2013 03:54'!newWithName: aString andSoftConfig: aSoftConfig andProcessor: aProcessor	"Crea una nueva isntancia con el nombre indicado"	| res |		res := self new.	res resourceName: aString.	res softwareConfiguration: aSoftConfig.	res processor: aProcessor.		^ res.! !PLC_TaskConfiguration subclass: #PLC_CyclicTaskConfiguration	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_CyclicTaskConfiguration commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_CyclicTaskConfiguration is xxxxxxxxx.Instance Variables!!PLC_CyclicTaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/8/2013 01:46'!cCompile	"Devuelve la definicion de función de Tarea de freeRTOS en lenguaje C.	Es la tarea cíclica del Sistema que ejecuta todos los programas sin asociación	con Tareas."			| task |		task := '	/*---------------------------------------------------------------------------------------------------------*/void vPLeriCScanCycleTask(void *pvParameters){		/* DECLARACIONES DE INSTANCIAS DE LOS PROGRAMAS ASOCIADOS A LA TAREA */		'.	"Declaraciones de variables de instancia de Programa sin valor inicial"	 self programConfigurations do: [ :each |		task := task , each instanceOperand declaration cCompileWithoutInitialValue , '			'.		 ].		task := task , '	/* Cada tarea del S.O. freeRTOS contiene un bucle infinito */		for( ;; )	{			/* Lectura de las entradas físicas */		entradas = Read_IN();		I0 = Convert_Uint8_t_2_PLC_1ByteRegister(entradas);						/* LLAMADOS A PROGRAMAS ASOCIADOS A LA TAREA PLC */		' .			"Llamados a Programa compilados a C"	 self programConfigurations do: [ :each |		task := task , each cCompile , '		'.		 ].			task := task , 			'		/* Escritura de salidas físicas */		salidas = Convert_PLC_1ByteRegister_2_Uint8_t( Q0 );		Write_OUT(salidas);			}}'.							^ task.			! !!PLC_CyclicTaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/7/2013 19:17'!cCompilePrototype	"Devuelve la definicion de función de Tarea de freeRTOS en lenguaje C.	Es la tarea cíclica del Sistema que ejecuta todos los programas sin asociación	con Tareas."				^ '		void vPLeriCScanCycleTask(void *);'.! !!PLC_CyclicTaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/7/2013 19:22'!cTaskCreate	"Devuelve la definicion de función de Tarea de freeRTOS en lenguaje C.	Es la tarea cíclica del Sistema que ejecuta todos los programas sin asociación	con Tareas."	"Tiene prioridad 0. En freeRTOS es la menor prioridad."			^ '		/* Crea una instancia de Tarea ciclica PLeriC Scan cycle. */	xTaskCreate( vPLeriCScanCycleTask, "PLeriC Scan cycle", 512, NULL, 0, NULL );'.! !!PLC_CyclicTaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/7/2013 19:06'!ilCompile	"La tarea ciclica del sistema no genera codigo IL."		^ ''.	! !!PLC_CyclicTaskConfiguration methodsFor: 'compilation' stamp: 'EricPernia 11/7/2013 19:22'!taskCPriority	"Devuelve el valor de prioridad de la Tarea c como String."	"Tiene prioridad 0. En freeRTOS es la menor prioridad."		^ '0'.! !PLC_ClassWithIdentifier subclass: #PLC_CPU	instanceVariableNames: 'currentResult programCounter stackPointer stack'	classVariableNames: 'FirstCheckFlag_BORRAME'	poolDictionaries: ''	category: 'IDE4PLC-Project'!!PLC_CPU commentStamp: '<historical>' prior: 0!Copyright © 2012-2014 Eric Nicolás Pernia.This class is part of IDE4PLC.IDE4PLC is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.IDE4PLC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public License along with IDE4PLC. If not, see <http://www.gnu.org/licenses/>.------------------------------------------------------------------A PLC_CPU is xxxxxxxxx.Instance Variables	currentResult:		<Object>	programCounter:		<Object>	stack:		<Object>	stackPointer:		<Object>currentResult	- xxxxxprogramCounter	- xxxxxstack	- xxxxxstackPointer	- xxxxx!!PLC_CPU methodsFor: 'initialize-release' stamp: 'EricPernia 11/7/2013 21:49'!initialize	"Inicializaciones"		stack := 0.	stackPointer := 0.	programCounter := 0.	currentResult := 0.! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!currentResult	^ currentResult! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!currentResult: anObject	currentResult := anObject! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!programCounter	^ programCounter! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!programCounter: anObject	programCounter := anObject! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!stack	^ stack! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!stack: anObject	stack := anObject! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!stackPointer	^ stackPointer! !!PLC_CPU methodsFor: 'accessing' stamp: 'EricPernia 7/28/2012 01:57'!stackPointer: anObject	stackPointer := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PLC_CPU class	instanceVariableNames: ''!!PLC_CPU class methodsFor: 'accessing' stamp: 'EricPernia 9/1/2012 19:19'!firstCheckFlag_BORRAME	^ FirstCheckFlag_BORRAME! !!PLC_CPU class methodsFor: 'accessing' stamp: 'EricPernia 9/1/2012 19:19'!firstCheckFlag_BORRAME: anObject	FirstCheckFlag_BORRAME := anObject! !!PLC_CPU class methodsFor: 'instance creation' stamp: 'EricPernia 11/7/2013 21:50'!lpc1769	"Devuelve una instancia de PLC PLeriC"	| cpu |		cpu := self new.		cpu identifier: 'NXP_LPC1769_Microcontroller'.		^ cpu.! !PLeriC initialize!